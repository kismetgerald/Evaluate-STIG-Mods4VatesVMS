##########################################################################
# Evaluate-STIG module
# --------------------
# STIG:     Debian 12 GPOS (General Purpose Operating System)
# Version:  V3R2 (adapted for Debian 12 Bookworm)
# Class:    UNCLASSIFIED
# Updated:  January 18, 2026
# Author:   Debian 12 STIG Compliance Contributors
#
# Implementation Status: COMPLETE STUB COVERAGE (198 functions)
# All functions return Not_Reviewed for baseline framework testing
##########################################################################
$ErrorActionPreference = "Stop"

#requires -version 7.1

################################################################################
# Helper Functions
################################################################################

Function Get-DebianVersion {
    <#
    .SYNOPSIS
        Retrieves Debian version information for conditional check execution
    #>

    if ($null -eq $DebianVersionInfo) {
        $Global:DebianVersionInfo = @{
            'IsDebian' = $false
            'Version' = ''
            'MajorVersion' = 0
            'PackageManager' = ''
        }

        # Check for Debian-specific files
        if (Test-Path '/etc/debian_version' -ErrorAction SilentlyContinue) {
            $Global:DebianVersionInfo['IsDebian'] = $true
            $version = Get-Content '/etc/debian_version' 2>/dev/null
            $Global:DebianVersionInfo['Version'] = $version

            if ($version -match '^12') {
                $Global:DebianVersionInfo['MajorVersion'] = 12
            }
        }

        # Detect package manager
        if (Test-Path '/usr/bin/apt' -ErrorAction SilentlyContinue) {
            $Global:DebianVersionInfo['PackageManager'] = 'apt'
        }
        elseif (Test-Path '/usr/bin/dpkg' -ErrorAction SilentlyContinue) {
            $Global:DebianVersionInfo['PackageManager'] = 'dpkg'
        }
    }

    return $Global:DebianVersionInfo
}

Function Get-FirewallStatus {
    <#
    .SYNOPSIS
        Detects active firewall(s) on Debian 12 (Xen Orchestra context)
    .DESCRIPTION
        Checks for UFW, firewalld, nftables, iptables. Returns status and details.
    #>
    $firewalls = @()
    $details = @()
    # UFW
    if (Get-Command ufw -ErrorAction SilentlyContinue) {
        $ufwStatus = (ufw status 2>&1)
        if ($ufwStatus -match 'Status: active') {
            $firewalls += 'ufw'
            $details += "UFW: $ufwStatus"
        }
    }
    # firewalld
    if (Get-Command firewall-cmd -ErrorAction SilentlyContinue) {
        $fwStatus = (firewall-cmd --state 2>&1)
        if ($fwStatus -match 'running') {
            $firewalls += 'firewalld'
            $details += "firewalld: $fwStatus"
        }
    }
    # nftables
    if (Get-Command nft -ErrorAction SilentlyContinue) {
        $nftStatus = (nft list ruleset 2>&1)
        if ($nftStatus -and $nftStatus -notmatch 'command not found|No such file') {
            $firewalls += 'nftables'
            $details += "nftables: ruleset present"
        }
    }
    # iptables
    if (Get-Command iptables -ErrorAction SilentlyContinue) {
        $iptStatus = (iptables -L 2>&1)
        if ($iptStatus -and $iptStatus -notmatch 'No chain|No such file') {
            $firewalls += 'iptables'
            $details += "iptables: rules present"
        }
    }
    return @{ Firewalls = $firewalls; Details = $details }
}

Function Get-XODeploymentModel {
    <#
    .SYNOPSIS
        Detects whether this is XOA (Appliance) or XOCE (Community Edition)
    .DESCRIPTION
        XOA: Official Vates appliance — UFW firewall enabled by default, installs to /usr/share/xo-server
        XOCE: Built from source — no default firewall, installs to /opt/xo
        Results cached in $Global:XODeploymentModel to avoid repeated checks.
    #>

    if ($null -ne $Global:XODeploymentModel) {
        return $Global:XODeploymentModel
    }

    $Global:XODeploymentModel = @{
        Model = "Unknown"
        Details = ""
    }

    $xoaMarkers = @(
        "/usr/share/xo-server",
        "/usr/local/share/xo-server"
    )
    $xoceMarkers = @(
        "/opt/xo/xo-server",
        "/opt/xo/xo-src"
    )

    $isXOA = $false
    $isXOCE = $false

    foreach ($p in $xoaMarkers) {
        $check = $(timeout 3 test -d $p 2>&1; echo $LASTEXITCODE)
        $checkStr = ($check -join " ").Trim()
        if ($checkStr -match "0$") { $isXOA = $true; break }
    }

    if (-not $isXOA) {
        $xoaUpdater = $(timeout 3 which xoa-updater 2>&1)
        $xoaUpdaterStr = ($xoaUpdater -join " ").Trim()
        if ($xoaUpdaterStr -and $xoaUpdaterStr -notmatch "not found|no xoa-updater") {
            $isXOA = $true
        }
    }

    if (-not $isXOA) {
        foreach ($p in $xoceMarkers) {
            $check = $(timeout 3 test -d $p 2>&1; echo $LASTEXITCODE)
            $checkStr = ($check -join " ").Trim()
            if ($checkStr -match "0$") { $isXOCE = $true; break }
        }
    }

    if ($isXOA) {
        $Global:XODeploymentModel.Model = "XOA"
        $Global:XODeploymentModel.Details = "XOA (Appliance) — UFW firewall enabled by default"
    }
    elseif ($isXOCE) {
        $Global:XODeploymentModel.Model = "XOCE"
        $Global:XODeploymentModel.Details = "XOCE (Community Edition) — no default firewall; must be configured manually"
    }
    else {
        $Global:XODeploymentModel.Details = "Unable to determine XO deployment model"
    }

    return $Global:XODeploymentModel
}

Function Get-XOAuditPluginInfo {
    <#
    .SYNOPSIS
        Checks XO Audit Plugin status via REST API. Cached per scan session.
    .DESCRIPTION
        Queries Xen Orchestra REST API to determine if the audit plugin is active
        and has recent audit records. Uses 3-source token lookup.
        Results cached in $Global:XOAuditPluginInfo to avoid repeated API calls.
        Reference: https://docs.xen-orchestra.com/users#audit-log
    #>

    if ($null -ne $Global:XOAuditPluginInfo) {
        return $Global:XOAuditPluginInfo
    }

    $Global:XOAuditPluginInfo = @{
        Enabled      = $false
        RecordCount  = 0
        HasIntegrity = $false
        TokenFound   = $false
        TokenSource  = ""
        Details      = ""
    }

    $token = $null
    $tokenSource = ""

    # Priority 1: Server-side token file (recommended for STIG scans)
    if (Test-Path "/etc/xo-server/stig/api-token" -ErrorAction SilentlyContinue) {
        $tokenContent = $(timeout 5 cat /etc/xo-server/stig/api-token 2>&1)
        if ($LASTEXITCODE -eq 0 -and $tokenContent) {
            $token = ($tokenContent -join "").Trim()
            $tokenSource = "/etc/xo-server/stig/api-token"
        }
    }

    # Priority 2: Environment variable
    if (-not $token -and $env:XO_API_TOKEN) {
        $token = $env:XO_API_TOKEN
        $tokenSource = "XO_API_TOKEN environment variable"
    }

    # Priority 3: CLI config file
    if (-not $token -and (Test-Path "/var/lib/xo-server/.xo-cli" -ErrorAction SilentlyContinue)) {
        $cliContent = $(timeout 5 cat /var/lib/xo-server/.xo-cli 2>&1)
        if ($LASTEXITCODE -eq 0 -and $cliContent) {
            try {
                $cliObj = ($cliContent -join "") | ConvertFrom-Json -ErrorAction SilentlyContinue
                $firstServer = $cliObj.PSObject.Properties | Select-Object -First 1
                if ($firstServer -and $firstServer.Value.token) {
                    $token = $firstServer.Value.token
                    $tokenSource = "/var/lib/xo-server/.xo-cli"
                }
            }
            catch { }
        }
    }

    if (-not $token) {
        $Global:XOAuditPluginInfo.Details = "API token not found"
        return $Global:XOAuditPluginInfo
    }

    $Global:XOAuditPluginInfo.TokenFound = $true
    $Global:XOAuditPluginInfo.TokenSource = $tokenSource
    $sq = [char]39

    # Detect audit plugin by querying its REST endpoint directly
    # Note: /rest/v0/plugins is NOT a valid collection endpoint — each plugin
    # registers sub-routes under /rest/v0/plugins/<name>/. We test the audit
    # plugin by querying its records endpoint; a valid response means it is loaded.
    $recordArgs = "timeout 10 curl -s -k -H ${sq}Cookie: authenticationToken=${token}${sq} ${sq}https://localhost/rest/v0/plugins/audit/records?limit=10${sq} 2>/dev/null"
    $recordsJson = $(sh -c $recordArgs 2>&1)

    if ($LASTEXITCODE -ne 0 -or -not $recordsJson) {
        $Global:XOAuditPluginInfo.Details = "Unable to query XO REST API at /rest/v0/plugins/audit/records"
        return $Global:XOAuditPluginInfo
    }

    $recordsStr = ($recordsJson -join "")

    # If the response is HTML (e.g., "Cannot GET ..."), the plugin is not loaded
    if ($recordsStr -match "<!DOCTYPE|Cannot GET|<html") {
        $Global:XOAuditPluginInfo.Details = "Audit plugin REST endpoint not available (plugin may not be loaded)"
        return $Global:XOAuditPluginInfo
    }

    # Plugin is loaded — the endpoint responded with data
    $Global:XOAuditPluginInfo.Enabled = $true
    $Global:XOAuditPluginInfo.Details = "Audit plugin detected and active"

    try {
        $records = $recordsStr | ConvertFrom-Json -ErrorAction SilentlyContinue
        if ($records -is [Array]) {
            $Global:XOAuditPluginInfo.RecordCount = $records.Count
        }
    }
    catch { }

    # Check one record for hash chain integrity fields
    # XO audit records use SHA256 IDs (format: "$5$$<hash>") and "previousId" for chain linking
    if ($Global:XOAuditPluginInfo.RecordCount -gt 0) {
        $firstId = $records[0]
        # URL-encode the record ID (contains $ characters)
        $encodedId = [Uri]::EscapeDataString($firstId)
        $detailArgs = "timeout 10 curl -s -k -H ${sq}Cookie: authenticationToken=${token}${sq} ${sq}https://localhost/rest/v0/plugins/audit/records/${encodedId}${sq} 2>/dev/null"
        $detailJson = $(sh -c $detailArgs 2>&1)
        if ($detailJson) {
            $detailStr = ($detailJson -join "")
            if ($detailStr -match "previousId|nonce|previousRecord") {
                $Global:XOAuditPluginInfo.HasIntegrity = $true
            }
            elseif ($detailStr -match "subject|event|time") {
                # Record has standard fields — integrity chain likely present
                $Global:XOAuditPluginInfo.HasIntegrity = $true
            }
        }
    }

    return $Global:XOAuditPluginInfo
}

Function Get-XOAuthLdapInfo {
    <#
    .SYNOPSIS
        Checks if XO uses auth-ldap plugin for AD/LDAP authentication delegation.
        Cached per scan session.
    .DESCRIPTION
        Detects the auth-ldap plugin by checking XO configuration files for LDAP
        settings and optionally verifying the plugin package. When auth-ldap is
        active, authentication/authorization is offloaded to Active Directory,
        which satisfies several STIG requirements through delegation.
        Results cached in $Global:XOAuthLdapInfo to avoid repeated checks.
    #>

    if ($null -ne $Global:XOAuthLdapInfo) {
        return $Global:XOAuthLdapInfo
    }

    $nl = [Environment]::NewLine
    $Global:XOAuthLdapInfo = @{
        Enabled    = $false
        LdapUri    = ""
        BaseDN     = ""
        Details    = ""
    }

    # Check 1: XO config files for auth-ldap settings
    $configPaths = @(
        "/opt/xo/xo-server/config.toml",
        "/etc/xo-server/config.toml",
        "/opt/xo/xo-server/.xo-server.yaml",
        "/etc/xo-server/config.yaml"
    )
    foreach ($cfgPath in $configPaths) {
        $cfgContent = $(timeout 5 cat $cfgPath 2>/dev/null)
        if ($LASTEXITCODE -eq 0 -and $cfgContent) {
            $cfgStr = ($cfgContent -join $nl)
            # Look for auth-ldap plugin configuration
            if ($cfgStr -match "auth-ldap|auth_ldap|authLdap") {
                $Global:XOAuthLdapInfo.Enabled = $true
                $Global:XOAuthLdapInfo.Details = "auth-ldap configured in $cfgPath"
                # Extract LDAP URI
                if ($cfgStr -match "(?i)url\s*=\s*[" + [char]34 + "']?(ldaps?://[^" + [char]34 + "'\s]+)") {
                    $Global:XOAuthLdapInfo.LdapUri = $matches[1]
                }
                # Extract Base DN
                if ($cfgStr -match "(?i)base\s*=\s*[" + [char]34 + "']?([^" + [char]34 + "'\s]+)") {
                    $Global:XOAuthLdapInfo.BaseDN = $matches[1]
                }
                return $Global:XOAuthLdapInfo
            }
        }
    }

    # Check 2: Look for auth-ldap package in XO node_modules
    $pluginPaths = @(
        "/opt/xo/xo-server/node_modules/xo-server-auth-ldap",
        "/opt/xo/node_modules/xo-server-auth-ldap",
        "/usr/local/lib/node_modules/xo-server/node_modules/xo-server-auth-ldap",
        "/opt/xen-orchestra/packages/xo-server-auth-ldap"
    )
    foreach ($plugPath in $pluginPaths) {
        if (Test-Path $plugPath -ErrorAction SilentlyContinue) {
            $Global:XOAuthLdapInfo.Enabled = $true
            $Global:XOAuthLdapInfo.Details = "auth-ldap plugin found at $plugPath"
            return $Global:XOAuthLdapInfo
        }
    }

    # Check 3: Query XO REST API for plugin configuration (if token available)
    $auditInfo = Get-XOAuditPluginInfo
    if ($auditInfo.TokenFound) {
        $sq = [char]39
        $token = ""
        # Re-read token (same priority as audit plugin)
        if (Test-Path "/etc/xo-server/stig/api-token" -ErrorAction SilentlyContinue) {
            $tokenContent = $(timeout 5 cat /etc/xo-server/stig/api-token 2>&1)
            if ($LASTEXITCODE -eq 0 -and $tokenContent) { $token = ($tokenContent -join "").Trim() }
        }
        if (-not $token -and $env:XO_API_TOKEN) { $token = $env:XO_API_TOKEN }
        if (-not $token -and (Test-Path "/var/lib/xo-server/.xo-cli" -ErrorAction SilentlyContinue)) {
            $cliContent = $(timeout 5 cat /var/lib/xo-server/.xo-cli 2>&1)
            if ($LASTEXITCODE -eq 0 -and $cliContent) {
                try {
                    $cliObj = ($cliContent -join "") | ConvertFrom-Json -ErrorAction SilentlyContinue
                    $firstServer = $cliObj.PSObject.Properties | Select-Object -First 1
                    if ($firstServer -and $firstServer.Value.token) { $token = $firstServer.Value.token }
                }
                catch { }
            }
        }

        if ($token) {
            # Query XO users to check for LDAP-authenticated users
            $usersArgs = "timeout 10 curl -s -k -H ${sq}Cookie: authenticationToken=${token}${sq} ${sq}https://localhost/rest/v0/users${sq} 2>/dev/null"
            $usersJson = $(sh -c $usersArgs 2>&1)
            if ($LASTEXITCODE -eq 0 -and $usersJson) {
                $usersStr = ($usersJson -join "")
                if ($usersStr -match "authProviders.*ldap|auth-ldap") {
                    $Global:XOAuthLdapInfo.Enabled = $true
                    $Global:XOAuthLdapInfo.Details = "LDAP-authenticated users detected via REST API"
                    return $Global:XOAuthLdapInfo
                }
            }
        }
    }

    # Check 4: OS-level LDAP integration (SSSD/nslcd with AD provider)
    $sssdActive = $(timeout 5 systemctl is-active sssd 2>&1)
    if (($sssdActive -join "").Trim() -eq "active") {
        $sssdConf = $(timeout 5 cat /etc/sssd/sssd.conf 2>/dev/null)
        if ($LASTEXITCODE -eq 0 -and $sssdConf) {
            $sssdStr = ($sssdConf -join $nl)
            if ($sssdStr -match "id_provider\s*=\s*(ldap|ad)|auth_provider\s*=\s*(ldap|ad|krb5)") {
                $Global:XOAuthLdapInfo.Enabled = $true
                $Global:XOAuthLdapInfo.Details = "SSSD active with LDAP/AD provider"
                if ($sssdStr -match "ldap_uri\s*=\s*(\S+)") {
                    $Global:XOAuthLdapInfo.LdapUri = $matches[1]
                }
                if ($sssdStr -match "ldap_search_base\s*=\s*(\S+)") {
                    $Global:XOAuthLdapInfo.BaseDN = $matches[1]
                }
                return $Global:XOAuthLdapInfo
            }
        }
    }

    $Global:XOAuthLdapInfo.Details = "No LDAP/AD authentication integration detected"
    return $Global:XOAuthLdapInfo
}

Function CheckPermissions {
    param(
        [string]$FindPath,
        [ValidateSet("File", "Directory")]
        [string]$Type,
        [int]$MinPerms,
        [switch]$Recurse
    )

    $permMask = "{0:D4}" -f $(7777 - $MinPerms)

    if ($Recurse) {
        if ($Type -eq "File") {
            $result = @(find $FindPath -xdev -not -path '*/.*' -not -type l -type f -perm /$permMask -printf "%04m %p\n" 2>/dev/null)
        }
        elseif ($Type -eq "Directory") {
            $result = @(find $FindPath -xdev -not -path '*/.*' -not -type l -type d -perm /$permMask -printf "%04m %p\n" 2>/dev/null)
        }
        else {
            $result = @(find $FindPath -xdev -not -path '*/.*' -not -type l -perm /$permMask -printf "%04m %p\n" 2>/dev/null)
        }
    }
    else {
        if ($Type -eq "File") {
            $result = @(find $FindPath -maxdepth 1 -not -path '*/.*' -not -type l -type f -perm /$permMask -printf "%04m %p\n" 2>/dev/null)
        }
        elseif ($Type -eq "Directory") {
            $result = @(find $FindPath -maxdepth 0 -not -path '*/.*' -not -type l -type d -perm /$permMask -printf "%04m %p\n" 2>/dev/null)
        }
        else {
            $result = @(find $FindPath -maxdepth 0 -not -path '*/.*' -not -type l -perm /$permMask -printf "%04m %p\n" 2>/dev/null)
        }
    }

    if ($result.Count -eq 0 -or $null -eq $result) {
        return $true
    }
    else {
        return $result
    }
}

Function Get-PackageStatus {
    <#
    .SYNOPSIS
        Checks if a package is installed using Debian apt/dpkg
    #>
    param(
        [string]$PackageName
    )
    try {
        $installed = dpkg -l | grep -c "^ii.*$PackageName" 2>/dev/null
        return ($installed -gt 0)
    }
    catch {
        return $false
    }
}

Function FormatFinding {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory, Position = 0)]
        [AllowNull()]
        $finding
    )

    # insert separator line between $FindingMessage and $finding
    $BarLine = '------------------------------------------------------------------------'
    $FormattedFinding = $BarLine | Out-String

    # building a string to properly format new lines between findings and each bar line when argument is an array
    $joiner = '' | Out-String | Out-String
    $joiner += $BarLine | Out-String

    # if $finding is an array, '-join' will combine the items in the array together into a String with the bar and new line separators
    # if $finding is not an array, this will simply set $combined_finding to the value of $finding
    $combined_finding = $finding -join $joiner

    # insert findings
    $FormattedFinding += $combined_finding | Out-String

    return $FormattedFinding
}

################################################################################
# GPOS Compliance Check Functions (Debian 12 Adapted)
################################################################################

Function Get-V203591 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203591
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203591r958362_rule
        Rule Title : The operating system must provide automated mechanisms for supporting account management functions.
        DiscussMD5 : e8745279a444350222f06bee7279dcae
        CheckMD5   : 4260619870759950e8b45eaf04fe931b
        FixMD5     : a60e7461cd14b14bd7e412bd6471c425
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203591"
    $RuleID = "SV-203591r958362_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Account management tools available
    $output += "Check 1: Account Management Tools${nl}"
    try {
        $tools = @("useradd", "usermod", "userdel", "chage", "passwd", "groupadd")
        $foundTools = @()
        $missingTools = @()
        foreach ($tool in $tools) {
            $which = $(which $tool 2>&1)
            $whichStr = ($which -join $nl).Trim()
            if ($whichStr -and $whichStr -notmatch "not found") {
                $foundTools += $tool
            }
            else {
                $missingTools += $tool
            }
        }
        $output += "  Found: $($foundTools -join ', ')${nl}"
        if ($missingTools.Count -gt 0) {
            $output += "  Missing: $($missingTools -join ', ')${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM account management modules
    $output += "Check 2: PAM Account Management Configuration${nl}"
    try {
        $pamAccount = $(timeout 5 cat /etc/pam.d/common-account 2>&1)
        $pamStr = ($pamAccount -join $nl).Trim()
        if ($pamStr -match "pam_unix\.so") {
            $output += "  [PASS] pam_unix.so configured for account management${nl}"
        }
        else {
            $output += "  [FAIL] pam_unix.so not found in common-account${nl}"
        }
        if ($pamStr -match "pam_faillock\.so|pam_tally2\.so") {
            $output += "  [PASS] Account lockout module configured${nl}"
        }
        else {
            $output += "  [INFO] No account lockout module (pam_faillock/pam_tally2)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: LDAP/AD integration (centralized account management)
    $output += "Check 3: Centralized Account Management${nl}"
    try {
        $sssd = $(timeout 5 systemctl is-active sssd 2>&1)
        $sssdStr = ($sssd -join $nl).Trim()
        $nslcd = $(timeout 5 systemctl is-active nslcd 2>&1)
        $nslcdStr = ($nslcd -join $nl).Trim()
        $pamLdap = $(timeout 5 dpkg -l libpam-ldapd 2>&1)
        $pamLdapStr = ($pamLdap -join $nl).Trim()

        if ($sssdStr -eq "active") {
            $output += "  [PASS] SSSD active (centralized account management)${nl}"
            $Status = "NotAFinding"
        }
        elseif ($nslcdStr -eq "active") {
            $output += "  [PASS] nslcd active (LDAP account management)${nl}"
            $Status = "NotAFinding"
        }
        elseif ($pamLdapStr -match "^ii\s+libpam-ldapd") {
            $output += "  [INFO] libpam-ldapd installed (LDAP integration available)${nl}"
        }
        else {
            $output += "  [INFO] No centralized account management detected (SSSD/LDAP)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: Account lifecycle (useradd defaults)
    $output += "Check 4: Account Lifecycle Defaults${nl}"
    try {
        $defaults = $(timeout 5 useradd -D 2>&1)
        $defaultsStr = ($defaults -join $nl).Trim()
        if ($defaultsStr) {
            $output += "  useradd defaults:${nl}"
            foreach ($line in ($defaultsStr -split $nl)) {
                $output += "    $line${nl}"
            }
        }
        # If all 6 tools present AND (SSSD/LDAP active OR local tools functional)
        if ($foundTools.Count -ge 5 -and $Status -ne "NotAFinding") {
            $output += "  [INFO] Local account management tools available but no centralized management${nl}"
            $output += "  [INFO] Verify organizational account management procedures are documented${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203592 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203592
        STIG ID    : SRG-OS-000002-GPOS-00002
        Rule ID    : SV-203592r958364_rule
        Rule Title : The operating system must automatically remove or disable temporary user accounts after 72 hours.
        DiscussMD5 : 83e9e5509dadc0e5cbfd813054b47310
        CheckMD5   : 3a997104c141f6faca3ccfbcdec10683
        FixMD5     : 2826c55467d5801f7fcb83bb792dc41e
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203592"
    $RuleID = "SV-203592r958364_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Identify temporary/emergency accounts with expiration dates
    $output += "Check 1: Account Expiration Configuration${nl}"
    try {
        $shadowContent = $(timeout 5 cat /etc/shadow 2>&1)
        $shadowStr = ($shadowContent -join $nl).Trim()
        $expiredAccts = @()
        $noExpiry = @()
        $systemAccts = @("root", "daemon", "bin", "sys", "sync", "games", "man", "lp", "mail", "news", "uucp", "proxy", "www-data", "backup", "list", "irc", "gnats", "nobody", "systemd-network", "systemd-resolve", "messagebus", "sshd", "_apt", "systemd-timesync")

        foreach ($line in ($shadowStr -split $nl)) {
            if ($line -match "^([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):") {
                $acctName = $matches[1]
                $hashField = $matches[2]
                $expireField = $matches[8]

                # Skip system accounts and locked accounts
                if ($acctName -in $systemAccts) { continue }
                if ($hashField -match "^[!*]") { continue }

                if ($expireField -and $expireField -match "^\d+$") {
                    $expireDays = [int]$expireField
                    $expireDate = (Get-Date "1970-01-01").AddDays($expireDays)
                    $output += "  Account: $acctName - Expires: $($expireDate.ToString('yyyy-MM-dd'))${nl}"
                    $expiredAccts += $acctName
                }
                else {
                    $noExpiry += $acctName
                    $output += "  Account: $acctName - No expiration set${nl}"
                }
            }
        }
        if ($noExpiry.Count -eq 0 -and $expiredAccts.Count -eq 0) {
            $output += "  [INFO] No interactive user accounts found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: useradd default EXPIRE setting
    $output += "Check 2: Default Account Expiration (useradd -D)${nl}"
    try {
        $defaults = $(timeout 5 useradd -D 2>&1)
        $defaultsStr = ($defaults -join $nl).Trim()
        if ($defaultsStr -match "EXPIRE=(\S*)") {
            $expireDefault = $matches[1]
            if ($expireDefault -and $expireDefault -ne "") {
                $output += "  [PASS] Default EXPIRE: $expireDefault${nl}"
            }
            else {
                $output += "  [FAIL] Default EXPIRE is empty (no automatic expiration)${nl}"
            }
        }
        else {
            $output += "  [FAIL] EXPIRE not found in useradd defaults${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Automated account cleanup (cron/systemd timer)
    $output += "Check 3: Automated Account Cleanup Mechanism${nl}"
    try {
        $cronCheck = $(timeout 5 grep -r "userdel\|usermod.*--expiredate\|chage" /etc/cron.d/ /etc/cron.daily/ /var/spool/cron/ 2>&1)
        $cronStr = ($cronCheck -join $nl).Trim()
        $timerCheck = $(timeout 5 systemctl list-timers --all 2>&1)
        $timerStr = ($timerCheck -join $nl).Trim()

        if ($cronStr -and $cronStr -notmatch "No such file") {
            $output += "  [PASS] Account cleanup cron jobs detected${nl}"
            $Status = "NotAFinding"
        }
        elseif ($timerStr -match "account.*clean|user.*expire|cleanup") {
            $output += "  [PASS] Account cleanup systemd timer detected${nl}"
            $Status = "NotAFinding"
        }
        else {
            $output += "  [INFO] No automated account cleanup mechanism found${nl}"
            $output += "  [INFO] Verify organizational procedures for temporary account management${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203593 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203593
        STIG ID    : SRG-OS-000004-GPOS-00004
        Rule ID    : SV-203593r958368_rule
        Rule Title : The operating system must audit all account creations.
        DiscussMD5 : 61e3b8c1a541421dcc6d54f430ffb538
        CheckMD5   : 961656542c8f3332ad649bb9a2a3eef0
        FixMD5     : acdea85dc814b4efdb6d5df6b84e433a
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203593"
    $RuleID = "SV-203593r958368_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Verify auditd is running
    $output += "Check 1: Audit Service Status${nl}"
    try {
        $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
        $auditdStr = ($auditdStatus -join $nl).Trim()
        if ($auditdStr -eq "active") {
            $output += "  [PASS] auditd is active${nl}"
        }
        else {
            $output += "  [FAIL] auditd is not active: $auditdStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Audit rules for account creation files
    $output += "Check 2: Audit Rules for Account Creation${nl}"
    try {
        $auditRules = $(timeout 5 auditctl -l 2>&1)
        $rulesStr = ($auditRules -join $nl).Trim()

        $requiredFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow", "/etc/security/opasswd")
        $foundRules = @()
        $missingRules = @()

        foreach ($file in $requiredFiles) {
            if ($rulesStr -match [regex]::Escape($file)) {
                $foundRules += $file
                $matchedRule = ($rulesStr -split $nl | Where-Object { $_ -match [regex]::Escape($file) }) | Select-Object -First 1
                $output += "  [PASS] Watch rule found: $matchedRule${nl}"
            }
            else {
                $missingRules += $file
                $output += "  [FAIL] No watch rule for: $file${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Persistent audit rules in rules.d
    $output += "Check 3: Persistent Audit Rules${nl}"
    try {
        $persistRules = $(timeout 10 grep -r "passwd\|shadow\|group\|gshadow\|opasswd" /etc/audit/rules.d/ 2>&1)
        $persistStr = ($persistRules -join $nl).Trim()
        if ($persistStr -and $persistStr -notmatch "No such file") {
            $output += "  [PASS] Persistent rules found in /etc/audit/rules.d/${nl}"
            foreach ($line in ($persistStr -split $nl | Select-Object -First 5)) {
                $output += "    $line${nl}"
            }
        }
        else {
            $output += "  [FAIL] No persistent rules for account files in /etc/audit/rules.d/${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($auditdStr -eq "active" -and $foundRules.Count -ge 3) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203594 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203594
        STIG ID    : SRG-OS-000021-GPOS-00005
        Rule ID    : SV-203594r958388_rule
        Rule Title : The operating system must enforce the limit of three consecutive invalid logon attempts by a user during a 15-minute time period.
        DiscussMD5 : e5184ee108663cd818b13b5900586349
        CheckMD5   : f94712e2958b5fe7765acfa5e1a3048c
        FixMD5     : f766fbe920f5893fe81bb66e8cdd28a8
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203594"
    $RuleID = "SV-203594r958388_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: PAM faillock configuration
    $output += "Check 1: PAM Account Lockout (pam_faillock)${nl}"
    try {
        $pamAuth = $(timeout 5 cat /etc/pam.d/common-auth 2>&1)
        $pamAuthStr = ($pamAuth -join $nl).Trim()

        if ($pamAuthStr -match "pam_faillock\.so") {
            $output += "  [PASS] pam_faillock.so configured in common-auth${nl}"
            # Extract deny parameter
            if ($pamAuthStr -match "pam_faillock\.so.*deny=(\d+)") {
                $denyCount = [int]$matches[1]
                $output += "  deny=$denyCount (max attempts before lockout)${nl}"
                if ($denyCount -le 3) {
                    $output += "  [PASS] Meets DoD 3-attempt requirement${nl}"
                }
                else {
                    $output += "  [FAIL] Exceeds DoD 3-attempt limit${nl}"
                }
            }
            # Extract fail_interval (unlock_time)
            if ($pamAuthStr -match "pam_faillock\.so.*fail_interval=(\d+)") {
                $failInterval = [int]$matches[1]
                $output += "  fail_interval=$failInterval seconds${nl}"
                if ($failInterval -ge 900) {
                    $output += "  [PASS] Meets DoD 15-minute (900s) window requirement${nl}"
                }
                else {
                    $output += "  [FAIL] Below DoD 15-minute (900s) window requirement${nl}"
                }
            }
        }
        else {
            $output += "  [INFO] pam_faillock.so not found in common-auth${nl}"
        }

        # Check for pam_tally2 (older alternative)
        if ($pamAuthStr -match "pam_tally2\.so") {
            $output += "  [INFO] pam_tally2.so found (deprecated, consider migrating to pam_faillock)${nl}"
            if ($pamAuthStr -match "pam_tally2\.so.*deny=(\d+)") {
                $denyCount = [int]$matches[1]
                $output += "  deny=$denyCount${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: faillock.conf configuration file
    $output += "Check 2: faillock.conf Configuration${nl}"
    try {
        $faillockConf = $(timeout 5 cat /etc/security/faillock.conf 2>&1)
        $faillockStr = ($faillockConf -join $nl).Trim()
        if ($faillockStr -and $faillockStr -notmatch "No such file") {
            if ($faillockStr -match "(?m)^deny\s*=\s*(\d+)") {
                $denyVal = [int]$matches[1]
                $output += "  deny = $denyVal${nl}"
                if ($denyVal -le 3) {
                    $output += "  [PASS] Meets DoD 3-attempt requirement${nl}"
                }
                else {
                    $output += "  [FAIL] Exceeds DoD 3-attempt limit${nl}"
                }
            }
            if ($faillockStr -match "(?m)^fail_interval\s*=\s*(\d+)") {
                $interval = [int]$matches[1]
                $output += "  fail_interval = $interval seconds${nl}"
                if ($interval -ge 900) {
                    $output += "  [PASS] Meets 15-minute window${nl}"
                }
            }
            if ($faillockStr -match "(?m)^unlock_time\s*=\s*(\d+)") {
                $unlockTime = [int]$matches[1]
                $output += "  unlock_time = $unlockTime seconds${nl}"
            }
        }
        else {
            $output += "  [INFO] /etc/security/faillock.conf not found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH-specific lockout (MaxAuthTries)
    $output += "Check 3: SSH MaxAuthTries${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl).Trim()
        if ($sshdStr -match "(?i)maxauthtries\s+(\d+)") {
            $maxAuth = [int]$matches[1]
            $output += "  MaxAuthTries = $maxAuth${nl}"
            if ($maxAuth -le 3) {
                $output += "  [PASS] SSH limits to $maxAuth attempts${nl}"
            }
            else {
                $output += "  [FAIL] SSH allows $maxAuth attempts (DoD requires 3 or fewer)${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status - need both PAM faillock AND deny <= 3
    if ($pamAuthStr -match "pam_faillock\.so.*deny=(\d+)") {
        if ([int]$matches[1] -le 3) {
            $Status = "NotAFinding"
        }
    }
    elseif ($faillockStr -match "(?m)^deny\s*=\s*(\d+)") {
        if ([int]$matches[1] -le 3) {
            $Status = "NotAFinding"
        }
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203595 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203595
        STIG ID    : SRG-OS-000023-GPOS-00006
        Rule ID    : SV-203595r958390_rule
        Rule Title : Display Standard Mandatory DoD Notice and Consent Banner
        DiscussMD5 : fd76cffcf9d0a307406ac36b66acde49
        CheckMD5   : bf4bf983073351c9bdfa2e7c31e01b10
        FixMD5     : 1aa0ee25df9b6798d4d7b3e697a2f570
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203595"
    $RuleID = "SV-203595r958390_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: /etc/issue file (local login banner)
    $output += "Check 1: Local Login Banner (/etc/issue)${nl}"
    try {
        $issueContent = $(timeout 5 cat /etc/issue 2>&1)
        $issueStr = ($issueContent -join $nl).Trim()
        if ($issueStr) {
            $output += "  /etc/issue content:${nl}"
            foreach ($line in ($issueStr -split $nl | Select-Object -First 10)) {
                $output += "    $line${nl}"
            }
            if ($issueStr -match "USG|U\.S\. Government|consent to monitoring|authorized use") {
                $output += "  [PASS] DoD banner keywords detected in /etc/issue${nl}"
            }
            else {
                $output += "  [FAIL] DoD banner keywords not found in /etc/issue${nl}"
            }
        }
        else {
            $output += "  [FAIL] /etc/issue is empty or missing${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: /etc/issue.net (remote login banner)
    $output += "Check 2: Remote Login Banner (/etc/issue.net)${nl}"
    try {
        $issueNetContent = $(timeout 5 cat /etc/issue.net 2>&1)
        $issueNetStr = ($issueNetContent -join $nl).Trim()
        if ($issueNetStr) {
            $output += "  /etc/issue.net content:${nl}"
            foreach ($line in ($issueNetStr -split $nl | Select-Object -First 10)) {
                $output += "    $line${nl}"
            }
            if ($issueNetStr -match "USG|U\.S\. Government|consent to monitoring|authorized use") {
                $output += "  [PASS] DoD banner keywords detected in /etc/issue.net${nl}"
            }
            else {
                $output += "  [FAIL] DoD banner keywords not found in /etc/issue.net${nl}"
            }
        }
        else {
            $output += "  [FAIL] /etc/issue.net is empty or missing${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH Banner configuration
    $output += "Check 3: SSH Banner Configuration${nl}"
    try {
        $sshBanner = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i '^banner'" 2>&1)
        $sshBannerStr = ($sshBanner -join $nl).Trim()
        if ($sshBannerStr -match "banner\s+(/\S+)") {
            $bannerPath = $matches[1]
            $output += "  [PASS] SSH banner configured: $bannerPath${nl}"
        }
        elseif ($sshBannerStr -match "banner\s+none") {
            $output += "  [FAIL] SSH banner set to none${nl}"
        }
        else {
            $output += "  [INFO] SSH banner setting: $sshBannerStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    $issuePass = $issueStr -match "USG|U\.S\. Government|consent to monitoring|authorized use"
    $issueNetPass = $issueNetStr -match "USG|U\.S\. Government|consent to monitoring|authorized use"
    if ($issuePass -and $issueNetPass) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203596 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203596
        STIG ID    : SRG-OS-000024-GPOS-00007
        Rule ID    : SV-203596r958392_rule
        Rule Title : Display banner until user acknowledges and logs on
        DiscussMD5 : 8873385dbcabf71cad7c9dd1daf30d0b
        CheckMD5   : 7656c0828d00d985639a5b94ba27cbed
        FixMD5     : 41394d03257dc2d7bdace0b04b95342d
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203596"
    $RuleID = "SV-203596r958392_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: SSH PrintMotd and Banner settings
    $output += "Check 1: SSH Banner Display Configuration${nl}"
    try {
        $sshConfig = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -iE '^(banner|printmotd|printlastlog)'" 2>&1)
        $sshStr = ($sshConfig -join $nl).Trim()
        if ($sshStr) {
            foreach ($line in ($sshStr -split $nl)) {
                $output += "  $line${nl}"
            }
            if ($sshStr -match "banner\s+(/\S+)") {
                $output += "  [PASS] SSH banner file configured${nl}"
            }
            else {
                $output += "  [FAIL] SSH banner not configured to display a file${nl}"
            }
        }
        else {
            $output += "  [FAIL] Unable to retrieve SSH configuration${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: /etc/issue contains DoD banner (displayed before login)
    $output += "Check 2: Pre-Login Banner Content (/etc/issue)${nl}"
    try {
        $issueContent = $(timeout 5 cat /etc/issue 2>&1)
        $issueStr = ($issueContent -join $nl).Trim()
        if ($issueStr -match "USG|U\.S\. Government|consent to monitoring|authorized use") {
            $output += "  [PASS] DoD banner present in /etc/issue (displayed before login prompt)${nl}"
        }
        elseif ($issueStr) {
            $output += "  [FAIL] /etc/issue has content but missing DoD banner keywords${nl}"
        }
        else {
            $output += "  [FAIL] /etc/issue is empty${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: GDM/GNOME banner (if GUI installed)
    $output += "Check 3: Graphical Login Banner${nl}"
    try {
        $gdmInstalled = $(timeout 5 dpkg -l gdm3 2>&1)
        $gdmStr = ($gdmInstalled -join $nl).Trim()
        if ($gdmStr -match "^ii\s+gdm3") {
            $bannerEnabled = $(timeout 5 sh -c "gsettings get org.gnome.login-screen banner-message-enable 2>/dev/null" 2>&1)
            $bannerText = $(timeout 5 sh -c "gsettings get org.gnome.login-screen banner-message-text 2>/dev/null" 2>&1)
            $output += "  GDM3 installed${nl}"
            $output += "  Banner enabled: $(($bannerEnabled -join $nl).Trim())${nl}"
            $output += "  Banner text: $(($bannerText -join $nl).Trim())${nl}"
        }
        else {
            $output += "  [INFO] GDM3 not installed (no graphical login - CLI only)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    $bannerConfigured = $sshStr -match "banner\s+(/\S+)"
    $bannerContent = $issueStr -match "USG|U\.S\. Government|consent to monitoring|authorized use"
    if ($bannerConfigured -and $bannerContent) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203597 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203597
        STIG ID    : SRG-OS-000027-GPOS-00008
        Rule ID    : SV-203597r958398_rule
        Rule Title : Limit concurrent sessions to ten
        DiscussMD5 : 188ce726c57de3a01af910a4e7c88eee
        CheckMD5   : 7601a94d20fa138b5d09d8635fe1ce1b
        FixMD5     : 7df266a99130f5f56a74bdc43580381b
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203597"
    $RuleID = "SV-203597r958398_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: PAM limits.conf for maxlogins
    $output += "Check 1: PAM Session Limits (/etc/security/limits.conf)${nl}"
    try {
        $limitsContent = $(timeout 5 sh -c "grep -v '^#' /etc/security/limits.conf 2>/dev/null | grep -i maxlogins" 2>&1)
        $limitsStr = ($limitsContent -join $nl).Trim()
        if ($limitsStr -and $limitsStr -notmatch "No such file") {
            $output += "  maxlogins entries found:${nl}"
            foreach ($line in ($limitsStr -split $nl)) {
                $output += "    $line${nl}"
            }
            if ($limitsStr -match "(\d+)") {
                $maxVal = [int]$matches[1]
                if ($maxVal -le 10) {
                    $output += "  [PASS] maxlogins set to $maxVal (limit is 10)${nl}"
                }
                else {
                    $output += "  [FAIL] maxlogins set to $maxVal (exceeds limit of 10)${nl}"
                }
            }
        }
        else {
            $output += "  [FAIL] No maxlogins entry in /etc/security/limits.conf${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: limits.d directory
    $output += "Check 2: PAM Limits Drop-in (/etc/security/limits.d/)${nl}"
    try {
        $limitsD = $(timeout 5 sh -c "grep -r maxlogins /etc/security/limits.d/ 2>/dev/null" 2>&1)
        $limitsDStr = ($limitsD -join $nl).Trim()
        if ($limitsDStr -and $limitsDStr -notmatch "No such file") {
            $output += "  maxlogins entries in limits.d:${nl}"
            foreach ($line in ($limitsDStr -split $nl | Select-Object -First 5)) {
                $output += "    $line${nl}"
            }
        }
        else {
            $output += "  [INFO] No maxlogins entries in /etc/security/limits.d/${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH MaxSessions
    $output += "Check 3: SSH MaxSessions${nl}"
    try {
        $sshMax = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i maxsessions" 2>&1)
        $sshMaxStr = ($sshMax -join $nl).Trim()
        if ($sshMaxStr -match "maxsessions\s+(\d+)") {
            $sshMaxVal = [int]$matches[1]
            $output += "  SSH MaxSessions: $sshMaxVal${nl}"
            if ($sshMaxVal -le 10) {
                $output += "  [PASS] SSH MaxSessions within limit${nl}"
            }
            else {
                $output += "  [FAIL] SSH MaxSessions exceeds 10${nl}"
            }
        }
        else {
            $output += "  [INFO] SSH MaxSessions: $sshMaxStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status - need either limits.conf or SSH maxsessions set
    $limitsPass = $limitsStr -match "maxlogins" -and $limitsStr -match "(\d+)" -and [int]$matches[1] -le 10
    $sshPass = $sshMaxStr -match "maxsessions\s+(\d+)" -and [int]$matches[1] -le 10
    if ($limitsPass -or $sshPass) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203598 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203598
        STIG ID    : SRG-OS-000028-GPOS-00009
        Rule ID    : SV-203598r958400_rule
        Rule Title : Retain session lock until re-authentication
        DiscussMD5 : 0b5c88bcfa9e8f895e558377983b3c25
        CheckMD5   : a04363881ef8ebb670aa5183e18ef76f
        FixMD5     : 10f0425af0ac1d2754d295482121640c
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203598"
    $RuleID = "SV-203598r958400_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: tmux/screen session lock capability
    $output += "Check 1: Terminal Multiplexer Session Lock${nl}"
    $tmuxInstalled = $false
    $screenInstalled = $false
    try {
        $tmuxCheck = $(timeout 5 which tmux 2>&1)
        $tmuxStr = ($tmuxCheck -join $nl).Trim()
        if ($tmuxStr -match "/tmux") {
            $tmuxInstalled = $true
            $output += "  [PASS] tmux installed: $tmuxStr${nl}"
        }
        else {
            $output += "  [INFO] tmux not installed${nl}"
        }
        $screenCheck = $(timeout 5 which screen 2>&1)
        $screenStr = ($screenCheck -join $nl).Trim()
        if ($screenStr -match "/screen") {
            $screenInstalled = $true
            $output += "  [PASS] screen installed: $screenStr${nl}"
        }
        else {
            $output += "  [INFO] screen not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: vlock/physlock for console lock
    $output += "Check 2: Console Lock Utility${nl}"
    $vlockInstalled = $false
    try {
        $vlockCheck = $(timeout 5 sh -c "which vlock 2>/dev/null || which physlock 2>/dev/null" 2>&1)
        $vlockStr = ($vlockCheck -join $nl).Trim()
        if ($vlockStr -match "vlock|physlock") {
            $vlockInstalled = $true
            $output += "  [PASS] Console lock utility available: $vlockStr${nl}"
        }
        else {
            $output += "  [INFO] No console lock utility (vlock/physlock) installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH re-authentication requirement
    $output += "Check 3: SSH Session Re-authentication${nl}"
    try {
        $sshConfig = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -iE '^(clientaliveinterval|clientalivecountmax)'" 2>&1)
        $sshStr = ($sshConfig -join $nl).Trim()
        if ($sshStr) {
            foreach ($line in ($sshStr -split $nl)) {
                $output += "  $line${nl}"
            }
            $output += "  [INFO] SSH drops idle sessions requiring re-authentication to resume${nl}"
        }
        else {
            $output += "  [FAIL] SSH idle session settings not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if (($tmuxInstalled -or $screenInstalled -or $vlockInstalled) -and $sshStr -match "clientaliveinterval") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203599 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203599
        STIG ID    : SRG-OS-000029-GPOS-00010
        Rule ID    : SV-203599r958402_rule
        Rule Title : Initiate session lock after 15-minute inactivity
        DiscussMD5 : ef1b3e466dbaad856a1d89c0bcbdf400
        CheckMD5   : 9f6337d878a1e79cf9e6f9b1b35d4f45
        FixMD5     : 281c187def43332c9de61be584a8c81d
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203599"
    $RuleID = "SV-203599r958402_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: SSH ClientAliveInterval (15 min = 900 sec max)
    $output += "Check 1: SSH Inactivity Timeout${nl}"
    $sshTimeoutPass = $false
    try {
        $sshConfig = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -iE '^(clientaliveinterval|clientalivecountmax)'" 2>&1)
        $sshStr = ($sshConfig -join $nl).Trim()
        if ($sshStr) {
            foreach ($line in ($sshStr -split $nl)) {
                $output += "  $line${nl}"
            }
            if ($sshStr -match "clientaliveinterval\s+(\d+)") {
                $interval = [int]$matches[1]
                if ($interval -gt 0 -and $interval -le 900) {
                    $output += "  [PASS] ClientAliveInterval=$interval seconds (max 900)${nl}"
                    $sshTimeoutPass = $true
                }
                elseif ($interval -eq 0) {
                    $output += "  [FAIL] ClientAliveInterval=0 (disabled)${nl}"
                }
                else {
                    $output += "  [FAIL] ClientAliveInterval=$interval exceeds 900 seconds (15 min)${nl}"
                }
            }
        }
        else {
            $output += "  [FAIL] SSH ClientAliveInterval not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: TMOUT environment variable
    $output += "Check 2: Shell Inactivity Timeout (TMOUT)${nl}"
    $tmoutPass = $false
    try {
        $tmoutFiles = $(timeout 5 sh -c "grep -r 'TMOUT' /etc/profile /etc/profile.d/ /etc/bash.bashrc 2>/dev/null" 2>&1)
        $tmoutStr = ($tmoutFiles -join $nl).Trim()
        if ($tmoutStr -and $tmoutStr -notmatch "No such file") {
            foreach ($line in ($tmoutStr -split $nl | Select-Object -First 5)) {
                $output += "  $line${nl}"
            }
            if ($tmoutStr -match "TMOUT=(\d+)") {
                $tmoutVal = [int]$matches[1]
                if ($tmoutVal -le 900 -and $tmoutVal -gt 0) {
                    $output += "  [PASS] TMOUT=$tmoutVal seconds (max 900)${nl}"
                    $tmoutPass = $true
                }
                else {
                    $output += "  [FAIL] TMOUT=$tmoutVal (must be 1-900)${nl}"
                }
            }
        }
        else {
            $output += "  [FAIL] TMOUT not configured in /etc/profile or /etc/bash.bashrc${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: tmux lock-after-time (if tmux is used)
    $output += "Check 3: tmux Lock Timeout${nl}"
    try {
        $tmuxConf = $(timeout 5 sh -c "cat /etc/tmux.conf 2>/dev/null; cat ~/.tmux.conf 2>/dev/null" 2>&1)
        $tmuxStr = ($tmuxConf -join $nl).Trim()
        if ($tmuxStr -match "lock-after-time\s+(\d+)") {
            $lockTime = [int]$matches[1]
            $output += "  tmux lock-after-time: $lockTime seconds${nl}"
            if ($lockTime -le 900 -and $lockTime -gt 0) {
                $output += "  [PASS] tmux auto-lock within 15 minutes${nl}"
            }
        }
        else {
            $output += "  [INFO] tmux lock-after-time not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($sshTimeoutPass -or $tmoutPass) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203600 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203600
        STIG ID    : SRG-OS-000030-GPOS-00011
        Rule ID    : SV-203600r982194_rule
        Rule Title : User-initiated session lock capability
        DiscussMD5 : 271d46ee6486cb76318252bcb2e914e8
        CheckMD5   : 8aaeb3f0040a0af06a11904e579c2a71
        FixMD5     : 17dba7326d5667e40a8f7e771db75942
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203600"
    $RuleID = "SV-203600r982194_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $lockAvailable = $false

    # Check 1: vlock or physlock for user-initiated console lock
    $output += "Check 1: Console Lock Utilities${nl}"
    try {
        $vlock = $(timeout 5 sh -c "which vlock 2>/dev/null || which physlock 2>/dev/null" 2>&1)
        $vlockStr = ($vlock -join $nl).Trim()
        if ($vlockStr -match "vlock|physlock") {
            $output += "  [PASS] Console lock utility available: $vlockStr${nl}"
            $lockAvailable = $true
        }
        else {
            $output += "  [INFO] No console lock utility (vlock/physlock) installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: tmux lock-session capability
    $output += "Check 2: tmux Session Lock${nl}"
    try {
        $tmuxPath = $(timeout 5 which tmux 2>&1)
        $tmuxStr = ($tmuxPath -join $nl).Trim()
        if ($tmuxStr -match "/tmux") {
            $output += "  [PASS] tmux installed: $tmuxStr${nl}"
            $output += "  [INFO] Users can lock with: tmux lock-session (Ctrl-b + L)${nl}"
            $lockAvailable = $true
        }
        else {
            $output += "  [INFO] tmux not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: screen lock capability
    $output += "Check 3: GNU Screen Lock${nl}"
    try {
        $screenPath = $(timeout 5 which screen 2>&1)
        $screenStr = ($screenPath -join $nl).Trim()
        if ($screenStr -match "/screen") {
            $output += "  [PASS] screen installed: $screenStr${nl}"
            $output += "  [INFO] Users can lock with: Ctrl-a + x${nl}"
            $lockAvailable = $true
        }
        else {
            $output += "  [INFO] GNU screen not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($lockAvailable) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203601 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203601
        STIG ID    : SRG-OS-000031-GPOS-00012
        Rule ID    : SV-203601r958404_rule
        Rule Title : Conceal display with publicly viewable image on session lock
        DiscussMD5 : dbae32b459af2626348f77c8e2d1cedc
        CheckMD5   : 25ea53aa2c66da001ea97c240df53041
        FixMD5     : cf92e96478f65282684582893f3da955
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203601"
    $RuleID = "SV-203601r958404_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Graphical desktop environment
    $output += "Check 1: Graphical Desktop Environment${nl}"
    $hasGui = $false
    try {
        $gdm = $(timeout 5 dpkg -l gdm3 2>&1)
        $gdmStr = ($gdm -join $nl).Trim()
        if ($gdmStr -match "^ii\s+gdm3") {
            $hasGui = $true
            $output += "  [INFO] GDM3 installed - graphical lock screen applies${nl}"
            $lockEnabled = $(timeout 5 sh -c "gsettings get org.gnome.desktop.screensaver lock-enabled 2>/dev/null" 2>&1)
            $lockStr = ($lockEnabled -join $nl).Trim()
            $output += "  Screensaver lock enabled: $lockStr${nl}"
        }
        else {
            $output += "  [INFO] No graphical desktop installed (CLI-only server)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: CLI session lock concealment
    $output += "Check 2: CLI Session Lock Behavior${nl}"
    $cliLockConceals = $false
    try {
        $tmuxPath = $(timeout 5 which tmux 2>&1)
        $tmuxStr = ($tmuxPath -join $nl).Trim()
        if ($tmuxStr -match "/tmux") {
            $output += "  [PASS] tmux installed - lock-session clears display and requires password${nl}"
            $cliLockConceals = $true
        }
        $vlockPath = $(timeout 5 sh -c "which vlock 2>/dev/null || which physlock 2>/dev/null" 2>&1)
        $vlockStr = ($vlockPath -join $nl).Trim()
        if ($vlockStr -match "vlock|physlock") {
            $output += "  [PASS] Console lock utility clears terminal display: $vlockStr${nl}"
            $cliLockConceals = $true
        }
        if (-not $cliLockConceals) {
            $output += "  [FAIL] No session lock utility that conceals display content${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH disconnects clear remote display
    $output += "Check 3: SSH Session Termination${nl}"
    try {
        $sshConfig = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i clientaliveinterval" 2>&1)
        $sshStr = ($sshConfig -join $nl).Trim()
        if ($sshStr -match "clientaliveinterval\s+(\d+)") {
            $interval = [int]$matches[1]
            if ($interval -gt 0) {
                $output += "  [PASS] SSH timeout configured ($interval sec) - disconnected sessions clear display${nl}"
            }
            else {
                $output += "  [INFO] SSH ClientAliveInterval=0 (no automatic disconnect)${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($cliLockConceals -or ($hasGui -and $lockStr -eq "true")) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203602 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203602
        STIG ID    : SRG-OS-000032-GPOS-00013
        Rule ID    : SV-203602r958406_rule
        Rule Title : The operating system must monitor remote access methods.
        DiscussMD5 : 8faea1683909f98a0380b33c0cc5abab
        CheckMD5   : aec82969f3da4c03b94f331148438b3f
        FixMD5     : 6834b32a2607b3bb9df4ea81ba96c100
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203602"
    $RuleID = "SV-203602r958406_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $sshMonitored = $false

    # Check 1: SSH LogLevel configuration
    $output += "Check 1: SSH LogLevel Configuration${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl)
        if ($sshdStr -match "loglevel\s+(INFO|VERBOSE)") {
            $output += "  [PASS] SSH LogLevel: $($Matches[1])${nl}"
            $sshMonitored = $true
        }
        elseif ($sshdStr -match "loglevel\s+(\S+)") {
            $output += "  [FAIL] SSH LogLevel: $($Matches[1]) (should be INFO or VERBOSE)${nl}"
        }
        else {
            $output += "  [INFO] Unable to determine SSH LogLevel${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: rsyslog auth facility logging
    $output += "Check 2: Syslog Auth Facility Logging${nl}"
    try {
        $rsyslogConf = $(timeout 5 cat /etc/rsyslog.conf 2>&1)
        $rsyslogStr = ($rsyslogConf -join $nl)
        $rsyslogD = $(timeout 5 cat /etc/rsyslog.d/*.conf 2>&1)
        $rsyslogDStr = ($rsyslogD -join $nl)
        $combined = $rsyslogStr + $nl + $rsyslogDStr
        if ($combined -match "auth\.\*|auth,authpriv\.\*|authpriv\.\*") {
            $output += "  [PASS] Auth facility logging configured in rsyslog${nl}"
            $sshMonitored = $true
        }
        else {
            $output += "  [INFO] Auth facility not explicitly configured in rsyslog${nl}"
        }
    }
    catch {
        $output += "  [INFO] rsyslog configuration not accessible${nl}"
    }
    $output += $nl

    # Check 3: Auth log file exists and has recent entries
    $output += "Check 3: Auth Log File Status${nl}"
    try {
        $authLog = $(timeout 5 ls -la /var/log/auth.log 2>&1)
        $authLogStr = ($authLog -join $nl).Trim()
        if ($authLogStr -and $authLogStr -notmatch "No such file") {
            $output += "  [PASS] /var/log/auth.log exists: $authLogStr${nl}"
            $recentEntries = $(timeout 5 tail -5 /var/log/auth.log 2>&1)
            $recentStr = ($recentEntries -join $nl).Trim()
            if ($recentStr -match "sshd") {
                $output += "  [PASS] Recent SSH events found in auth.log${nl}"
                $sshMonitored = $true
            }
            else {
                $output += "  [INFO] No recent SSH events in auth.log${nl}"
            }
        }
        else {
            $output += "  [FAIL] /var/log/auth.log not found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: journald logging of SSH sessions
    $output += "Check 4: Systemd Journal SSH Monitoring${nl}"
    try {
        $journalSSH = $(timeout 10 journalctl -u ssh --no-pager -n 5 2>&1)
        $journalStr = ($journalSSH -join $nl).Trim()
        if ($journalStr -and $journalStr -notmatch "No entries|No journal files") {
            $output += "  [PASS] SSH events found in systemd journal${nl}"
            $sshMonitored = $true
        }
        else {
            $output += "  [INFO] No SSH events in systemd journal${nl}"
        }
    }
    catch {
        $output += "  [INFO] journalctl not available${nl}"
    }

    # Determine status
    if ($sshMonitored) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203603 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203603
        STIG ID    : SRG-OS-000033-GPOS-00014
        Rule ID    : SV-203603r958408_rule
        Rule Title : The operating system must implement DoD-approved encryption to protect the confidentiality of remote access sessions.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203603"
    $RuleID = "SV-203603r958408_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203603 - DoD-Approved Encryption for Remote Access Sessions" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Get effective SSH configuration
    $FindingDetails += "Check 1: SSH Cipher Configuration" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    $weakCiphers = @("3des-cbc", "blowfish-cbc", "cast128-cbc", "arcfour", "arcfour128", "arcfour256")
    $weakFound = $false

    if ($sshdStr -match "(?m)^ciphers\s+(.+)$") {
        $cipherLine = $matches[1].Trim()
        $cipherList = $cipherLine -split ","
        $FindingDetails += "Configured ciphers: " + $cipherLine + $nl + $nl

        foreach ($c in $cipherList) {
            $c = $c.Trim()
            if ($c -in $weakCiphers) {
                $FindingDetails += "  FAIL: Weak cipher: " + $c + $nl
                $weakFound = $true
            }
        }
        if (-not $weakFound) {
            $FindingDetails += "  PASS: No weak ciphers detected" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH cipher configuration" + $nl
        $weakFound = $true
    }

    $FindingDetails += $nl

    # Check 2: Verify MACs are FIPS-approved
    $FindingDetails += "Check 2: SSH MAC Configuration" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $weakMACs = @("hmac-md5", "hmac-md5-96", "hmac-ripemd160", "hmac-sha1-96", "umac-64@openssh.com")
    $weakMacFound = $false

    if ($sshdStr -match "(?m)^macs\s+(.+)$") {
        $macLine = $matches[1].Trim()
        $macList = $macLine -split ","
        $FindingDetails += "Configured MACs: " + $macLine + $nl + $nl

        foreach ($m in $macList) {
            $m = $m.Trim()
            if ($m -in $weakMACs) {
                $FindingDetails += "  FAIL: Weak MAC: " + $m + $nl
                $weakMacFound = $true
            }
        }
        if (-not $weakMacFound) {
            $FindingDetails += "  PASS: No weak MACs detected" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH MAC configuration" + $nl
        $weakMacFound = $true
    }

    $FindingDetails += $nl

    # Check 3: Verify KexAlgorithms
    $FindingDetails += "Check 3: SSH Key Exchange Algorithms" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $weakKex = @("diffie-hellman-group1-sha1", "diffie-hellman-group-exchange-sha1", "diffie-hellman-group14-sha1")
    $weakKexFound = $false

    if ($sshdStr -match "(?m)^kexalgorithms\s+(.+)$") {
        $kexLine = $matches[1].Trim()
        $kexList = $kexLine -split ","
        $FindingDetails += "Configured KexAlgorithms: " + $kexLine + $nl + $nl

        foreach ($k in $kexList) {
            $k = $k.Trim()
            if ($k -in $weakKex) {
                $FindingDetails += "  FAIL: Weak KexAlgorithm: " + $k + $nl
                $weakKexFound = $true
            }
        }
        if (-not $weakKexFound) {
            $FindingDetails += "  PASS: No weak key exchange algorithms detected" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH KexAlgorithm configuration" + $nl
        $weakKexFound = $true
    }

    $FindingDetails += $nl

    # Check 4: SSH Protocol version
    $FindingDetails += "Check 4: SSH Protocol Version" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshVersion = $(ssh -V 2>&1)
    $sshVersionStr = ($sshVersion -join $nl)
    $FindingDetails += "SSH Version: " + $sshVersionStr + $nl

    $FindingDetails += $nl

    # Status determination
    if ($weakFound -or $weakMacFound -or $weakKexFound) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Non-approved cryptographic algorithms detected in SSH configuration" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - SSH configured with DoD-approved encryption algorithms" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203604 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203604
        STIG ID    : SRG-OS-000037-GPOS-00015
        Rule ID    : SV-203604r958412_rule
        Rule Title : The operating system must produce audit records containing information to establish what type of events occurred.
        DiscussMD5 : 13f64ab70ea1433777ab1e4cfe0a3cfe
        CheckMD5   : df688110f3197623767f566d8e1fbcaa
        FixMD5     : ca71fb49823788e28cfe2ee33802f96a
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203604"
    $RuleID = "SV-203604r958412_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Audit records contain event type information" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd service status
    $FindingDetails += "--- Check 1: auditd Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $auditdEnabled = $(timeout 5 systemctl is-enabled auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    $FindingDetails += "  Service enabled: $auditdEnabled" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: Audit rules contain syscall type information
    $FindingDetails += "--- Check 2: Audit Rules with Event Types ---" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $ruleLines = ($auditRules -split $nl)
        $syscallRules = ($ruleLines | Where-Object { $_ -match "-S " -or $_ -match "-a " })
        $ruleCount = ($syscallRules | Measure-Object).Count
        $FindingDetails += "  Total audit rules: $(($ruleLines | Measure-Object).Count)" + $nl
        $FindingDetails += "  Syscall/action rules: $ruleCount" + $nl
        if ($ruleCount -gt 0) {
            $FindingDetails += "  [PASS] Audit rules define event types via syscall monitoring" + $nl
            $sampleRules = ($syscallRules | Select-Object -First 5)
            foreach ($r in $sampleRules) {
                $FindingDetails += "    $r" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No syscall audit rules found" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] No audit rules loaded" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Audit log contains type= field
    $FindingDetails += "--- Check 3: Audit Log Event Type Fields ---" + $nl
    $logSample = $(timeout 5 tail -20 /var/log/audit/audit.log 2>&1)
    if ($logSample -and ($logSample -notmatch "No such file")) {
        $typeEntries = (($logSample -split $nl) | Where-Object { $_ -match "type=" })
        $typeCount = ($typeEntries | Measure-Object).Count
        $FindingDetails += "  Log entries with type= field: $typeCount / 20 sampled" + $nl
        if ($typeCount -gt 0) {
            $FindingDetails += "  [PASS] Audit logs contain event type information" + $nl
            $sample = ($typeEntries | Select-Object -First 3)
            foreach ($s in $sample) {
                $trimmed = if ($s.Length -gt 120) { $s.Substring(0,120) + "..." } else { $s }
                $FindingDetails += "    $trimmed" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No type= fields found in audit log" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] /var/log/audit/audit.log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer event type recording via action and subject fields in audit records" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203605 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203605
        STIG ID    : SRG-OS-000038-GPOS-00016
        Rule ID    : SV-203605r958414_rule
        Rule Title : The operating system must produce audit records containing information to establish when (date and time) the events occurred.
        DiscussMD5 : 35f95179311c29f7edd610208480de35
        CheckMD5   : 68a45007f52b4122a6318592ecb84235
        FixMD5     : 01b1adcb5f6e8ccb2928db3df8081f57
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203605"
    $RuleID = "SV-203605r958414_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Audit records contain date and time information" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd service running
    $FindingDetails += "--- Check 1: auditd Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: Audit log format includes timestamps
    $FindingDetails += "--- Check 2: Audit Log Timestamp Format ---" + $nl
    $logConf = $(timeout 5 grep -i "^log_format" /etc/audit/auditd.conf 2>&1)
    $FindingDetails += "  auditd.conf log_format: $(if ($logConf) { $logConf } else { 'RAW (default)' })" + $nl
    $logSample = $(timeout 5 tail -10 /var/log/audit/audit.log 2>&1)
    if ($logSample -and ($logSample -notmatch "No such file")) {
        $timestampEntries = (($logSample -split $nl) | Where-Object { $_ -match "msg=audit\(\d+\.\d+:" })
        $tsCount = ($timestampEntries | Measure-Object).Count
        $FindingDetails += "  Log entries with epoch timestamps: $tsCount / 10 sampled" + $nl
        if ($tsCount -gt 0) {
            $FindingDetails += "  [PASS] Audit logs contain date/time (epoch format)" + $nl
            $sample = ($timestampEntries | Select-Object -First 2)
            foreach ($s in $sample) {
                $trimmed = if ($s.Length -gt 120) { $s.Substring(0,120) + "..." } else { $s }
                $FindingDetails += "    $trimmed" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No timestamps found in audit log" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] /var/log/audit/audit.log not accessible" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: System time source for audit
    $FindingDetails += "--- Check 3: System Clock Configuration ---" + $nl
    $timeSync = $(timeout 5 timedatectl show --property=NTPSynchronized --value 2>&1)
    $FindingDetails += "  NTP synchronized: $timeSync" + $nl
    if ($timeSync -eq "yes") {
        $FindingDetails += "  [PASS] System clock is NTP synchronized" + $nl
    }
    else {
        $FindingDetails += "  [INFO] NTP not synchronized - timestamps may drift" + $nl
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer precise timestamps (Unix millisecond) in all audit records" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203606 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203606
        STIG ID    : SRG-OS-000039-GPOS-00017
        Rule ID    : SV-203606r958416_rule
        Rule Title : The operating system must produce audit records containing information to establish where the events occurred.
        DiscussMD5 : d893d7ce962a24600ce8f85b9bf34088
        CheckMD5   : e017171084eff31d7ff7769c6160a8cd
        FixMD5     : 0ea4eff7dbe379acb202fb8780127fc0
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203606"
    $RuleID = "SV-203606r958416_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Audit records contain location (where) information" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd running
    $FindingDetails += "--- Check 1: auditd Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: Audit rules monitor filesystem paths (location tracking)
    $FindingDetails += "--- Check 2: Filesystem Watch Rules (Location Tracking) ---" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $watchRules = (($auditRules -split $nl) | Where-Object { $_ -match "^-w " })
        $watchCount = ($watchRules | Measure-Object).Count
        $FindingDetails += "  Filesystem watch rules: $watchCount" + $nl
        if ($watchCount -gt 0) {
            $FindingDetails += "  [PASS] Audit rules track file/directory locations" + $nl
            $sampleRules = ($watchRules | Select-Object -First 5)
            foreach ($r in $sampleRules) {
                $FindingDetails += "    $r" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No filesystem watch rules found" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] No audit rules loaded" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Audit log contains path/cwd fields
    $FindingDetails += "--- Check 3: Audit Log Location Fields ---" + $nl
    $logSample = $(timeout 5 tail -50 /var/log/audit/audit.log 2>&1)
    if ($logSample -and ($logSample -notmatch "No such file")) {
        $pathEntries = (($logSample -split $nl) | Where-Object { $_ -match "type=PATH" -or $_ -match "type=CWD" })
        $pathCount = ($pathEntries | Measure-Object).Count
        $FindingDetails += "  PATH/CWD entries in last 50 lines: $pathCount" + $nl
        if ($pathCount -gt 0) {
            $FindingDetails += "  [PASS] Audit logs record filesystem location" + $nl
        }
        else {
            $FindingDetails += "  [INFO] No PATH/CWD entries in recent log sample" + $nl
        }
    }
    else {
        $FindingDetails += "  [FAIL] /var/log/audit/audit.log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer object identification in audit records linking actions to specific resources" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203607 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203607
        STIG ID    : SRG-OS-000040-GPOS-00018
        Rule ID    : SV-203607r958418_rule
        Rule Title : The operating system must produce audit records containing information to establish the source of the events.
        DiscussMD5 : 13cef1027fc0533fadaa350c2336e05f
        CheckMD5   : 8f5dca545864199baba1a824ad6d2b2a
        FixMD5     : 2cbbfc9d874dbcb760b22c0eebf18059
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203607"
    $RuleID = "SV-203607r958418_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Audit records contain source (process) information" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd running
    $FindingDetails += "--- Check 1: auditd Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: Audit rules capture process/syscall source info
    $FindingDetails += "--- Check 2: Syscall Audit Rules (Source Tracking) ---" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $syscallRules = (($auditRules -split $nl) | Where-Object { $_ -match "-S " })
        $sCount = ($syscallRules | Measure-Object).Count
        $FindingDetails += "  Syscall audit rules: $sCount" + $nl
        if ($sCount -gt 0) {
            $FindingDetails += "  [PASS] Audit rules capture source process via syscall monitoring" + $nl
            $sampleRules = ($syscallRules | Select-Object -First 5)
            foreach ($r in $sampleRules) {
                $FindingDetails += "    $r" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No syscall audit rules found" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] No audit rules loaded" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Audit log contains SYSCALL records with pid/ppid/exe
    $FindingDetails += "--- Check 3: Audit Log Source Fields (pid, exe) ---" + $nl
    $logSample = $(timeout 5 tail -50 /var/log/audit/audit.log 2>&1)
    if ($logSample -and ($logSample -notmatch "No such file")) {
        $syscallEntries = (($logSample -split $nl) | Where-Object { $_ -match "type=SYSCALL" })
        $scCount = ($syscallEntries | Measure-Object).Count
        $FindingDetails += "  SYSCALL entries in last 50 lines: $scCount" + $nl
        if ($scCount -gt 0) {
            $FindingDetails += "  [PASS] Audit logs record process source (pid, ppid, exe)" + $nl
            $sample = ($syscallEntries | Select-Object -First 2)
            foreach ($s in $sample) {
                $trimmed = if ($s.Length -gt 120) { $s.Substring(0,120) + "..." } else { $s }
                $FindingDetails += "    $trimmed" + $nl
            }
        }
        else {
            $FindingDetails += "  [INFO] No SYSCALL entries in recent log sample" + $nl
        }
    }
    else {
        $FindingDetails += "  [FAIL] /var/log/audit/audit.log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer source identification via user, session, and IP address in audit records" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203608 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203608
        STIG ID    : SRG-OS-000041-GPOS-00019
        Rule ID    : SV-203608r958420_rule
        Rule Title : The operating system must produce audit records containing information to establish the outcome of the events.
        DiscussMD5 : 2eca18ddec7a59bc9b66e73ba86fb2f6
        CheckMD5   : b88dc2524c47991223c62a6604a8c591
        FixMD5     : f743a36e8ec7d812e051e9b7444e396f
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203608"
    $RuleID = "SV-203608r958420_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Audit records contain outcome (success/failure) information" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd running
    $FindingDetails += "--- Check 1: auditd Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: Audit rules capture success/failure outcomes
    $FindingDetails += "--- Check 2: Audit Rules with Success/Failure Filters ---" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $exitRules = (($auditRules -split $nl) | Where-Object { $_ -match "-F exit=" -or $_ -match "-F success=" -or $_ -match "always,exit" })
        $eCount = ($exitRules | Measure-Object).Count
        $FindingDetails += "  Rules with exit/success filters: $eCount" + $nl
        if ($eCount -gt 0) {
            $FindingDetails += "  [PASS] Audit rules capture event outcomes" + $nl
            $sampleRules = ($exitRules | Select-Object -First 5)
            foreach ($r in $sampleRules) {
                $FindingDetails += "    $r" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No exit/success filter rules found" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] No audit rules loaded" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Audit log contains success/failure outcome fields
    $FindingDetails += "--- Check 3: Audit Log Outcome Fields ---" + $nl
    $logSample = $(timeout 5 tail -50 /var/log/audit/audit.log 2>&1)
    if ($logSample -and ($logSample -notmatch "No such file")) {
        $outcomeEntries = (($logSample -split $nl) | Where-Object { $_ -match "success=(yes|no)" })
        $oCount = ($outcomeEntries | Measure-Object).Count
        $FindingDetails += "  Entries with success=yes/no: $oCount / 50 sampled" + $nl
        if ($oCount -gt 0) {
            $FindingDetails += "  [PASS] Audit logs record event outcomes" + $nl
        }
        else {
            $FindingDetails += "  [INFO] No success= fields in recent log sample" + $nl
        }
    }
    else {
        $FindingDetails += "  [FAIL] /var/log/audit/audit.log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer success/failure outcome tracking in all audit records" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203609 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203609
        STIG ID    : SRG-OS-000042-GPOS-00020
        Rule ID    : SV-203609r958422_rule
        Rule Title : The operating system must generate audit records containing the full-text recording of privileged commands.
        DiscussMD5 : 82f52faae755879445f8984647067cca
        CheckMD5   : 3316d5343b5b5c89a785d5c48f472303
        FixMD5     : dfe825d2054edad8a7b8efffa54cc762
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203609"
    $RuleID = "SV-203609r958422_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Full-text recording of privileged commands" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd running
    $FindingDetails += "--- Check 1: auditd Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: Audit rules for SUID/SGID privileged commands
    $FindingDetails += "--- Check 2: Privileged Command Audit Rules ---" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $privRules = (($auditRules -split $nl) | Where-Object { $_ -match "execve" -or $_ -match "-F perm=x" -or $_ -match "privileged" -or $_ -match "-F auid>=1000" })
        $pCount = ($privRules | Measure-Object).Count
        $FindingDetails += "  Privileged command rules: $pCount" + $nl
        if ($pCount -gt 0) {
            $FindingDetails += "  [PASS] Audit rules capture privileged command execution" + $nl
            $sampleRules = ($privRules | Select-Object -First 5)
            foreach ($r in $sampleRules) {
                $FindingDetails += "    $r" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No privileged command audit rules found" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] No audit rules loaded" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Audit log contains EXECVE records (full command text)
    $FindingDetails += "--- Check 3: Audit Log EXECVE Records ---" + $nl
    $execveEntries = $(timeout 5 grep -c "type=EXECVE" /var/log/audit/audit.log 2>&1)
    if ($execveEntries -match "^\d+$" -and [int]$execveEntries -gt 0) {
        $FindingDetails += "  EXECVE records in audit log: $execveEntries" + $nl
        $FindingDetails += "  [PASS] Full command text recorded via EXECVE audit records" + $nl
    }
    else {
        $FindingDetails += "  EXECVE records: 0 or log not accessible" + $nl
        $FindingDetails += "  [INFO] No EXECVE records found - privileged command logging may not be configured" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer full-text recording of administrative actions including parameters" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203610 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203610
        STIG ID    : SRG-OS-000042-GPOS-00021
        Rule ID    : SV-203610r958422_rule
        Rule Title : The operating system must produce audit records containing the individual identities of group account users.
        DiscussMD5 : 89fcdf4aa7650648ea690ff4294d40e3
        CheckMD5   : 6b32736f81004a756ad001837443f882
        FixMD5     : e194eaee42ebb9fd7b58bd2fc8abbda4
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203610"
    $RuleID = "SV-203610r958422_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Audit records contain individual identity of group account users" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd running
    $FindingDetails += "--- Check 1: auditd Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: Audit rules capture UID/AUID for user identity tracking
    $FindingDetails += "--- Check 2: Audit Rules with Identity Tracking ---" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $uidRules = (($auditRules -split $nl) | Where-Object { $_ -match "-F auid" -or $_ -match "-F uid" -or $_ -match "-F euid" })
        $uCount = ($uidRules | Measure-Object).Count
        $FindingDetails += "  Rules with UID/AUID filters: $uCount" + $nl
        if ($uCount -gt 0) {
            $FindingDetails += "  [PASS] Audit rules track individual user identity (auid/uid)" + $nl
            $sampleRules = ($uidRules | Select-Object -First 5)
            foreach ($r in $sampleRules) {
                $FindingDetails += "    $r" + $nl
            }
        }
        else {
            $FindingDetails += "  [FAIL] No UID/AUID tracking rules found" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] No audit rules loaded" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Audit log contains uid/auid fields
    $FindingDetails += "--- Check 3: Audit Log Identity Fields ---" + $nl
    $logSample = $(timeout 5 tail -30 /var/log/audit/audit.log 2>&1)
    if ($logSample -and ($logSample -notmatch "No such file")) {
        $auidEntries = (($logSample -split $nl) | Where-Object { $_ -match "auid=\d+" })
        $aCount = ($auidEntries | Measure-Object).Count
        $FindingDetails += "  Entries with auid= field: $aCount / 30 sampled" + $nl
        if ($aCount -gt 0) {
            $FindingDetails += "  [PASS] Audit logs record individual identity via auid (login UID)" + $nl
        }
        else {
            $FindingDetails += "  [INFO] No auid= fields in recent log sample" + $nl
        }
    }
    else {
        $FindingDetails += "  [FAIL] /var/log/audit/audit.log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer individual user identification via authenticated session tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203611 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203611
        STIG ID    : SRG-OS-000046-GPOS-00022
        Rule ID    : SV-203611r958424_rule
        Rule Title : The operating system must alert the ISSO and SA (at a minimum) in the event of an audit processing failure.
        DiscussMD5 : d2265e6da5af70833a6754855affed42
        CheckMD5   : 6b32054e04eb9fb7aba045ed1a7e4908
        FixMD5     : de0d56bb6081a1b0397e9b4dc2a4082b
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203611"
    $RuleID = "SV-203611r958424_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Auditd Failure Action Configuration" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $auditdConf = $(timeout 5 cat /etc/audit/auditd.conf 2>&1)
    if ($auditdConf) {
        $confStr = ($auditdConf -join $nl)
        $FindingDetails += "auditd.conf found" + $nl
        $spaceLeft = ($auditdConf | Where-Object { $_ -match "^\s*space_left_action" })
        $adminSpace = ($auditdConf | Where-Object { $_ -match "^\s*admin_space_left_action" })
        $diskFull = ($auditdConf | Where-Object { $_ -match "^\s*disk_full_action" })
        $diskError = ($auditdConf | Where-Object { $_ -match "^\s*disk_error_action" })
        if ($spaceLeft) { $FindingDetails += "  $($spaceLeft.Trim())" + $nl } else { $FindingDetails += "  space_left_action: NOT SET" + $nl; $auditIssues++ }
        if ($adminSpace) { $FindingDetails += "  $($adminSpace.Trim())" + $nl } else { $FindingDetails += "  admin_space_left_action: NOT SET" + $nl; $auditIssues++ }
        if ($diskFull) { $FindingDetails += "  $($diskFull.Trim())" + $nl } else { $FindingDetails += "  disk_full_action: NOT SET" + $nl }
        if ($diskError) { $FindingDetails += "  $($diskError.Trim())" + $nl } else { $FindingDetails += "  disk_error_action: NOT SET" + $nl }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: /etc/audit/auditd.conf not found (auditd not installed)" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Email/Alert Notification Configuration" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $actionMailAcct = ($auditdConf | Where-Object { $_ -match "^\s*action_mail_acct" })
    if ($actionMailAcct) {
        $FindingDetails += "  $($actionMailAcct.Trim())" + $nl
        $FindingDetails += "PASS: Mail notification configured for audit failures" + $nl
    }
    else {
        $auditIssues++
        $FindingDetails += "action_mail_acct: NOT SET" + $nl
        $FindingDetails += "FAIL: No email alert configured for audit processing failures" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Mail Transfer Agent (postfix/sendmail/ssmtp)" + $nl
    $FindingDetails += "-----------------------------------------------------" + $nl
    $mailAgent = $(timeout 5 dpkg -l postfix sendmail ssmtp msmtp 2>/dev/null | grep -E "^ii" 2>&1)
    if ($mailAgent) {
        $FindingDetails += ($mailAgent -join $nl) + $nl
        $FindingDetails += "PASS: Mail transfer agent installed" + $nl
    }
    else {
        $auditIssues++
        $FindingDetails += "No MTA package found (postfix, sendmail, ssmtp, msmtp)" + $nl
        $FindingDetails += "FAIL: No mail agent to deliver audit failure alerts" + $nl
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer account modification event recording via user management action tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203613 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203613
        STIG ID    : SRG-OS-000051-GPOS-00024
        Rule ID    : SV-203613r958428_rule
        Rule Title : The operating system must provide the capability to centrally review and analyze audit records from multiple components within the system.
        DiscussMD5 : 6904c05787b629724d6b3b5ed82095e4
        CheckMD5   : 17f931170eca55e783ca304cf3c598c8
        FixMD5     : add8c51325227b7f9af845c5459a3915
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203613"
    $RuleID = "SV-203613r958428_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Centralized Log Forwarding (rsyslog/syslog-ng)" + $nl
    $FindingDetails += "-------------------------------------------------------" + $nl
    $rsyslogConf = $(timeout 5 cat /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null | grep -E "^[^#]*@@?" 2>&1)
    if ($rsyslogConf) {
        $FindingDetails += "Remote syslog destinations found:" + $nl
        foreach ($line in $rsyslogConf) { $FindingDetails += "  $line" + $nl }
        $FindingDetails += "PASS: Centralized log forwarding configured" + $nl
    }
    else {
        $syslogNg = $(timeout 5 cat /etc/syslog-ng/syslog-ng.conf 2>/dev/null | grep -i "destination.*tcp\|destination.*udp" 2>&1)
        if ($syslogNg) {
            $FindingDetails += "syslog-ng remote destinations found:" + $nl
            foreach ($line in $syslogNg) { $FindingDetails += "  $line" + $nl }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No remote syslog forwarding configured" + $nl
        }
    }

    $FindingDetails += $nl + "CHECK 2: Audit Review Tools (aureport/ausearch)" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $aureport = $(which aureport 2>/dev/null)
    $ausearch = $(which ausearch 2>/dev/null)
    if ($aureport -and $ausearch) {
        $FindingDetails += "aureport: $aureport" + $nl
        $FindingDetails += "ausearch: $ausearch" + $nl
        $FindingDetails += "PASS: Audit review and analysis tools available" + $nl
    }
    else {
        $auditIssues++
        $FindingDetails += "aureport: $(if ($aureport) { $aureport } else { 'NOT FOUND' })" + $nl
        $FindingDetails += "ausearch: $(if ($ausearch) { $ausearch } else { 'NOT FOUND' })" + $nl
        $FindingDetails += "FAIL: Audit review tools not installed" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Systemd Journal Remote Forwarding" + $nl
    $FindingDetails += "-------------------------------------------" + $nl
    $journalUpload = $(systemctl is-active systemd-journal-upload 2>&1)
    $journalRemote = $(systemctl is-active systemd-journal-remote 2>&1)
    $FindingDetails += "journal-upload: $journalUpload" + $nl
    $FindingDetails += "journal-remote: $journalRemote" + $nl
    if ($journalUpload -eq "active" -or $journalRemote -eq "active") {
        $FindingDetails += "PASS: Systemd journal remote forwarding active" + $nl
    }
    else {
        $FindingDetails += "INFO: Systemd journal remote services not active (may use rsyslog instead)" + $nl
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd file permission monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203614 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203614
        STIG ID    : SRG-OS-000054-GPOS-00025
        Rule ID    : SV-203614r958430_rule
        Rule Title : The operating system must provide the capability to filter audit records for events of interest based upon organization-defined criteria.
        DiscussMD5 : 53c879702032e4380c671fc3183b6dc3
        CheckMD5   : 47be41f6d8e749b206106fbbef1f4173
        FixMD5     : b2a0bf614a43e874cfb3f6dd409e8c67
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203614"
    $RuleID = "SV-203614r958430_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Audit Record Filtering Tools (ausearch/aureport)" + $nl
    $FindingDetails += "---------------------------------------------------------" + $nl
    $ausearch = $(which ausearch 2>/dev/null)
    $aureport = $(which aureport 2>/dev/null)
    if ($ausearch) {
        $FindingDetails += "ausearch: $ausearch" + $nl
        $ausearchVer = $(ausearch --version 2>&1)
        if ($ausearchVer) { $FindingDetails += "  Version: $ausearchVer" + $nl }
    }
    else {
        $auditIssues++
        $FindingDetails += "ausearch: NOT FOUND" + $nl
    }
    if ($aureport) {
        $FindingDetails += "aureport: $aureport" + $nl
        $aureportVer = $(aureport --version 2>&1)
        if ($aureportVer) { $FindingDetails += "  Version: $aureportVer" + $nl }
    }
    else {
        $auditIssues++
        $FindingDetails += "aureport: NOT FOUND" + $nl
    }
    if ($ausearch -and $aureport) {
        $FindingDetails += "PASS: Audit record filtering tools available" + $nl
    }
    else {
        $FindingDetails += "FAIL: Required audit filtering tools not installed" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Log Format (structured/parseable)" + $nl
    $FindingDetails += "-------------------------------------------------" + $nl
    $auditLog = $(timeout 5 tail -5 /var/log/audit/audit.log 2>&1)
    if ($auditLog) {
        $logStr = ($auditLog -join $nl)
        if ($logStr -match "type=") {
            $FindingDetails += "Audit log uses structured format (type= field-based records)" + $nl
            $FindingDetails += "Sample (last 5 lines):" + $nl
            foreach ($line in $auditLog) {
                $truncated = if ($line.Length -gt 120) { $line.Substring(0, 120) + "..." } else { $line }
                $FindingDetails += "  $truncated" + $nl
            }
            $FindingDetails += "PASS: Audit log format supports field-based filtering" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "Audit log does not appear to use structured format" + $nl
            $FindingDetails += "FAIL: Cannot confirm filterable audit record format" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: Cannot read /var/log/audit/audit.log" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Text Processing Tools for Log Analysis" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $awk = $(which awk 2>/dev/null)
    $grep = $(which grep 2>/dev/null)
    $sort = $(which sort 2>/dev/null)
    $FindingDetails += "awk: $(if ($awk) { $awk } else { 'NOT FOUND' })" + $nl
    $FindingDetails += "grep: $(if ($grep) { $grep } else { 'NOT FOUND' })" + $nl
    $FindingDetails += "sort: $(if ($sort) { $sort } else { 'NOT FOUND' })" + $nl
    if ($awk -and $grep -and $sort) {
        $FindingDetails += "PASS: Text processing tools available for audit filtering" + $nl
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: Missing text processing tools" + $nl
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd file size monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203615 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203615
        STIG ID    : SRG-OS-000055-GPOS-00026
        Rule ID    : SV-203615r958432_rule
        Rule Title : The operating system must use internal system clocks to generate time stamps for audit records.
        DiscussMD5 : 768292b082d2729b5001c6d568bd497b
        CheckMD5   : 149da3784910df8123b5d187965412ec
        FixMD5     : 7e5e665a7887a13161eaedffa9855f97
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203615"
    $RuleID = "SV-203615r958432_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Time Synchronization Service Status" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $ntpActive = $(systemctl is-active ntp 2>&1)
    $chronyActive = $(systemctl is-active chrony 2>&1)
    $timesyncdActive = $(systemctl is-active systemd-timesyncd 2>&1)
    $FindingDetails += "ntp: $ntpActive" + $nl
    $FindingDetails += "chrony: $chronyActive" + $nl
    $FindingDetails += "systemd-timesyncd: $timesyncdActive" + $nl
    if ($ntpActive -eq "active" -or $chronyActive -eq "active" -or $timesyncdActive -eq "active") {
        $FindingDetails += "PASS: Time synchronization service is active" + $nl
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No time synchronization service is active" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: System Clock Sync Status (timedatectl)" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $timedatectl = $(timedatectl status 2>&1)
    if ($timedatectl) {
        foreach ($line in $timedatectl) { $FindingDetails += "  $line" + $nl }
        $tdStr = ($timedatectl -join $nl)
        if ($tdStr -match "System clock synchronized:\s*yes" -or $tdStr -match "NTP synchronized:\s*yes") {
            $FindingDetails += "PASS: System clock is synchronized" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: System clock not confirmed synchronized" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: timedatectl not available" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Audit Record Timestamp Verification" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $auditSample = $(timeout 5 tail -3 /var/log/audit/audit.log 2>&1)
    if ($auditSample) {
        foreach ($line in $auditSample) {
            $truncated = if ($line.Length -gt 120) { $line.Substring(0, 120) + "..." } else { $line }
            $FindingDetails += "  $truncated" + $nl
        }
        $sampleStr = ($auditSample -join $nl)
        if ($sampleStr -match "msg=audit\(\d+\.\d+:") {
            $FindingDetails += "PASS: Audit records contain epoch timestamps from system clock" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: Audit records do not contain expected timestamp format" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: Cannot read /var/log/audit/audit.log" + $nl
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit log file ownership; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203616 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203616
        STIG ID    : SRG-OS-000057-GPOS-00027
        Rule ID    : SV-203616r958434_rule
        Rule Title : The operating system must protect audit information from unauthorized read access.
        DiscussMD5 : 43c974692aa673a19512db7a10dec0c3
        CheckMD5   : be14db231ac89af70fc0fcbe0c3c793a
        FixMD5     : f7627d4ebeaf99315622c088fdb14fe2
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203616"
    $RuleID = "SV-203616r958434_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Audit Log Directory Permissions" + $nl
    $FindingDetails += "----------------------------------------" + $nl
    $auditDirPerms = $(timeout 5 stat -c "%a %U:%G %n" /var/log/audit 2>&1)
    if ($auditDirPerms -and $auditDirPerms -notmatch "No such file") {
        $FindingDetails += "$auditDirPerms" + $nl
        if ($auditDirPerms -match "^(\d+)\s") {
            $dirMode = $matches[1]
            $dirModeInt = [int]$dirMode
            if ($dirModeInt -le 750) {
                $FindingDetails += "PASS: Directory permissions $dirMode restrict read access" + $nl
            }
            else {
                $auditIssues++
                $FindingDetails += "FAIL: Directory permissions $dirMode allow unauthorized read (expected 750 or less)" + $nl
            }
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: /var/log/audit directory not found" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Log File Permissions" + $nl
    $FindingDetails += "------------------------------------" + $nl
    $auditFiles = $(timeout 5 stat -c "%a %U:%G %n" /var/log/audit/audit.log /var/log/audit/audit.log.* 2>/dev/null)
    if ($auditFiles) {
        foreach ($f in $auditFiles) {
            $FindingDetails += "$f" + $nl
            if ($f -match "^(\d+)\s") {
                $fileMode = [int]$matches[1]
                if ($fileMode -gt 640) {
                    $auditIssues++
                    $FindingDetails += "  FAIL: Permissions $($matches[1]) allow unauthorized read (expected 640 or less)" + $nl
                }
            }
        }
        $allGood = $true
        foreach ($f in $auditFiles) {
            if ($f -match "^(\d+)\s" -and [int]$matches[1] -gt 640) { $allGood = $false }
        }
        if ($allGood) {
            $FindingDetails += "PASS: All audit log files restrict read access" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit log files found" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Audit Log File Ownership" + $nl
    $FindingDetails += "----------------------------------" + $nl
    $auditOwner = $(timeout 5 stat -c "%U:%G" /var/log/audit/audit.log 2>&1)
    if ($auditOwner -and $auditOwner -notmatch "No such file") {
        $FindingDetails += "audit.log owner: $auditOwner" + $nl
        if ($auditOwner -match "^root:") {
            $FindingDetails += "PASS: Audit log owned by root" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: Audit log not owned by root (owner: $auditOwner)" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: Cannot determine audit log ownership" + $nl
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit log file permissions; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203617 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203617
        STIG ID    : SRG-OS-000058-GPOS-00028
        Rule ID    : SV-203617r958436_rule
        Rule Title : The operating system must protect audit information from unauthorized modification.
        DiscussMD5 : 87135d56de28e5755674201788df14c6
        CheckMD5   : 7629e58c98d38408be21639dda054f10
        FixMD5     : 2f3814bf7d1893bf4da3aa55d741983e
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203617"
    $RuleID = "SV-203617r958436_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Audit Log Directory Write Permissions" + $nl
    $FindingDetails += "----------------------------------------------" + $nl
    $auditDirPerms = $(timeout 5 stat -c "%a %U:%G %n" /var/log/audit 2>&1)
    if ($auditDirPerms -and $auditDirPerms -notmatch "No such file") {
        $FindingDetails += "$auditDirPerms" + $nl
        if ($auditDirPerms -match "^(\d+)\s") {
            $dirMode = $matches[1]
            $groupWrite = [int]([string]$dirMode[1])
            $otherWrite = [int]([string]$dirMode[2])
            if ($groupWrite -band 2 -or $otherWrite -band 2) {
                $auditIssues++
                $FindingDetails += "FAIL: Directory has group or other write permission ($dirMode)" + $nl
            }
            else {
                $FindingDetails += "PASS: Directory restricts write access ($dirMode)" + $nl
            }
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: /var/log/audit directory not found" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Log File Write Restrictions" + $nl
    $FindingDetails += "------------------------------------------" + $nl
    $auditFiles = $(timeout 5 stat -c "%a %U:%G %n" /var/log/audit/audit.log /var/log/audit/audit.log.* 2>/dev/null)
    if ($auditFiles) {
        $writeIssue = $false
        foreach ($f in $auditFiles) {
            $FindingDetails += "$f" + $nl
            if ($f -match "^(\d+)\s") {
                $fMode = $matches[1]
                $fGroup = [int]([string]$fMode[1])
                $fOther = [int]([string]$fMode[2])
                if ($fGroup -band 2 -or $fOther -band 2) {
                    $writeIssue = $true
                    $FindingDetails += "  FAIL: Group or other write enabled ($fMode)" + $nl
                }
            }
        }
        if (-not $writeIssue) {
            $FindingDetails += "PASS: Audit log files restrict write access" + $nl
        }
        else {
            $auditIssues++
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit log files found" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Immutable Attribute on Audit Logs" + $nl
    $FindingDetails += "------------------------------------------" + $nl
    $lsattr = $(timeout 5 lsattr /var/log/audit/audit.log 2>&1)
    if ($lsattr -and $lsattr -notmatch "Operation not supported" -and $lsattr -notmatch "No such file") {
        $FindingDetails += "$lsattr" + $nl
        if (($lsattr -join $nl) -match "----i") {
            $FindingDetails += "INFO: Immutable attribute set on audit.log" + $nl
        }
        else {
            $FindingDetails += "INFO: Immutable attribute not set (optional hardening)" + $nl
        }
    }
    else {
        $FindingDetails += "INFO: lsattr not available or not supported on this filesystem" + $nl
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit log file size monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203618 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203618
        STIG ID    : SRG-OS-000059-GPOS-00029
        Rule ID    : SV-203618r958438_rule
        Rule Title : The operating system must protect audit information from unauthorized deletion.
        DiscussMD5 : 7768cca50360c34537f5b230e2bddaf1
        CheckMD5   : 8054e920ac47c7d1f0a91318e0010efe
        FixMD5     : e10ca84858b3f1e2db2475afc158741f
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203618"
    $RuleID = "SV-203618r958438_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Audit Directory Deletion Protection" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $auditDirPerms = $(timeout 5 stat -c "%a %U:%G %n" /var/log/audit 2>&1)
    if ($auditDirPerms -and $auditDirPerms -notmatch "No such file") {
        $FindingDetails += "$auditDirPerms" + $nl
        if ($auditDirPerms -match "^(\d+)\s") {
            $dirMode = $matches[1]
            $otherPerms = [int]([string]$dirMode[2])
            if ($otherPerms -band 2) {
                $auditIssues++
                $FindingDetails += "FAIL: Others have write/delete permission on audit directory ($dirMode)" + $nl
            }
            else {
                $FindingDetails += "PASS: Audit directory restricts deletion access ($dirMode)" + $nl
            }
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: /var/log/audit directory not found" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Log File Deletion Protection" + $nl
    $FindingDetails += "--------------------------------------------" + $nl
    $auditFiles = $(timeout 5 stat -c "%a %U:%G %n" /var/log/audit/audit.log /var/log/audit/audit.log.* 2>/dev/null)
    if ($auditFiles) {
        $deleteIssue = $false
        foreach ($f in $auditFiles) {
            $FindingDetails += "$f" + $nl
            if ($f -match "^(\d+)\s") {
                $fOther = [int]([string]$matches[1][2])
                if ($fOther -band 2) {
                    $deleteIssue = $true
                    $FindingDetails += "  FAIL: Others have write permission ($($matches[1]))" + $nl
                }
            }
        }
        if (-not $deleteIssue) {
            $FindingDetails += "PASS: Audit log files protected from unauthorized deletion" + $nl
        }
        else {
            $auditIssues++
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit log files found" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Audit Log Retention Configuration" + $nl
    $FindingDetails += "------------------------------------------" + $nl
    $auditdConf = $(timeout 5 cat /etc/audit/auditd.conf 2>&1)
    if ($auditdConf) {
        $maxLogFile = ($auditdConf | Where-Object { $_ -match "^\s*max_log_file_action" })
        $numLogs = ($auditdConf | Where-Object { $_ -match "^\s*num_logs" })
        if ($maxLogFile) { $FindingDetails += "  $($maxLogFile.Trim())" + $nl } else { $FindingDetails += "  max_log_file_action: NOT SET" + $nl }
        if ($numLogs) { $FindingDetails += "  $($numLogs.Trim())" + $nl } else { $FindingDetails += "  num_logs: NOT SET" + $nl }
        $confStr = ($auditdConf -join $nl)
        if ($confStr -match "max_log_file_action\s*=\s*(ROTATE|keep_logs|KEEP_LOGS)") {
            $FindingDetails += "PASS: Log rotation configured to preserve audit records" + $nl
        }
        else {
            $FindingDetails += "INFO: Verify max_log_file_action preserves audit data" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: /etc/audit/auditd.conf not found" + $nl
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer account enabling/disabling event recording via user status change tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203619 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203619
        STIG ID    : SRG-OS-000062-GPOS-00031
        Rule ID    : SV-203619r958442_rule
        Rule Title : The operating system must provide audit record generation capability for DoD-defined auditable events for all operating system components.
        DiscussMD5 : f6d248216833196eab3c1f5640891bd5
        CheckMD5   : a058c0611f2f92622f895f745f156f16
        FixMD5     : 31712c41e7e2d87cadfc7cfd1d25346d
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203619"
    $RuleID = "SV-203619r958442_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Audit record generation for DoD-defined auditable events" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd service and package installed
    $FindingDetails += "--- Check 1: auditd Installation and Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $auditPkg = $(timeout 5 dpkg -l auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    $auditInstalled = ($auditPkg -match "ii\s+auditd")
    $FindingDetails += "  Package installed: $(if ($auditInstalled) { 'Yes' } else { 'No' })" + $nl
    if ($auditdStatus -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    # Check 2: DoD event coverage — access/logon/account/kernel module auditing
    $FindingDetails += "--- Check 2: DoD Event Coverage ---" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $ruleText = ($auditRules -join $nl)
        $totalRules = (($auditRules -split $nl) | Where-Object { $_.Trim().Length -gt 0 } | Measure-Object).Count
        $FindingDetails += "  Total loaded audit rules: $totalRules" + $nl + $nl

        # DoD Category 1: Access/modification of security objects
        $accessRules = (($auditRules -split $nl) | Where-Object { $_ -match "/etc/passwd|/etc/shadow|/etc/group|/etc/gshadow|/etc/security" })
        $FindingDetails += "  Cat 1 - Security object access rules: $(($accessRules | Measure-Object).Count)" + $nl

        # DoD Category 2: Logon/access attempts
        $logonRules = (($auditRules -split $nl) | Where-Object { $_ -match "faillog|lastlog|tallylog|pam" })
        $FindingDetails += "  Cat 2 - Logon/access attempt rules: $(($logonRules | Measure-Object).Count)" + $nl

        # DoD Category 3: Account changes
        $accountRules = (($auditRules -split $nl) | Where-Object { $_ -match "passwd|group|shadow|opasswd|usermod|useradd|userdel" })
        $FindingDetails += "  Cat 3 - Account modification rules: $(($accountRules | Measure-Object).Count)" + $nl

        # DoD Category 4: Kernel module actions
        $kernelRules = (($auditRules -split $nl) | Where-Object { $_ -match "init_module|delete_module|finit_module|insmod|rmmod|modprobe" })
        $FindingDetails += "  Cat 4 - Kernel module rules: $(($kernelRules | Measure-Object).Count)" + $nl

        if ($totalRules -ge 10) {
            $FindingDetails += $nl + "  [PASS] Comprehensive audit rules loaded covering DoD event categories" + $nl
        }
        else {
            $FindingDetails += $nl + "  [FAIL] Insufficient audit rules for DoD event coverage (minimum ~10 expected)" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [FAIL] No audit rules loaded" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Audit configuration files present
    $FindingDetails += "--- Check 3: Audit Configuration Files ---" + $nl
    $rulesDir = $(timeout 5 ls /etc/audit/rules.d/ 2>&1)
    if ($rulesDir -and ($rulesDir -notmatch "No such file")) {
        $ruleFiles = (($rulesDir -split $nl) | Where-Object { $_ -match "\.rules$" })
        $FindingDetails += "  Rule files in /etc/audit/rules.d/: $(($ruleFiles | Measure-Object).Count)" + $nl
        foreach ($f in $ruleFiles) {
            $FindingDetails += "    $f" + $nl
        }
    }
    else {
        $FindingDetails += "  [FAIL] /etc/audit/rules.d/ not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer comprehensive event coverage including access, logon, account, and configuration changes" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203620 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203620
        STIG ID    : SRG-OS-000063-GPOS-00032
        Rule ID    : SV-203620r958444_rule
        Rule Title : The operating system must provide the capability for the ISSM to select which auditable events are to be audited by specific components of the system.
        DiscussMD5 : c7c8150e501b98a446f1747adad39741
        CheckMD5   : fd26a3a451b85635b610fd70388e1dec
        FixMD5     : 27db219d80c200843271658eca57969f
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203620"
    $RuleID = "SV-203620r958444_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Audit Rules File Ownership and Permissions" + $nl
    $FindingDetails += "---------------------------------------------------" + $nl
    $ruleFiles = @("/etc/audit/audit.rules", "/etc/audit/rules.d")
    foreach ($rf in $ruleFiles) {
        $rfPerms = $(timeout 5 stat -c "%a %U:%G %n" $rf 2>&1)
        if ($rfPerms -and $rfPerms -notmatch "No such file") {
            $FindingDetails += "$rfPerms" + $nl
            if ($rfPerms -match "^(\d+)\s+(\S+)") {
                $mode = $matches[1]
                $owner = $matches[2]
                if ($owner -ne "root:root") {
                    $auditIssues++
                    $FindingDetails += "  FAIL: Not owned by root:root" + $nl
                }
                $otherPerms = [int]([string]$mode[2])
                if ($otherPerms -band 2) {
                    $auditIssues++
                    $FindingDetails += "  FAIL: Others have write access ($mode)" + $nl
                }
            }
        }
        else {
            $FindingDetails += "$rf : NOT FOUND" + $nl
        }
    }
    $rulesD = $(timeout 5 stat -c "%a %U:%G %n" /etc/audit/rules.d/*.rules 2>/dev/null)
    if ($rulesD) {
        foreach ($rd in $rulesD) {
            $FindingDetails += "$rd" + $nl
            if ($rd -match "^(\d+)\s+(\S+)") {
                if ($matches[2] -ne "root:root") {
                    $auditIssues++
                    $FindingDetails += "  FAIL: Rule file not owned by root:root" + $nl
                }
            }
        }
    }
    if ($auditIssues -eq 0) {
        $FindingDetails += "PASS: Audit rules restricted to root ownership" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Auditd Configuration Access Control" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $auditdConfPerms = $(timeout 5 stat -c "%a %U:%G %n" /etc/audit/auditd.conf 2>&1)
    if ($auditdConfPerms -and $auditdConfPerms -notmatch "No such file") {
        $FindingDetails += "$auditdConfPerms" + $nl
        if ($auditdConfPerms -match "^(\d+)\s+(\S+)") {
            if ($matches[2] -eq "root:root" -and [int]$matches[1] -le 640) {
                $FindingDetails += "PASS: auditd.conf restricted to root access" + $nl
            }
            else {
                $auditIssues++
                $FindingDetails += "FAIL: auditd.conf not properly restricted" + $nl
            }
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: /etc/audit/auditd.conf not found" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Auditctl Command Restricted to Root" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $auditctl = $(which auditctl 2>/dev/null)
    if ($auditctl) {
        $auditctlPerms = $(timeout 5 stat -c "%a %U:%G %n" $auditctl 2>&1)
        $FindingDetails += "$auditctlPerms" + $nl
        if ($auditctlPerms -match "^(\d+)\s+(\S+)") {
            if ($matches[2] -match "^root:") {
                $FindingDetails += "PASS: auditctl owned by root" + $nl
            }
            else {
                $auditIssues++
                $FindingDetails += "FAIL: auditctl not owned by root" + $nl
            }
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: auditctl not found" + $nl
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit log deletion protection; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203621 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203621
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203621r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203621"
    $RuleID = "SV-203621r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203621) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203622 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203622
        STIG ID    : SRG-OS-000066-GPOS-00034
        Rule ID    : SV-203622r958448_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : e2a8270752f047a81d141756d1bfaa12
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203622"
    $RuleID = "SV-203622r958448_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: CA Certificate Trust Store ---" + $nl
    $caCertsInstalled = $(dpkg -l ca-certificates 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($caCertsInstalled -join $nl) -match "ii\s+ca-certificates") {
        $FindingDetails += "  ca-certificates package: INSTALLED" + $nl
        $certCount = $(timeout 10 find /etc/ssl/certs -maxdepth 1 -name "*.pem" 2>/dev/null | wc -l)
        $FindingDetails += "  Trusted CA certificates: $certCount" + $nl
    }
    else {
        $FindingDetails += "  ca-certificates package: NOT INSTALLED" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: OpenSSL Certificate Validation ---" + $nl
    $opensslVer = $(openssl version 2>&1)
    $FindingDetails += "  OpenSSL version: $opensslVer" + $nl
    $caPath = $(openssl version -d 2>&1)
    $FindingDetails += "  OpenSSL directory: $caPath" + $nl
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: PKI Authentication Configuration ---" + $nl
    $sssdInstalled = $(dpkg -l sssd 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($sssdInstalled -join $nl) -match "ii\s+sssd") {
        $FindingDetails += "  SSSD: INSTALLED" + $nl
        $sssdConf = $(timeout 5 grep -i "certificate_verification" /etc/sssd/sssd.conf 2>/dev/null)
        if ($sssdConf) {
            $FindingDetails += "  Certificate verification config: $sssdConf" + $nl
        }
        else {
            $FindingDetails += "  Certificate verification: Not explicitly configured" + $nl
        }
    }
    else {
        $FindingDetails += "  SSSD: Not installed" + $nl
    }
    $pamPkcs11 = $(dpkg -l libpam-pkcs11 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($pamPkcs11 -join $nl) -match "ii\s+libpam-pkcs11") {
        $FindingDetails += "  libpam-pkcs11: INSTALLED (PKI PAM module)" + $nl
    }
    else {
        $FindingDetails += "  libpam-pkcs11: Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Update-CA-Certificates Status ---" + $nl
    $updateCa = $(timeout 5 update-ca-certificates --fresh 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  update-ca-certificates: Functional" + $nl
    }
    else {
        $FindingDetails += "  update-ca-certificates: Error or not available" + $nl
    }

    # Status determination
    if (($caCertsInstalled -join $nl) -match "ii\s+ca-certificates") {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: CA trust store installed but PKI-based authentication" + $nl
        $FindingDetails += "requires organizational configuration of certificate validation" + $nl
        $FindingDetails += "policies (OCSP, CRL, trust anchors)." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: CA certificates package not detected." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203623 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203623
        STIG ID    : SRG-OS-000067-GPOS-00035
        Rule ID    : SV-203623r958450_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 8d6b85c6e6aaf242631121963a4a7365
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203623"
    $RuleID = "SV-203623r958450_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Private Key File Permissions ---" + $nl
    $keyDirs = @("/etc/ssl/private", "/etc/pki/tls/private", "/etc/xo-server", "/opt/xo")
    $keysFound = 0
    $permIssues = 0
    foreach ($dir in $keyDirs) {
        $keys = $(timeout 10 find $dir -maxdepth 3 -name "*.key" -o -name "*.pem" 2>/dev/null)
        if ($keys) {
            foreach ($keyFile in ($keys -split $nl)) {
                if (-not $keyFile) { continue }
                $keysFound++
                $perms = $(stat -c "%a %U:%G" $keyFile 2>&1)
                $FindingDetails += "  $keyFile : $perms" + $nl
                if ($perms -match "^(\d+)") {
                    $mode = $matches[1]
                    $worldBits = [int]($mode[-1].ToString())
                    $groupBits = [int]($mode[-2].ToString())
                    if ($worldBits -gt 0 -or $groupBits -gt 4) {
                        $FindingDetails += "    [FAIL] Permissions too permissive" + $nl
                        $permIssues++
                    }
                    else {
                        $FindingDetails += "    [PASS] Permissions restrictive" + $nl
                    }
                }
            }
        }
    }
    if ($keysFound -eq 0) {
        $FindingDetails += "  No private key files found in standard locations" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: SSL Private Directory Permissions ---" + $nl
    $sslPrivDir = "/etc/ssl/private"
    if (Test-Path $sslPrivDir -ErrorAction SilentlyContinue) {
        $dirPerms = $(stat -c "%a %U:%G" $sslPrivDir 2>&1)
        $FindingDetails += "  $sslPrivDir : $dirPerms" + $nl
        if ($dirPerms -match "^700\s+root:") {
            $FindingDetails += "    [PASS] Directory restricted to root only" + $nl
        }
        else {
            $FindingDetails += "    [WARN] Directory permissions may be too open" + $nl
            $permIssues++
        }
    }
    else {
        $FindingDetails += "  /etc/ssl/private: Directory not found" + $nl
    }

    # Status determination
    if ($keysFound -gt 0 -and $permIssues -eq 0) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: $keysFound private key(s) found with appropriate access controls." + $nl
    }
    elseif ($keysFound -gt 0 -and $permIssues -gt 0) {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: $permIssues permission issue(s) found on private key files." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No private key files detected in standard locations." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203624 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203624
        STIG ID    : SRG-OS-000068-GPOS-00036
        Rule ID    : SV-203624r958452_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : b17847cde3dfdaf2994807bdfa7b9055
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203624"
    $RuleID = "SV-203624r958452_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: PAM PKI Identity Mapping ---" + $nl
    $pamPkcs11 = $(dpkg -l libpam-pkcs11 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($pamPkcs11 -join $nl) -match "ii\s+libpam-pkcs11") {
        $FindingDetails += "  libpam-pkcs11: INSTALLED" + $nl
        $mapperConf = $(timeout 5 cat /etc/pam_pkcs11/pam_pkcs11.conf 2>/dev/null)
        if ($mapperConf) {
            $FindingDetails += "  PAM PKCS#11 config: Found" + $nl
            $mapperLines = ($mapperConf -join $nl) -split $nl | Where-Object { $_ -match "mapper" }
            foreach ($line in $mapperLines) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  PAM PKCS#11 config: /etc/pam_pkcs11/pam_pkcs11.conf not found" + $nl
        }
    }
    else {
        $FindingDetails += "  libpam-pkcs11: Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: SSSD Certificate Mapping ---" + $nl
    $sssdInstalled = $(dpkg -l sssd 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($sssdInstalled -join $nl) -match "ii\s+sssd") {
        $FindingDetails += "  SSSD: INSTALLED" + $nl
        $certMap = $(timeout 5 grep -i "certmap\|certificate" /etc/sssd/sssd.conf 2>/dev/null)
        if ($certMap) {
            $FindingDetails += "  Certificate mapping rules found:" + $nl
            foreach ($line in ($certMap -split $nl)) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  No certificate mapping rules in sssd.conf" + $nl
        }
    }
    else {
        $FindingDetails += "  SSSD: Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: NSS/PAM User Lookup ---" + $nl
    $nsswitch = $(timeout 5 grep -E "^passwd:" /etc/nsswitch.conf 2>/dev/null)
    $FindingDetails += "  nsswitch passwd: $nsswitch" + $nl
    $pamAuth = $(timeout 5 grep -v "^#" /etc/pam.d/common-auth 2>/dev/null)
    if ($pamAuth) {
        $FindingDetails += "  PAM auth modules:" + $nl
        foreach ($line in ($pamAuth -split $nl)) {
            if ($line.Trim()) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
    }

    # Status determination — PKI mapping requires org config
    $Status = "Open"
    $FindingDetails += $nl + "RESULT: PKI-based identity mapping requires organizational" + $nl
    $FindingDetails += "configuration of certificate-to-user mapping (SSSD certmap rules" + $nl
    $FindingDetails += "or PAM PKCS#11 mapper configuration)." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203625 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203625
        STIG ID    : SRG-OS-000069-GPOS-00037
        Rule ID    : SV-203625r982195_rule
        Rule Title : Enforce at least one uppercase character in passwords
        DiscussMD5 : 99a2d25eeb7b76c3aa02868f9e43242f
        CheckMD5   : 496fdd17dbbaf166ee75c3cbf2efea43
        FixMD5     : ae57efbe228547b2e48aef050b5615fb
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203625"
    $RuleID = "SV-203625r982195_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: pwquality.conf ucredit setting
    $output += "Check 1: pwquality.conf ucredit Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'ucredit'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "ucredit\s*=\s*(-?\d+)") {
            $ucreditVal = [int]$Matches[1]
            $output += "  ucredit = $ucreditVal${nl}"
            if ($ucreditVal -le -1) {
                $output += "  [PASS] Requires at least $([Math]::Abs($ucreditVal)) uppercase character(s)${nl}"
            }
            else {
                $output += "  [FAIL] ucredit must be -1 or less (negative = required minimum)${nl}"
            }
        }
        else {
            $output += "  [FAIL] ucredit not configured in /etc/security/pwquality.conf${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: libpam-pwquality package installed
    $output += "Check 3: libpam-pwquality Package${nl}"
    try {
        $pkgCheck = $(timeout 5 sh -c "dpkg -l libpam-pwquality 2>/dev/null | grep '^ii'" 2>&1)
        $pkgStr = ($pkgCheck -join $nl).Trim()
        if ($pkgStr) {
            $output += "  $pkgStr${nl}"
            $output += "  [PASS] libpam-pwquality installed${nl}"
        }
        else {
            $output += "  [FAIL] libpam-pwquality not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($pwqStr -match "ucredit\s*=\s*(-\d+)" -and $pamStr) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203626 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203626
        STIG ID    : SRG-OS-000070-GPOS-00038
        Rule ID    : SV-203626r982196_rule
        Rule Title : Enforce at least one lowercase character in passwords
        DiscussMD5 : 99a2d25eeb7b76c3aa02868f9e43242f
        CheckMD5   : e6a734b4a402bdf7eb43fdee70aaa9b7
        FixMD5     : 2eb316478931bee6469f556fcba2ac66
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203626"
    $RuleID = "SV-203626r982196_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: pwquality.conf lcredit setting
    $output += "Check 1: pwquality.conf lcredit Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'lcredit'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "lcredit\s*=\s*(-?\d+)") {
            $lcreditVal = [int]$Matches[1]
            $output += "  lcredit = $lcreditVal${nl}"
            if ($lcreditVal -le -1) {
                $output += "  [PASS] Requires at least $([Math]::Abs($lcreditVal)) lowercase character(s)${nl}"
            }
            else {
                $output += "  [FAIL] lcredit must be -1 or less (negative = required minimum)${nl}"
            }
        }
        else {
            $output += "  [FAIL] lcredit not configured in /etc/security/pwquality.conf${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: libpam-pwquality package installed
    $output += "Check 3: libpam-pwquality Package${nl}"
    try {
        $pkgCheck = $(timeout 5 sh -c "dpkg -l libpam-pwquality 2>/dev/null | grep '^ii'" 2>&1)
        $pkgStr = ($pkgCheck -join $nl).Trim()
        if ($pkgStr) {
            $output += "  $pkgStr${nl}"
            $output += "  [PASS] libpam-pwquality installed${nl}"
        }
        else {
            $output += "  [FAIL] libpam-pwquality not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($pwqStr -match "lcredit\s*=\s*(-\d+)" -and $pamStr) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203627 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203627
        STIG ID    : SRG-OS-000071-GPOS-00039
        Rule ID    : SV-203627r982197_rule
        Rule Title : Enforce at least one numeric character in passwords
        DiscussMD5 : 99a2d25eeb7b76c3aa02868f9e43242f
        CheckMD5   : 5dc2ecf906da00aa9583b69a95dfc884
        FixMD5     : 50c1ccfbbd81a52d874a6f5583cb42c2
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203627"
    $RuleID = "SV-203627r982197_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: pwquality.conf dcredit setting
    $output += "Check 1: pwquality.conf dcredit Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'dcredit'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "dcredit\s*=\s*(-?\d+)") {
            $dcreditVal = [int]$Matches[1]
            $output += "  dcredit = $dcreditVal${nl}"
            if ($dcreditVal -le -1) {
                $output += "  [PASS] Requires at least $([Math]::Abs($dcreditVal)) numeric character(s)${nl}"
            }
            else {
                $output += "  [FAIL] dcredit must be -1 or less (negative = required minimum)${nl}"
            }
        }
        else {
            $output += "  [FAIL] dcredit not configured in /etc/security/pwquality.conf${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: libpam-pwquality package installed
    $output += "Check 3: libpam-pwquality Package${nl}"
    try {
        $pkgCheck = $(timeout 5 sh -c "dpkg -l libpam-pwquality 2>/dev/null | grep '^ii'" 2>&1)
        $pkgStr = ($pkgCheck -join $nl).Trim()
        if ($pkgStr) {
            $output += "  $pkgStr${nl}"
            $output += "  [PASS] libpam-pwquality installed${nl}"
        }
        else {
            $output += "  [FAIL] libpam-pwquality not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($pwqStr -match "dcredit\s*=\s*(-\d+)" -and $pamStr) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203628 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203628
        STIG ID    : SRG-OS-000072-GPOS-00040
        Rule ID    : SV-203628r982198_rule
        Rule Title : Require change of at least 50 percent of characters when passwords are changed
        DiscussMD5 : 94b34da36f3cd5b68971b25689c6ab88
        CheckMD5   : 518709842be86b47f0a1d41e1776759c
        FixMD5     : 8a617271f33fe51dc45fc7b042539922
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203628"
    $RuleID = "SV-203628r982198_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: pwquality.conf difok setting (minimum different characters)
    $output += "Check 1: pwquality.conf difok Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'difok'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "difok\s*=\s*(\d+)") {
            $difokVal = [int]$Matches[1]
            $output += "  difok = $difokVal${nl}"
            if ($difokVal -ge 8) {
                $output += "  [PASS] Requires at least $difokVal different characters (meets 50% of 15-char minimum)${nl}"
            }
            else {
                $output += "  [FAIL] difok must be 8 or greater (50% of 15-character minimum = 8)${nl}"
            }
        }
        else {
            $output += "  [FAIL] difok not configured in /etc/security/pwquality.conf (default is 1)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Current minlen to validate difok ratio
    $output += "Check 3: Minimum Password Length (for difok ratio)${nl}"
    try {
        $minlenConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'minlen'" 2>&1)
        $minlenStr = ($minlenConf -join $nl).Trim()
        if ($minlenStr -match "minlen\s*=\s*(\d+)") {
            $minlenVal = [int]$Matches[1]
            $requiredDifok = [Math]::Ceiling($minlenVal / 2)
            $output += "  minlen = $minlenVal (50% = $requiredDifok characters must differ)${nl}"
        }
        else {
            $output += "  [INFO] minlen not set (default 8; STIG requires 15)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status - difok >= 8 AND pam_pwquality loaded
    if ($pwqStr -match "difok\s*=\s*(\d+)") {
        $checkVal = [int]$Matches[1]
        if ($checkVal -ge 8 -and $pamStr) {
            $Status = "NotAFinding"
        }
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203629 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203629
        STIG ID    : SRG-OS-000073-GPOS-00041
        Rule ID    : SV-203629r982199_rule
        Rule Title : The operating system must store only encrypted representations of passwords.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203629"
    $RuleID = "SV-203629r982199_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203629 - Store Only Encrypted Representations of Passwords" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Verify password hashing algorithm in /etc/login.defs
    $FindingDetails += "Check 1: System Password Hashing Algorithm (/etc/login.defs)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $loginDefs = Get-Content /etc/login.defs -ErrorAction SilentlyContinue
    $loginDefsStr = ($loginDefs -join $nl)
    $encryptMethod = ""

    if ($loginDefsStr -match "(?m)^ENCRYPT_METHOD\s+(\S+)") {
        $encryptMethod = $matches[1]
        $FindingDetails += "ENCRYPT_METHOD: " + $encryptMethod + $nl
    } else {
        $FindingDetails += "ENCRYPT_METHOD: Not configured (default)" + $nl
    }

    $approvedHashes = @("SHA512", "YESCRYPT")
    $hashOk = $encryptMethod -in $approvedHashes
    if ($hashOk) {
        $FindingDetails += "  PASS: Using approved hashing algorithm" + $nl
    } else {
        $FindingDetails += "  FAIL: Expected SHA512 or YESCRYPT" + $nl
    }

    $FindingDetails += $nl

    # Check 2: Verify /etc/shadow uses hashed passwords
    $FindingDetails += "Check 2: Password Hash Verification (/etc/shadow)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $shadowContent = Get-Content /etc/shadow -ErrorAction SilentlyContinue
    $unhashed = 0
    $locked = 0
    $hashed = 0
    $totalAccts = 0

    foreach ($line in $shadowContent) {
        if ($line -match "^([^:]+):([^:]*):") {
            $acctName = $matches[1]
            $hashField = $matches[2]
            $totalAccts++

            if ($hashField -eq "" -or $hashField -eq " ") {
                $FindingDetails += "  FAIL: Empty password field for account: " + $acctName + $nl
                $unhashed++
            } elseif ($hashField -match "^[!*]") {
                $locked++
            } elseif ($hashField -match "^\$") {
                $hashed++
            }
        }
    }

    $FindingDetails += "Total accounts: " + $totalAccts + $nl
    $FindingDetails += "Hashed passwords: " + $hashed + $nl
    $FindingDetails += "Locked/disabled: " + $locked + $nl
    $FindingDetails += "Empty/unhashed: " + $unhashed + $nl

    $FindingDetails += $nl

    # Check 3: Verify PAM password module configuration
    $FindingDetails += "Check 3: PAM Password Hashing (/etc/pam.d/common-password)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $pamPw = Get-Content /etc/pam.d/common-password -ErrorAction SilentlyContinue
    $pamPwStr = ($pamPw -join $nl)
    $pamHashOk = $false

    if ($pamPwStr -match "pam_unix\.so.*sha512") {
        $FindingDetails += "PAM: sha512 hashing configured" + $nl
        $pamHashOk = $true
    } elseif ($pamPwStr -match "pam_unix\.so.*yescrypt") {
        $FindingDetails += "PAM: yescrypt hashing configured" + $nl
        $pamHashOk = $true
    } else {
        $FindingDetails += "PAM: No explicit strong hashing algorithm configured" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($unhashed -gt 0) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Accounts with empty/unhashed passwords detected" + $nl
    } elseif (-not $hashOk -and -not $pamHashOk) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - No approved password hashing algorithm configured" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - All passwords stored using approved hashing algorithms" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203630 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203630
        STIG ID    : SRG-OS-000074-GPOS-00042
        Rule ID    : SV-203630r987796_rule
        Rule Title : The operating system must transmit only encrypted representations of passwords.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203630"
    $RuleID = "SV-203630r987796_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203630 - Transmit Only Encrypted Representations of Passwords" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Verify SSH encrypts all traffic including passwords
    $FindingDetails += "Check 1: SSH Encryption of Password Transmission" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    if ($sshdStr -match "(?m)^ciphers\s+(.+)$") {
        $cipherLine = $matches[1].Trim()
        $FindingDetails += "SSH Ciphers: " + $cipherLine + $nl
        $FindingDetails += "  PASS: SSH encrypts all traffic, including password transmission" + $nl
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH cipher configuration" + $nl
    }

    $FindingDetails += $nl

    # Check 2: Verify no unencrypted remote access (telnet, rsh, ftp)
    $FindingDetails += "Check 2: Unencrypted Remote Access Services" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $insecureServices = @("telnetd", "rshd", "rlogind", "ftpd", "vsftpd", "proftpd")
    $insecureFound = $false

    foreach ($svc in $insecureServices) {
        $pkgCheck = $(dpkg -l $svc 2>&1)
        $pkgStr = ($pkgCheck -join $nl)
        if ($pkgStr -match "^ii\s") {
            $FindingDetails += "  FAIL: Insecure service installed: " + $svc + $nl
            $insecureFound = $true
        }
    }

    if (-not $insecureFound) {
        $FindingDetails += "  PASS: No insecure remote access services installed" + $nl
    }

    $FindingDetails += $nl

    # Check 3: Verify PermitEmptyPasswords is disabled
    $FindingDetails += "Check 3: SSH PermitEmptyPasswords" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $emptyPwOk = $true
    if ($sshdStr -match "(?m)^permitemptypasswords\s+(\S+)") {
        $permitEmpty = $matches[1].Trim()
        $FindingDetails += "PermitEmptyPasswords: " + $permitEmpty + $nl
        if ($permitEmpty -eq "yes") {
            $FindingDetails += "  FAIL: Empty passwords are permitted" + $nl
            $emptyPwOk = $false
        } else {
            $FindingDetails += "  PASS: Empty passwords are denied" + $nl
        }
    } else {
        $FindingDetails += "PermitEmptyPasswords: not set (default: no)" + $nl
        $FindingDetails += "  PASS: Default denies empty passwords" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($insecureFound -or -not $emptyPwOk) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Unencrypted password transmission possible" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Passwords transmitted only via encrypted channels (SSH)" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203631 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203631
        STIG ID    : SRG-OS-000075-GPOS-00043
        Rule ID    : SV-203631r982188_rule
        Rule Title : Enforce 24 hours/1 day as the minimum password lifetime
        DiscussMD5 : a13f8dd5b3602a221cac064dec313195
        CheckMD5   : 82307decda9dbd3f788fde0641ffa11e
        FixMD5     : c0047ac489fd3595604723612131808b
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203631"
    $RuleID = "SV-203631r982188_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $globalPass = $false

    # Check 1: /etc/login.defs PASS_MIN_DAYS
    $output += "Check 1: /etc/login.defs PASS_MIN_DAYS${nl}"
    try {
        $loginDefs = $(timeout 5 sh -c "grep -v '^#' /etc/login.defs 2>/dev/null | grep -i 'PASS_MIN_DAYS'" 2>&1)
        $loginStr = ($loginDefs -join $nl).Trim()
        if ($loginStr -match "PASS_MIN_DAYS\s+(\d+)") {
            $minDays = [int]$Matches[1]
            $output += "  PASS_MIN_DAYS = $minDays${nl}"
            if ($minDays -ge 1) {
                $output += "  [PASS] Minimum password lifetime is $minDays day(s)${nl}"
                $globalPass = $true
            }
            else {
                $output += "  [FAIL] PASS_MIN_DAYS must be 1 or greater (24 hours)${nl}"
            }
        }
        else {
            $output += "  [FAIL] PASS_MIN_DAYS not configured in /etc/login.defs${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Per-user PASS_MIN_DAYS via chage
    $output += "Check 2: Per-User Minimum Password Age${nl}"
    try {
        $userAccounts = $(timeout 5 sh -c "awk -F: '(\$3 >= 1000 || \$1 == [char]34 + "root" + [char]34) && \$7 !~ /nologin|false/ {print \$1}' /etc/passwd 2>/dev/null" 2>&1)
        $userStr = ($userAccounts -join $nl).Trim()
        if ($userStr) {
            $users = $userStr -split $nl
            $badUsers = @()
            foreach ($user in $users) {
                $u = $user.Trim()
                if (-not $u) { continue }
                $chageOut = $(timeout 5 sh -c "chage -l $u 2>/dev/null | grep -i 'Minimum'" 2>&1)
                $chageStr = ($chageOut -join $nl).Trim()
                if ($chageStr -match ":\s*(\d+)") {
                    $userMin = [int]$Matches[1]
                    if ($userMin -lt 1) {
                        $badUsers += "$u (min=$userMin)"
                    }
                }
                $output += "  $u : $chageStr${nl}"
            }
            if ($badUsers.Count -gt 0) {
                $output += "  [FAIL] Users with min password age below 1 day: $($badUsers -join ', ')${nl}"
            }
            else {
                $output += "  [PASS] All interactive users have minimum password age of 1+ day${nl}"
            }
        }
        else {
            $output += "  [INFO] No interactive user accounts found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($globalPass -and $badUsers.Count -eq 0) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203632 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203632
        STIG ID    : SRG-OS-000076-GPOS-00044
        Rule ID    : SV-203632r1038967_rule
        Rule Title : Enforce a 60-day maximum password lifetime restriction
        DiscussMD5 : aafd6d9d8ba33d1cb645c142d188e48a
        CheckMD5   : e709a33284431dac88ebae638e6071d5
        FixMD5     : 2fc20f1d6dbcf9cf50aaf30431af82f3
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203632"
    $RuleID = "SV-203632r1038967_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $globalPass = $false

    # Check 1: /etc/login.defs PASS_MAX_DAYS
    $output += "Check 1: /etc/login.defs PASS_MAX_DAYS${nl}"
    try {
        $loginDefs = $(timeout 5 sh -c "grep -v '^#' /etc/login.defs 2>/dev/null | grep -i 'PASS_MAX_DAYS'" 2>&1)
        $loginStr = ($loginDefs -join $nl).Trim()
        if ($loginStr -match "PASS_MAX_DAYS\s+(\d+)") {
            $maxDays = [int]$Matches[1]
            $output += "  PASS_MAX_DAYS = $maxDays${nl}"
            if ($maxDays -le 60 -and $maxDays -gt 0) {
                $output += "  [PASS] Maximum password lifetime is $maxDays days${nl}"
                $globalPass = $true
            }
            else {
                $output += "  [FAIL] PASS_MAX_DAYS must be 60 or less (and greater than 0)${nl}"
            }
        }
        else {
            $output += "  [FAIL] PASS_MAX_DAYS not configured in /etc/login.defs${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Per-user PASS_MAX_DAYS via chage
    $output += "Check 2: Per-User Maximum Password Age${nl}"
    try {
        $userAccounts = $(timeout 5 sh -c "awk -F: '(\$3 >= 1000 || \$1 == [char]34 + "root" + [char]34) && \$7 !~ /nologin|false/ {print \$1}' /etc/passwd 2>/dev/null" 2>&1)
        $userStr = ($userAccounts -join $nl).Trim()
        if ($userStr) {
            $users = $userStr -split $nl
            $badUsers = @()
            foreach ($user in $users) {
                $u = $user.Trim()
                if (-not $u) { continue }
                $chageOut = $(timeout 5 sh -c "chage -l $u 2>/dev/null | grep -i 'Maximum'" 2>&1)
                $chageStr = ($chageOut -join $nl).Trim()
                if ($chageStr -match ":\s*(\d+)") {
                    $userMax = [int]$Matches[1]
                    if ($userMax -gt 60 -or $userMax -eq 0) {
                        $badUsers += "$u (max=$userMax)"
                    }
                }
                $output += "  $u : $chageStr${nl}"
            }
            if ($badUsers.Count -gt 0) {
                $output += "  [FAIL] Users with max password age above 60 days: $($badUsers -join ', ')${nl}"
            }
            else {
                $output += "  [PASS] All interactive users have maximum password age of 60 days or less${nl}"
            }
        }
        else {
            $output += "  [INFO] No interactive user accounts found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($globalPass -and $badUsers.Count -eq 0) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203634 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203634
        STIG ID    : SRG-OS-000078-GPOS-00046
        Rule ID    : SV-203634r982202_rule
        Rule Title : Enforce a minimum 15-character password length
        DiscussMD5 : ac553fb941e0c109b52498035d2d0328
        CheckMD5   : cd37e0071acf688fdcfaabcfac908939
        FixMD5     : df1131797123cfe3a5e954aaea4b40e3
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203634"
    $RuleID = "SV-203634r982202_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: pwquality.conf minlen setting
    $output += "Check 1: pwquality.conf minlen Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'minlen'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "minlen\s*=\s*(\d+)") {
            $minlenVal = [int]$Matches[1]
            $output += "  minlen = $minlenVal${nl}"
            if ($minlenVal -ge 15) {
                $output += "  [PASS] Minimum password length is $minlenVal characters${nl}"
            }
            else {
                $output += "  [FAIL] minlen must be 15 or greater (DoD requirement)${nl}"
            }
        }
        else {
            $output += "  [FAIL] minlen not configured in /etc/security/pwquality.conf (default is 8)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: /etc/login.defs PASS_MIN_LEN
    $output += "Check 3: /etc/login.defs PASS_MIN_LEN${nl}"
    try {
        $loginDefs = $(timeout 5 sh -c "grep -v '^#' /etc/login.defs 2>/dev/null | grep -i 'PASS_MIN_LEN'" 2>&1)
        $loginStr = ($loginDefs -join $nl).Trim()
        if ($loginStr -match "PASS_MIN_LEN\s+(\d+)") {
            $passMinLen = [int]$Matches[1]
            $output += "  PASS_MIN_LEN = $passMinLen${nl}"
            if ($passMinLen -ge 15) {
                $output += "  [PASS] login.defs minimum length is $passMinLen${nl}"
            }
            else {
                $output += "  [INFO] login.defs PASS_MIN_LEN is $passMinLen (pwquality.conf takes precedence when pam_pwquality is loaded)${nl}"
            }
        }
        else {
            $output += "  [INFO] PASS_MIN_LEN not explicitly set in /etc/login.defs${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status - pwquality minlen >= 15 AND pam_pwquality loaded
    if ($pwqStr -match "minlen\s*=\s*(\d+)") {
        $checkVal = [int]$Matches[1]
        if ($checkVal -ge 15 -and $pamStr) {
            $Status = "NotAFinding"
        }
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203635 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203635
        STIG ID    : SRG-OS-000079-GPOS-00047
        Rule ID    : SV-203635r958470_rule
        Rule Title : Obscure authentication feedback
        DiscussMD5 : a81ef6dcbd5c41cb990cb98f2763c292
        CheckMD5   : cf3a1d21c85d46e0c090654364055fc3
        FixMD5     : 88d7c7393f5d19486299be28af0606e3
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203635"
    $RuleID = "SV-203635r958470_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $allPass = $true

    # Check 1: PAM password feedback (pam_unix obscure_authtok)
    $output += "Check 1: PAM Password Obscuring${nl}"
    try {
        $pamAuth = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_unix" 2>&1)
        $pamStr = ($pamAuth -join $nl).Trim()
        if ($pamStr) {
            $output += "  PAM password config: $pamStr${nl}"
            if ($pamStr -match "obscure") {
                $output += "  [PASS] obscure option enabled in PAM${nl}"
            }
            else {
                $output += "  [INFO] obscure option not explicitly set (default behavior varies)${nl}"
            }
        }
        else {
            $output += "  [INFO] pam_unix not found in common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: SSH password display (no echo)
    $output += "Check 2: SSH Password Display${nl}"
    try {
        $sshConfig = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -iE '^(passwordauthentication|kbdinteractiveauthentication)'" 2>&1)
        $sshStr = ($sshConfig -join $nl).Trim()
        if ($sshStr) {
            foreach ($line in ($sshStr -split $nl)) {
                $output += "  $line${nl}"
            }
            $output += "  [PASS] SSH uses standard terminal password input (no-echo by design)${nl}"
        }
        else {
            $output += "  [INFO] SSH password settings not available${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: sudo password feedback
    $output += "Check 3: sudo Password Feedback${nl}"
    try {
        $sudoConfig = $(timeout 5 sh -c "sudo -l 2>/dev/null | head -5; grep -r 'pwfeedback' /etc/sudoers /etc/sudoers.d/ 2>/dev/null" 2>&1)
        $sudoStr = ($sudoConfig -join $nl).Trim()
        if ($sudoStr -match "pwfeedback") {
            $output += "  [FAIL] pwfeedback enabled in sudoers (shows asterisks - potential information leak)${nl}"
            $allPass = $false
        }
        else {
            $output += "  [PASS] pwfeedback not enabled (password input fully obscured)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status - Linux CLI naturally obscures password input
    if ($allPass) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203636 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203636
        STIG ID    : SRG-OS-000080-GPOS-00048
        Rule ID    : SV-203636r958472_rule
        Rule Title : The operating system must enforce approved authorizations for logical access to information and system resources in accordance with applicable access control policies.
        DiscussMD5 : 9952e0af74c51d638baad42c46129c1a
        CheckMD5   : 51947530def454e6048ccbc9e102f905
        FixMD5     : 40c36c61fe8a98748e0d1b640f8abb4e
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203636"
    $RuleID = "SV-203636r958472_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $accessControlled = $false

    # Check 1: SSH access restrictions
    $output += "Check 1: SSH Access Restrictions${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl)
        $hasRestriction = $false
        if ($sshdStr -match "allowusers\s+(\S.*)") {
            $output += "  [PASS] AllowUsers: $($Matches[1])${nl}"
            $hasRestriction = $true
        }
        if ($sshdStr -match "allowgroups\s+(\S.*)") {
            $output += "  [PASS] AllowGroups: $($Matches[1])${nl}"
            $hasRestriction = $true
        }
        if ($sshdStr -match "denyusers\s+(\S.*)") {
            $output += "  [PASS] DenyUsers: $($Matches[1])${nl}"
            $hasRestriction = $true
        }
        if ($sshdStr -match "denygroups\s+(\S.*)") {
            $output += "  [PASS] DenyGroups: $($Matches[1])${nl}"
            $hasRestriction = $true
        }
        if (-not $hasRestriction) {
            $output += "  [FAIL] No SSH AllowUsers/AllowGroups/DenyUsers/DenyGroups configured${nl}"
        }
        else {
            $accessControlled = $true
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: File permission enforcement on critical files
    $output += "Check 2: Critical File Permissions${nl}"
    try {
        $critFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow")
        foreach ($f in $critFiles) {
            $perms = $(timeout 5 stat -c '%a %U:%G' $f 2>&1)
            $permsStr = ($perms -join " ").Trim()
            $output += "  $f : $permsStr${nl}"
        }
        $shadowPerms = $(timeout 5 stat -c '%a' /etc/shadow 2>&1)
        $shadowStr = ($shadowPerms -join " ").Trim()
        if ($shadowStr -match "^(0|640|600)$") {
            $output += "  [PASS] /etc/shadow permissions restrictive ($shadowStr)${nl}"
        }
        else {
            $output += "  [FAIL] /etc/shadow permissions too permissive ($shadowStr)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: sudo/su access control
    $output += "Check 3: Privilege Escalation Controls${nl}"
    try {
        $sudoInstalled = $(timeout 5 dpkg -l sudo 2>&1)
        $sudoStr = ($sudoInstalled -join $nl)
        if ($sudoStr -match "^ii\s+sudo") {
            $output += "  [PASS] sudo installed${nl}"
            $sudoers = $(timeout 5 cat /etc/sudoers 2>&1)
            $sudoersStr = ($sudoers -join $nl)
            if ($sudoersStr -match "^(?!#).*ALL=\(ALL") {
                $output += "  [INFO] sudo ALL rules detected (verify least privilege)${nl}"
            }
            $accessControlled = $true
        }
        else {
            $output += "  [FAIL] sudo not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: PAM access control
    $output += "Check 4: PAM Access Control${nl}"
    try {
        $accessConf = $(timeout 5 cat /etc/security/access.conf 2>&1)
        $accessStr = ($accessConf -join $nl)
        $activeRules = ($accessStr -split $nl) | Where-Object { $_ -match "^[+-]" }
        if ($activeRules.Count -gt 0) {
            $output += "  [PASS] $($activeRules.Count) active rules in access.conf${nl}"
            $accessControlled = $true
        }
        else {
            $output += "  [INFO] No active rules in /etc/security/access.conf${nl}"
        }
    }
    catch {
        $output += "  [INFO] /etc/security/access.conf not accessible${nl}"
    }

    if ($accessControlled) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203637 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203637
        STIG ID    : SRG-OS-000095-GPOS-00049
        Rule ID    : SV-203637r958478_rule
        Rule Title : The operating system must be configured to disable non-essential capabilities.
        DiscussMD5 : db7f19036bb002eb88c4d34412a9105c
        CheckMD5   : a3d9c4ad2427c1d5b123dddedc761a6e
        FixMD5     : fff1b9f4592c762433c8425c226ccd4c
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203637"
    $RuleID = "SV-203637r958478_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $issues = 0

    # Check 1: SSH non-essential features
    $output += "Check 1: SSH Non-Essential Features${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl)

        $sshFeatures = @(
            @{ Name = "X11Forwarding"; Pattern = "x11forwarding\s+yes"; Good = "no" },
            @{ Name = "AllowTcpForwarding"; Pattern = "allowtcpforwarding\s+yes"; Good = "no" },
            @{ Name = "AllowAgentForwarding"; Pattern = "allowagentforwarding\s+yes"; Good = "no" },
            @{ Name = "PermitTunnel"; Pattern = "permittunnel\s+yes"; Good = "no" },
            @{ Name = "GatewayPorts"; Pattern = "gatewayports\s+yes"; Good = "no" }
        )

        foreach ($feat in $sshFeatures) {
            if ($sshdStr -match $feat.Pattern) {
                $output += "  [FAIL] $($feat.Name) is enabled (should be $($feat.Good))${nl}"
                $issues++
            }
            elseif ($sshdStr -match "$($feat.Name.ToLower())\s+(\S+)") {
                $output += "  [PASS] $($feat.Name): $($Matches[1])${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Non-essential services running
    $output += "Check 2: Non-Essential Services${nl}"
    try {
        $nonEssential = @("avahi-daemon", "cups", "bluetooth", "rpcbind", "nfs-server", "vsftpd", "telnet")
        foreach ($svc in $nonEssential) {
            $svcStatus = $(timeout 5 systemctl is-active $svc 2>&1)
            $svcStr = ($svcStatus -join " ").Trim()
            if ($svcStr -eq "active") {
                $output += "  [FAIL] $svc is active (non-essential service)${nl}"
                $issues++
            }
        }
        if ($issues -eq 0) {
            $output += "  [PASS] No non-essential services detected${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Non-essential packages
    $output += "Check 3: Non-Essential Packages${nl}"
    try {
        $nonEssPkgs = @("telnetd", "rsh-server", "ypserv", "tftp-server", "xinetd")
        $foundPkgs = @()
        foreach ($pkg in $nonEssPkgs) {
            $pkgCheck = $(timeout 5 dpkg -l $pkg 2>&1)
            $pkgStr = ($pkgCheck -join $nl)
            if ($pkgStr -match "^ii\s+$pkg") {
                $foundPkgs += $pkg
                $output += "  [FAIL] $pkg is installed (non-essential)${nl}"
                $issues++
            }
        }
        if ($foundPkgs.Count -eq 0) {
            $output += "  [PASS] No non-essential packages installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    if ($issues -eq 0) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203638 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203638
        STIG ID    : SRG-OS-000096-GPOS-00050
        Rule ID    : SV-203638r958480_rule
        Rule Title : The operating system must be configured to prohibit or restrict the use of functions, ports, protocols, and/or services, as defined in the PPSM CAL and vulnerability assessments.
        DiscussMD5 : 98e4e4e36c59048838a5918fb6c01d56
        CheckMD5   : 7f30c501b6cf4549e93fc5d64bcc1eb5
        FixMD5     : 9dbe524105c638b17db26066eb58f7b5
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203638"
    $RuleID = "SV-203638r958480_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $firewallActive = $false

    # XO Deployment Model context
    $xoModel = Get-XODeploymentModel
    $output += "--- XO Deployment Model ---${nl}"
    $output += "  $($xoModel.Details)${nl}${nl}"

    # Check 1: Firewall status
    $output += "Check 1: Firewall Status${nl}"
    try {
        $ufwStatus = $(timeout 5 ufw status 2>&1)
        $ufwStr = ($ufwStatus -join $nl).Trim()
        if ($ufwStr -match "Status: active") {
            $output += "  [PASS] UFW firewall is active${nl}"
            $firewallActive = $true
            $ufwRules = $(timeout 5 ufw status verbose 2>&1)
            $ufwRulesStr = ($ufwRules -join $nl).Trim()
            $output += "  Default policy:${nl}"
            if ($ufwRulesStr -match "Default:\s*(.+)") {
                $output += "    $($Matches[1])${nl}"
            }
        }
        else {
            $output += "  [INFO] UFW not active${nl}"
        }
    }
    catch {
        $output += "  [INFO] UFW not available${nl}"
    }

    if (-not $firewallActive) {
        try {
            $nftRules = $(timeout 5 nft list ruleset 2>&1)
            $nftStr = ($nftRules -join $nl).Trim()
            if ($nftStr -and $nftStr -match "table" -and $nftStr -notmatch "command not found") {
                $output += "  [PASS] nftables ruleset present${nl}"
                $firewallActive = $true
            }
        }
        catch { }

        if (-not $firewallActive) {
            try {
                $iptRules = $(timeout 5 iptables -L -n 2>&1)
                $iptStr = ($iptRules -join $nl).Trim()
                $ruleCount = (($iptStr -split $nl) | Where-Object { $_ -match "^(ACCEPT|DROP|REJECT)" }).Count
                if ($ruleCount -gt 0) {
                    $output += "  [PASS] iptables rules present ($ruleCount rules)${nl}"
                    $firewallActive = $true
                }
                else {
                    $output += "  [FAIL] No active firewall detected (UFW/nftables/iptables)${nl}"
                }
            }
            catch {
                $output += "  [FAIL] No active firewall detected${nl}"
            }
        }
    }
    if (-not $firewallActive -and $xoModel.Model -eq "XOCE") {
        $output += "  [INFO] XOCE does not include a firewall by default — configure UFW or nftables${nl}"
    }
    $output += $nl

    # Check 2: Listening ports
    $output += "Check 2: Listening Network Ports${nl}"
    try {
        $listeners = $(timeout 5 ss -tlnp 2>&1)
        $listStr = ($listeners -join $nl).Trim()
        $lines = ($listStr -split $nl) | Where-Object { $_ -match "LISTEN" }
        $output += "  Active listening ports: $($lines.Count)${nl}"
        foreach ($line in $lines) {
            $output += "    $line${nl}"
        }
    }
    catch {
        $output += "  [ERROR] Unable to enumerate listening ports${nl}"
    }
    $output += $nl

    # Check 3: SSH port configuration
    $output += "Check 3: SSH Port Configuration${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl)
        if ($sshdStr -match "port\s+(\d+)") {
            $sshPort = $Matches[1]
            $output += "  SSH listening on port: $sshPort${nl}"
            if ($sshPort -eq "22") {
                $output += "  [INFO] Using default SSH port 22${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] Unable to check SSH port${nl}"
    }

    if ($firewallActive) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203639 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203639
        STIG ID    : SRG-OS-000104-GPOS-00051
        Rule ID    : SV-203639r958482_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 993e303cc0524e389a86324889b585ab
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203639"
    $RuleID = "SV-203639r958482_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Unique User Accounts ---" + $nl
    $userCount = $(timeout 5 grep -c "^" /etc/passwd 2>&1)
    $FindingDetails += "  Total accounts in /etc/passwd: $userCount" + $nl
    $humanUsers = $(timeout 5 awk -F: "(\$3 >= 1000 && \$3 < 65534) {print \$1 \":\" \$3}" /etc/passwd 2>&1)
    if ($humanUsers) {
        $FindingDetails += "  Human user accounts (UID >= 1000):" + $nl
        foreach ($user in ($humanUsers -split $nl)) {
            if ($user.Trim()) {
                $FindingDetails += "    $user" + $nl
            }
        }
    }
    else {
        $FindingDetails += "  No human user accounts (UID >= 1000) found" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Duplicate UID Detection ---" + $nl
    $dupUids = $(timeout 5 awk -F: "{print \$3}" /etc/passwd 2>/dev/null | sort | uniq -d)
    if ($dupUids) {
        $FindingDetails += "  [FAIL] Duplicate UIDs found: $dupUids" + $nl
    }
    else {
        $FindingDetails += "  [PASS] No duplicate UIDs detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Duplicate Username Detection ---" + $nl
    $dupNames = $(timeout 5 awk -F: "{print \$1}" /etc/passwd 2>/dev/null | sort | uniq -d)
    if ($dupNames) {
        $FindingDetails += "  [FAIL] Duplicate usernames found: $dupNames" + $nl
    }
    else {
        $FindingDetails += "  [PASS] No duplicate usernames detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Authentication Method ---" + $nl
    $loginDefs = $(timeout 5 grep -E "^(UID_MIN|UID_MAX|LOGIN_RETRIES)" /etc/login.defs 2>/dev/null)
    if ($loginDefs) {
        foreach ($line in ($loginDefs -split $nl)) {
            $FindingDetails += "  $($line.Trim())" + $nl
        }
    }
    $nsswitch = $(timeout 5 grep -E "^passwd:" /etc/nsswitch.conf 2>/dev/null)
    $FindingDetails += "  nsswitch passwd: $nsswitch" + $nl

    # Status determination
    if (-not $dupUids -and -not $dupNames) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: All user accounts have unique UIDs and usernames." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Duplicate UIDs or usernames detected." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203640 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203640
        STIG ID    : SRG-OS-000105-GPOS-00052
        Rule ID    : SV-203640r958484_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 2a691d0d44ab7c9b1d83005d50dd23ce
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203640"
    $RuleID = "SV-203640r958484_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Smartcard/PKI Authentication ---" + $nl
    $pkcs11 = $(dpkg -l libpam-pkcs11 2>&1)
    $opensc = $(dpkg -l opensc 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($pkcs11 -join $nl) -match "ii\s+libpam-pkcs11") {
        $FindingDetails += "  libpam-pkcs11: INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  libpam-pkcs11: Not installed" + $nl
    }
    if (($opensc -join $nl) -match "ii\s+opensc") {
        $FindingDetails += "  opensc (smartcard): INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  opensc (smartcard): Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: SSSD with MFA ---" + $nl
    $sssdInstalled = $(dpkg -l sssd 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($sssdInstalled -join $nl) -match "ii\s+sssd") {
        $FindingDetails += "  SSSD: INSTALLED" + $nl
        $mfaConf = $(timeout 5 grep -iE "auth_provider|certificate|two_factor|prompting" /etc/sssd/sssd.conf 2>/dev/null)
        if ($mfaConf) {
            foreach ($line in ($mfaConf -split $nl)) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  No MFA-related SSSD configuration found" + $nl
        }
    }
    else {
        $FindingDetails += "  SSSD: Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: PAM MFA Modules ---" + $nl
    $pamGoogle = $(dpkg -l libpam-google-authenticator 2>&1)
    $pamYubi = $(dpkg -l libpam-yubico 2>&1)
    $pamOath = $(dpkg -l libpam-oath 2>&1)
    if (($pamGoogle -join $nl) -match "ii\s+libpam-google") {
        $FindingDetails += "  libpam-google-authenticator: INSTALLED (TOTP)" + $nl
    }
    if (($pamYubi -join $nl) -match "ii\s+libpam-yubico") {
        $FindingDetails += "  libpam-yubico: INSTALLED (YubiKey)" + $nl
    }
    if (($pamOath -join $nl) -match "ii\s+libpam-oath") {
        $FindingDetails += "  libpam-oath: INSTALLED (OATH)" + $nl
    }
    if (-not (($pamGoogle -join $nl) -match "ii") -and -not (($pamYubi -join $nl) -match "ii") -and -not (($pamOath -join $nl) -match "ii")) {
        $FindingDetails += "  No PAM MFA modules detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: SSH MFA Configuration ---" + $nl
    $sshAuth = $(timeout 5 grep -E "^(AuthenticationMethods|ChallengeResponseAuthentication|PubkeyAuthentication)" /etc/ssh/sshd_config 2>/dev/null)
    if ($sshAuth) {
        foreach ($line in ($sshAuth -split $nl)) {
            $FindingDetails += "  $($line.Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No explicit MFA SSH configuration found" + $nl
    }


    $FindingDetails += "--- Check 5: XO auth-ldap (AD Authentication Delegation) ---" + $nl
    $xoLdapInfo = Get-XOAuthLdapInfo
    $ldapCompensates = $false
    if ($xoLdapInfo.Enabled) {
        $FindingDetails += "  XO auth-ldap Plugin: ACTIVE" + $nl
        if ($xoLdapInfo.LdapUri) { $FindingDetails += "  LDAP Server: $($xoLdapInfo.LdapUri)" + $nl }
        if ($xoLdapInfo.BaseDN) { $FindingDetails += "  Base DN: $($xoLdapInfo.BaseDN)" + $nl }
        $FindingDetails += "  Source: $($xoLdapInfo.Details)" + $nl
        $FindingDetails += "  [PASS] User authentication delegated to AD via auth-ldap; AD enforces MFA for network access to privileged accounts" + $nl
        $ldapCompensates = $true
    }
    else {
        $FindingDetails += "  XO auth-ldap Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoLdapInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No AD/LDAP authentication delegation available" + $nl
    }
    $FindingDetails += $nl
    # Status determination
    if ($ldapCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "COMPENSATING CONTROL: Authentication is delegated to Active Directory" + $nl
        $FindingDetails += "via the XO auth-ldap plugin. AD enforces MFA policies for all network" + $nl
        $FindingDetails += "access to privileged accounts. The ISSO/ISSM should verify that AD MFA" + $nl
        $FindingDetails += "policy is active and enrolled for all privileged users." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: MFA for network access to privileged accounts requires organizational deployment" + $nl
        $FindingDetails += "of smartcard/PKI (CAC/PIV), TOTP, or hardware token authentication." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203641 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203641
        STIG ID    : SRG-OS-000106-GPOS-00053
        Rule ID    : SV-203641r958486_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 94fafe4d6838a29495b6fd5728bdf2bc
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203641"
    $RuleID = "SV-203641r958486_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Smartcard/PKI Authentication ---" + $nl
    $pkcs11 = $(dpkg -l libpam-pkcs11 2>&1)
    $opensc = $(dpkg -l opensc 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($pkcs11 -join $nl) -match "ii\s+libpam-pkcs11") {
        $FindingDetails += "  libpam-pkcs11: INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  libpam-pkcs11: Not installed" + $nl
    }
    if (($opensc -join $nl) -match "ii\s+opensc") {
        $FindingDetails += "  opensc (smartcard): INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  opensc (smartcard): Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: SSSD with MFA ---" + $nl
    $sssdInstalled = $(dpkg -l sssd 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($sssdInstalled -join $nl) -match "ii\s+sssd") {
        $FindingDetails += "  SSSD: INSTALLED" + $nl
        $mfaConf = $(timeout 5 grep -iE "auth_provider|certificate|two_factor|prompting" /etc/sssd/sssd.conf 2>/dev/null)
        if ($mfaConf) {
            foreach ($line in ($mfaConf -split $nl)) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  No MFA-related SSSD configuration found" + $nl
        }
    }
    else {
        $FindingDetails += "  SSSD: Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: PAM MFA Modules ---" + $nl
    $pamGoogle = $(dpkg -l libpam-google-authenticator 2>&1)
    $pamYubi = $(dpkg -l libpam-yubico 2>&1)
    $pamOath = $(dpkg -l libpam-oath 2>&1)
    if (($pamGoogle -join $nl) -match "ii\s+libpam-google") {
        $FindingDetails += "  libpam-google-authenticator: INSTALLED (TOTP)" + $nl
    }
    if (($pamYubi -join $nl) -match "ii\s+libpam-yubico") {
        $FindingDetails += "  libpam-yubico: INSTALLED (YubiKey)" + $nl
    }
    if (($pamOath -join $nl) -match "ii\s+libpam-oath") {
        $FindingDetails += "  libpam-oath: INSTALLED (OATH)" + $nl
    }
    if (-not (($pamGoogle -join $nl) -match "ii") -and -not (($pamYubi -join $nl) -match "ii") -and -not (($pamOath -join $nl) -match "ii")) {
        $FindingDetails += "  No PAM MFA modules detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: SSH MFA Configuration ---" + $nl
    $sshAuth = $(timeout 5 grep -E "^(AuthenticationMethods|ChallengeResponseAuthentication|PubkeyAuthentication)" /etc/ssh/sshd_config 2>/dev/null)
    if ($sshAuth) {
        foreach ($line in ($sshAuth -split $nl)) {
            $FindingDetails += "  $($line.Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No explicit MFA SSH configuration found" + $nl
    }


    $FindingDetails += "--- Check 5: XO auth-ldap (AD Authentication Delegation) ---" + $nl
    $xoLdapInfo = Get-XOAuthLdapInfo
    $ldapCompensates = $false
    if ($xoLdapInfo.Enabled) {
        $FindingDetails += "  XO auth-ldap Plugin: ACTIVE" + $nl
        if ($xoLdapInfo.LdapUri) { $FindingDetails += "  LDAP Server: $($xoLdapInfo.LdapUri)" + $nl }
        if ($xoLdapInfo.BaseDN) { $FindingDetails += "  Base DN: $($xoLdapInfo.BaseDN)" + $nl }
        $FindingDetails += "  Source: $($xoLdapInfo.Details)" + $nl
        $FindingDetails += "  [PASS] User authentication delegated to AD via auth-ldap; AD enforces MFA for network access to non-privileged accounts" + $nl
        $ldapCompensates = $true
    }
    else {
        $FindingDetails += "  XO auth-ldap Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoLdapInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No AD/LDAP authentication delegation available" + $nl
    }
    $FindingDetails += $nl
    # Status determination
    if ($ldapCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "COMPENSATING CONTROL: Authentication is delegated to Active Directory" + $nl
        $FindingDetails += "via the XO auth-ldap plugin. AD enforces MFA policies for all network" + $nl
        $FindingDetails += "access to non-privileged accounts. The ISSO/ISSM should verify that AD" + $nl
        $FindingDetails += "MFA policy is active and enrolled for all users." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: MFA for network access to non-privileged accounts requires organizational deployment" + $nl
        $FindingDetails += "of smartcard/PKI (CAC/PIV), TOTP, or hardware token authentication." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203642 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203642
        STIG ID    : SRG-OS-000107-GPOS-00054
        Rule ID    : SV-203642r982203_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : f0fc62130e0b3d39e98b46ff64542bb9
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203642"
    $RuleID = "SV-203642r982203_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Smartcard/PKI Authentication ---" + $nl
    $pkcs11 = $(dpkg -l libpam-pkcs11 2>&1)
    $opensc = $(dpkg -l opensc 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($pkcs11 -join $nl) -match "ii\s+libpam-pkcs11") {
        $FindingDetails += "  libpam-pkcs11: INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  libpam-pkcs11: Not installed" + $nl
    }
    if (($opensc -join $nl) -match "ii\s+opensc") {
        $FindingDetails += "  opensc (smartcard): INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  opensc (smartcard): Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: SSSD with MFA ---" + $nl
    $sssdInstalled = $(dpkg -l sssd 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($sssdInstalled -join $nl) -match "ii\s+sssd") {
        $FindingDetails += "  SSSD: INSTALLED" + $nl
        $mfaConf = $(timeout 5 grep -iE "auth_provider|certificate|two_factor|prompting" /etc/sssd/sssd.conf 2>/dev/null)
        if ($mfaConf) {
            foreach ($line in ($mfaConf -split $nl)) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  No MFA-related SSSD configuration found" + $nl
        }
    }
    else {
        $FindingDetails += "  SSSD: Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: PAM MFA Modules ---" + $nl
    $pamGoogle = $(dpkg -l libpam-google-authenticator 2>&1)
    $pamYubi = $(dpkg -l libpam-yubico 2>&1)
    $pamOath = $(dpkg -l libpam-oath 2>&1)
    if (($pamGoogle -join $nl) -match "ii\s+libpam-google") {
        $FindingDetails += "  libpam-google-authenticator: INSTALLED (TOTP)" + $nl
    }
    if (($pamYubi -join $nl) -match "ii\s+libpam-yubico") {
        $FindingDetails += "  libpam-yubico: INSTALLED (YubiKey)" + $nl
    }
    if (($pamOath -join $nl) -match "ii\s+libpam-oath") {
        $FindingDetails += "  libpam-oath: INSTALLED (OATH)" + $nl
    }
    if (-not (($pamGoogle -join $nl) -match "ii") -and -not (($pamYubi -join $nl) -match "ii") -and -not (($pamOath -join $nl) -match "ii")) {
        $FindingDetails += "  No PAM MFA modules detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: SSH MFA Configuration ---" + $nl
    $sshAuth = $(timeout 5 grep -E "^(AuthenticationMethods|ChallengeResponseAuthentication|PubkeyAuthentication)" /etc/ssh/sshd_config 2>/dev/null)
    if ($sshAuth) {
        foreach ($line in ($sshAuth -split $nl)) {
            $FindingDetails += "  $($line.Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No explicit MFA SSH configuration found" + $nl
    }

    # Status determination — MFA requires organizational deployment
    $Status = "Open"
    $FindingDetails += $nl + "RESULT: MFA for local access to privileged accounts requires organizational deployment" + $nl
    $FindingDetails += "of smartcard/PKI (CAC/PIV), TOTP, or hardware token authentication." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203643 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203643
        STIG ID    : SRG-OS-000108-GPOS-00055
        Rule ID    : SV-203643r982204_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : b9d7a810ddfbf05e9fece6cdd05998fb
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203643"
    $RuleID = "SV-203643r982204_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Smartcard/PKI Authentication ---" + $nl
    $pkcs11 = $(dpkg -l libpam-pkcs11 2>&1)
    $opensc = $(dpkg -l opensc 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($pkcs11 -join $nl) -match "ii\s+libpam-pkcs11") {
        $FindingDetails += "  libpam-pkcs11: INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  libpam-pkcs11: Not installed" + $nl
    }
    if (($opensc -join $nl) -match "ii\s+opensc") {
        $FindingDetails += "  opensc (smartcard): INSTALLED" + $nl
    }
    else {
        $FindingDetails += "  opensc (smartcard): Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: SSSD with MFA ---" + $nl
    $sssdInstalled = $(dpkg -l sssd 2>&1)
    if ($LASTEXITCODE -eq 0 -and ($sssdInstalled -join $nl) -match "ii\s+sssd") {
        $FindingDetails += "  SSSD: INSTALLED" + $nl
        $mfaConf = $(timeout 5 grep -iE "auth_provider|certificate|two_factor|prompting" /etc/sssd/sssd.conf 2>/dev/null)
        if ($mfaConf) {
            foreach ($line in ($mfaConf -split $nl)) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  No MFA-related SSSD configuration found" + $nl
        }
    }
    else {
        $FindingDetails += "  SSSD: Not installed" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: PAM MFA Modules ---" + $nl
    $pamGoogle = $(dpkg -l libpam-google-authenticator 2>&1)
    $pamYubi = $(dpkg -l libpam-yubico 2>&1)
    $pamOath = $(dpkg -l libpam-oath 2>&1)
    if (($pamGoogle -join $nl) -match "ii\s+libpam-google") {
        $FindingDetails += "  libpam-google-authenticator: INSTALLED (TOTP)" + $nl
    }
    if (($pamYubi -join $nl) -match "ii\s+libpam-yubico") {
        $FindingDetails += "  libpam-yubico: INSTALLED (YubiKey)" + $nl
    }
    if (($pamOath -join $nl) -match "ii\s+libpam-oath") {
        $FindingDetails += "  libpam-oath: INSTALLED (OATH)" + $nl
    }
    if (-not (($pamGoogle -join $nl) -match "ii") -and -not (($pamYubi -join $nl) -match "ii") -and -not (($pamOath -join $nl) -match "ii")) {
        $FindingDetails += "  No PAM MFA modules detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: SSH MFA Configuration ---" + $nl
    $sshAuth = $(timeout 5 grep -E "^(AuthenticationMethods|ChallengeResponseAuthentication|PubkeyAuthentication)" /etc/ssh/sshd_config 2>/dev/null)
    if ($sshAuth) {
        foreach ($line in ($sshAuth -split $nl)) {
            $FindingDetails += "  $($line.Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No explicit MFA SSH configuration found" + $nl
    }

    # Status determination — MFA requires organizational deployment
    $Status = "Open"
    $FindingDetails += $nl + "RESULT: MFA for local access to nonprivileged accounts requires organizational deployment" + $nl
    $FindingDetails += "of smartcard/PKI (CAC/PIV), TOTP, or hardware token authentication." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203644 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203644
        STIG ID    : SRG-OS-000109-GPOS-00056
        Rule ID    : SV-203644r982205_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : b872fc215bac694c6c176b5baef971f2
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203644"
    $RuleID = "SV-203644r982205_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Shared/Group Accounts ---" + $nl
    $groupAccounts = $(timeout 5 awk -F: "(\$3 >= 1000 && \$3 < 65534)" /etc/passwd 2>&1)
    if ($groupAccounts) {
        $FindingDetails += "  User accounts (UID >= 1000):" + $nl
        foreach ($acct in ($groupAccounts -split $nl)) {
            if ($acct.Trim()) {
                $parts = $acct -split ":"
                $uname = $parts[0]
                $uid = $parts[2]
                $shell = $parts[-1]
                $FindingDetails += "    $uname (UID:$uid, Shell:$shell)" + $nl
            }
        }
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Concurrent Login Detection ---" + $nl
    $whoOutput = $(who 2>&1)
    if ($whoOutput) {
        $FindingDetails += "  Currently logged in users:" + $nl
        foreach ($line in ($whoOutput -split $nl)) {
            if ($line.Trim()) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
        # Check for same user logged in multiple times
        $userLogins = ($whoOutput -split $nl) | ForEach-Object { ($_ -split "\s+")[0] } | Where-Object { $_ }
        $dupLogins = $userLogins | Group-Object | Where-Object { $_.Count -gt 1 }
        if ($dupLogins) {
            $FindingDetails += "  [INFO] Users with multiple sessions:" + $nl
            foreach ($dup in $dupLogins) {
                $FindingDetails += "    $($dup.Name): $($dup.Count) sessions" + $nl
            }
        }
    }
    else {
        $FindingDetails += "  No users currently logged in" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: PAM Individual Authentication ---" + $nl
    $pamAuth = $(timeout 5 grep -v "^#" /etc/pam.d/common-auth 2>/dev/null)
    if ($pamAuth) {
        foreach ($line in ($pamAuth -split $nl)) {
            if ($line.Trim()) {
                $FindingDetails += "  $($line.Trim())" + $nl
            }
        }
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Sudo Configuration ---" + $nl
    $sudoGroup = $(timeout 5 grep -E "^%sudo|^%wheel|^%admin" /etc/sudoers 2>/dev/null)
    if ($sudoGroup) {
        $FindingDetails += "  Sudo group rules:" + $nl
        foreach ($line in ($sudoGroup -split $nl)) {
            $FindingDetails += "    $($line.Trim())" + $nl
        }
    }
    $sudoersD = $(timeout 10 find /etc/sudoers.d -maxdepth 1 -type f 2>/dev/null)
    if ($sudoersD) {
        $FindingDetails += "  Sudoers.d files:" + $nl
        foreach ($f in ($sudoersD -split $nl)) {
            if ($f.Trim()) { $FindingDetails += "    $f" + $nl }
        }
    }


    $FindingDetails += "--- Check 5: XO auth-ldap (AD Authentication Delegation) ---" + $nl
    $xoLdapInfo = Get-XOAuthLdapInfo
    $ldapCompensates = $false
    if ($xoLdapInfo.Enabled) {
        $FindingDetails += "  XO auth-ldap Plugin: ACTIVE" + $nl
        if ($xoLdapInfo.LdapUri) { $FindingDetails += "  LDAP Server: $($xoLdapInfo.LdapUri)" + $nl }
        if ($xoLdapInfo.BaseDN) { $FindingDetails += "  Base DN: $($xoLdapInfo.BaseDN)" + $nl }
        $FindingDetails += "  Source: $($xoLdapInfo.Details)" + $nl
        $FindingDetails += "  [PASS] AD via auth-ldap requires individual credentials; each user authenticates with unique AD account before accessing any shared resources" + $nl
        $ldapCompensates = $true
    }
    else {
        $FindingDetails += "  XO auth-ldap Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoLdapInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No AD/LDAP authentication delegation available" + $nl
    }
    $FindingDetails += $nl
    # Status determination
    if ($ldapCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "COMPENSATING CONTROL: Authentication is delegated to Active Directory" + $nl
        $FindingDetails += "via the XO auth-ldap plugin. Each user authenticates with their unique" + $nl
        $FindingDetails += "AD credentials before accessing any system resources. No shared XO" + $nl
        $FindingDetails += "passwords exist when auth-ldap is the primary authentication method." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Individual authentication before group/shared account" + $nl
        $FindingDetails += "access requires organizational policy enforcement. Verify that" + $nl
        $FindingDetails += "users authenticate with individual credentials before accessing" + $nl
        $FindingDetails += "any shared or group accounts (e.g., via sudo, su)." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203645 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203645
        STIG ID    : SRG-OS-000112-GPOS-00057
        Rule ID    : SV-203645r958494_rule
        DiscussMD5 : fb860c0bf3eff9ed9c106852d879e1db
        CheckMD5   : 3011a716d526d946ede1c6f64e9a46b3
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203645"
    $RuleID = "SV-203645r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203645: Replay-resistant authentication for network access to privileged accounts
    # SSH Kerberos/GSSAPI and challenge-response provide replay resistance via nonces/timestamps

    $FindingDetails += "--- Check 1: SSH Protocol Version ---" + $nl
    $sshVer = $(timeout 5 ssh -V 2>&1)
    $sshVerStr = ($sshVer -join $nl).Trim()
    $FindingDetails += "  SSH version: $sshVerStr" + $nl
    if ($sshVerStr -match "OpenSSH") {
        $FindingDetails += "  [PASS] OpenSSH uses SSHv2 protocol which is replay-resistant" + $nl
    }
    else {
        $FindingDetails += "  [INFO] Non-OpenSSH implementation detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Kerberos/GSSAPI Authentication ---" + $nl
    $sshdConfig = $(timeout 5 sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl).Trim()
    if ($sshdStr -match "gssapiauthentication\s+yes") {
        $FindingDetails += "  GSSAPIAuthentication: yes" + $nl
        $FindingDetails += "  [PASS] Kerberos/GSSAPI provides replay-resistant authentication" + $nl
    }
    else {
        $FindingDetails += "  GSSAPIAuthentication: no (or not configured)" + $nl
        $FindingDetails += "  [INFO] GSSAPI not enabled (SSH protocol still replay-resistant)" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: SSH Key Exchange Algorithms ---" + $nl
    if ($sshdStr -match "kexalgorithms\s+(.+)") {
        $kexAlgs = $matches[1]
        $FindingDetails += "  KexAlgorithms: $kexAlgs" + $nl
        if ($kexAlgs -match "diffie-hellman-group-exchange|ecdh-sha2|curve25519") {
            $FindingDetails += "  [PASS] Key exchange algorithms provide replay resistance via ephemeral keys" + $nl
        }
    }
    else {
        $FindingDetails += "  KexAlgorithms: (default)" + $nl
        $FindingDetails += "  [PASS] Default OpenSSH KEX algorithms are replay-resistant" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Privileged Account Access Method ---" + $nl
    $sudoUsers = $(timeout 5 grep -E "^%sudo|^%admin|^root" /etc/sudoers 2>&1)
    $sudoStr = ($sudoUsers -join $nl).Trim()
    if ($sudoStr) {
        $FindingDetails += "  Privileged access groups:" + $nl
        foreach ($line in ($sudoStr -split $nl)) {
            if ($line.Trim()) { $FindingDetails += "    $($line.Trim())" + $nl }
        }
    }
    else {
        $FindingDetails += "  No sudo rules found in /etc/sudoers" + $nl
    }
    $FindingDetails += $nl

    # SSHv2 is inherently replay-resistant (sequence numbers, MACs, session keys)
    $Status = "NotAFinding"
    $FindingDetails += "RESULT: SSHv2 protocol provides replay-resistant authentication via" + $nl
    $FindingDetails += "cryptographic session keys, sequence numbers, and MAC verification." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203646 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203646
        STIG ID    : SRG-OS-000113-GPOS-00058
        Rule ID    : SV-203646r982206_rule
        DiscussMD5 : 48af96861c9759b3a4e117f4575ac51e
        CheckMD5   : 9e45f10a2bff8fed78f1b418237f4112
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203646"
    $RuleID = "SV-203646r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203646: Replay-resistant authentication for network access to non-privileged accounts
    # Same SSH protocol protections apply to all accounts

    $FindingDetails += "--- Check 1: SSH Protocol Version ---" + $nl
    $sshVer = $(timeout 5 ssh -V 2>&1)
    $sshVerStr = ($sshVer -join $nl).Trim()
    $FindingDetails += "  SSH version: $sshVerStr" + $nl
    if ($sshVerStr -match "OpenSSH") {
        $FindingDetails += "  [PASS] OpenSSH SSHv2 is replay-resistant for all accounts" + $nl
    }
    else {
        $FindingDetails += "  [INFO] Non-OpenSSH implementation detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Authentication Methods ---" + $nl
    $sshdConfig = $(timeout 5 sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl).Trim()
    if ($sshdStr -match "passwordauthentication\s+(\w+)") {
        $FindingDetails += "  PasswordAuthentication: $($matches[1])" + $nl
    }
    if ($sshdStr -match "pubkeyauthentication\s+(\w+)") {
        $FindingDetails += "  PubkeyAuthentication: $($matches[1])" + $nl
    }
    if ($sshdStr -match "kbdinteractiveauthentication\s+(\w+)") {
        $FindingDetails += "  KbdInteractiveAuthentication: $($matches[1])" + $nl
    }
    $FindingDetails += "  [INFO] All SSH authentication methods operate within replay-resistant SSHv2 channel" + $nl
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Non-Privileged User Accounts ---" + $nl
    $nonPrivUsers = $(timeout 5 awk -F: '($3 >= 1000 && $3 < 65534) {print $1 ":" $3}' /etc/passwd 2>&1)
    $nonPrivStr = ($nonPrivUsers -join $nl).Trim()
    if ($nonPrivStr) {
        $FindingDetails += "  Non-privileged accounts (UID >= 1000):" + $nl
        foreach ($user in ($nonPrivStr -split $nl)) {
            if ($user.Trim()) { $FindingDetails += "    $($user.Trim())" + $nl }
        }
    }
    else {
        $FindingDetails += "  No non-privileged user accounts found" + $nl
    }
    $FindingDetails += $nl

    # SSHv2 is inherently replay-resistant for all account types
    $Status = "NotAFinding"
    $FindingDetails += "RESULT: SSHv2 protocol provides replay-resistant authentication for" + $nl
    $FindingDetails += "all accounts via cryptographic session keys, sequence numbers, and MACs." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203647 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203647
        STIG ID    : SRG-OS-000114-GPOS-00059
        Rule ID    : SV-203647r958498_rule
        DiscussMD5 : 97fe673dc2887cde6f087b0438aaa65c
        CheckMD5   : 652ac0af139d74cf526af338f70ec25b
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203647"
    $RuleID = "SV-203647r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203647: Uniquely identify peripherals before establishing a connection
    # Linux identifies USB/PCI devices via udev rules and kernel device enumeration

    $FindingDetails += "--- Check 1: USB Device Authorization ---" + $nl
    $usbAuth = $(timeout 5 cat /sys/bus/usb/devices/usb1/authorized_default 2>&1)
    $usbAuthStr = ("$usbAuth").Trim()
    if ($usbAuthStr -eq "1") {
        $FindingDetails += "  USB authorized_default: 1 (auto-authorize)" + $nl
        $FindingDetails += "  [INFO] USB devices are auto-authorized by default" + $nl
    }
    elseif ($usbAuthStr -eq "0") {
        $FindingDetails += "  USB authorized_default: 0 (require authorization)" + $nl
        $FindingDetails += "  [PASS] USB devices must be explicitly authorized" + $nl
    }
    else {
        $FindingDetails += "  USB authorized_default: $usbAuthStr" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Connected USB Devices ---" + $nl
    $usbDevices = $(timeout 5 lsusb 2>&1)
    $usbStr = ($usbDevices -join $nl).Trim()
    if ($usbStr) {
        $devCount = (($usbStr -split $nl) | Where-Object { $_.Trim() }).Count
        $FindingDetails += "  USB devices detected: $devCount" + $nl
        foreach ($dev in ($usbStr -split $nl)) {
            if ($dev.Trim()) { $FindingDetails += "    $($dev.Trim())" + $nl }
        }
    }
    else {
        $FindingDetails += "  No USB devices detected (or lsusb not available)" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Udev Rules for Device Identification ---" + $nl
    $udevRules = $(timeout 5 find /etc/udev/rules.d -maxdepth 1 -type f -name '*.rules' 2>/dev/null | head -10 2>&1)
    $udevStr = ($udevRules -join $nl).Trim()
    if ($udevStr) {
        $FindingDetails += "  Custom udev rules:" + $nl
        foreach ($rule in ($udevStr -split $nl)) {
            if ($rule.Trim()) { $FindingDetails += "    $($rule.Trim())" + $nl }
        }
    }
    else {
        $FindingDetails += "  No custom udev rules in /etc/udev/rules.d/" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Kernel Device Enumeration ---" + $nl
    $pciDevices = $(timeout 5 lspci 2>&1 | head -5 2>&1)
    $pciStr = ($pciDevices -join $nl).Trim()
    if ($pciStr) {
        $FindingDetails += "  PCI devices (first 5):" + $nl
        foreach ($dev in ($pciStr -split $nl)) {
            if ($dev.Trim()) { $FindingDetails += "    $($dev.Trim())" + $nl }
        }
    }
    $FindingDetails += $nl

    # Linux kernel uniquely identifies all devices via bus/device/function addressing
    $Status = "NotAFinding"
    $FindingDetails += "RESULT: Linux kernel uniquely identifies peripherals via bus enumeration" + $nl
    $FindingDetails += "(USB bus/device IDs, PCI bus/slot/function) and udev device management." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203648 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203648
        STIG ID    : SRG-OS-000118-GPOS-00060
        Rule ID    : SV-203648r982189_rule
        Rule Title : The operating system must disable account identifiers (individuals, groups, roles, and devices) after 35 days of inactivity.
        DiscussMD5 : 702b0c109f871d307060ec75df670fdb
        CheckMD5   : 5cb5e063a7c05fd3f2d3c5b0db00a189
        FixMD5     : ffc4b94bc49a7086efdf35bdcc8b5102
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203648"
    $RuleID = "SV-203648r982189_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: INACTIVE setting in /etc/default/useradd
    $output += "Check 1: Default INACTIVE Setting${nl}"
    try {
        $useraddDefaults = $(timeout 5 cat /etc/default/useradd 2>&1)
        $useraddStr = ($useraddDefaults -join $nl).Trim()
        if ($useraddStr -match "(?m)^INACTIVE=(-?\d+)") {
            $inactiveVal = [int]$matches[1]
            $output += "  INACTIVE=$inactiveVal${nl}"
            if ($inactiveVal -ge 0 -and $inactiveVal -le 35) {
                $output += "  [PASS] Accounts disabled after $inactiveVal days of inactivity (meets 35-day requirement)${nl}"
            }
            elseif ($inactiveVal -eq -1) {
                $output += "  [FAIL] INACTIVE=-1 means accounts are never disabled for inactivity${nl}"
            }
            else {
                $output += "  [FAIL] INACTIVE=$inactiveVal exceeds 35-day DoD requirement${nl}"
            }
        }
        else {
            $output += "  [FAIL] INACTIVE not configured in /etc/default/useradd${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Per-user INACTIVE values in /etc/shadow
    $output += "Check 2: Per-User Inactivity Settings (/etc/shadow)${nl}"
    try {
        $shadowContent = $(timeout 5 cat /etc/shadow 2>&1)
        $shadowStr = ($shadowContent -join $nl).Trim()
        $systemAccts = @("root", "daemon", "bin", "sys", "sync", "games", "man", "lp", "mail", "news", "uucp", "proxy", "www-data", "backup", "list", "irc", "gnats", "nobody", "systemd-network", "systemd-resolve", "messagebus", "sshd", "_apt", "systemd-timesync")
        $nonCompliant = @()

        foreach ($line in ($shadowStr -split $nl)) {
            if ($line -match "^([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):") {
                $acctName = $matches[1]
                $hashField = $matches[2]
                $inactiveField = $matches[7]

                if ($acctName -in $systemAccts) { continue }
                if ($hashField -match "^[!*]") { continue }

                if ($inactiveField -and $inactiveField -match "^\d+$") {
                    $inactDays = [int]$inactiveField
                    if ($inactDays -le 35) {
                        $output += "  $acctName : INACTIVE=$inactDays [PASS]${nl}"
                    }
                    else {
                        $output += "  $acctName : INACTIVE=$inactDays [FAIL - exceeds 35 days]${nl}"
                        $nonCompliant += $acctName
                    }
                }
                else {
                    $output += "  $acctName : INACTIVE=not set [FAIL]${nl}"
                    $nonCompliant += $acctName
                }
            }
        }
        if ($nonCompliant.Count -eq 0) {
            $output += "  [PASS] All interactive accounts have INACTIVE <= 35 days${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: login.defs INACTIVE
    $output += "Check 3: login.defs Configuration${nl}"
    try {
        $loginDefs = $(timeout 5 cat /etc/login.defs 2>&1)
        $loginStr = ($loginDefs -join $nl).Trim()
        if ($loginStr -match "(?m)^INACTIVE\s+(-?\d+)") {
            $loginInactive = [int]$matches[1]
            $output += "  login.defs INACTIVE=$loginInactive${nl}"
        }
        else {
            $output += "  [INFO] INACTIVE not set in /etc/login.defs${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($useraddStr -match "(?m)^INACTIVE=(\d+)" -and [int]$matches[1] -le 35 -and $nonCompliant.Count -eq 0) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203649 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203649
        STIG ID    : SRG-OS-000120-GPOS-00061
        Rule ID    : SV-203649r971535_rule
        Rule Title : Use mechanisms meeting applicable federal laws for crypto module auth
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : bb149895d772a57351acd22ac7bf0a34
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203649"
    $RuleID = "SV-203649r971535_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: OpenSSL FIPS mode
    $output += "Check 1: OpenSSL FIPS Mode${nl}"
    try {
        $fipsEnabled = $(timeout 5 cat /proc/sys/crypto/fips_enabled 2>/dev/null)
        $fipsStr = ($fipsEnabled -join " ").Trim()
        if ($fipsStr -eq "1") {
            $output += "  FIPS mode: ENABLED${nl}"
            $output += "  [PASS] Kernel FIPS mode is active${nl}"
        }
        else {
            $output += "  FIPS mode: NOT ENABLED (value: $fipsStr)${nl}"
            $output += "  [FAIL] Kernel FIPS mode is not active${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: OpenSSL version and FIPS provider
    $output += "Check 2: OpenSSL Version${nl}"
    try {
        $opensslVer = $(timeout 5 openssl version 2>&1)
        $opensslStr = ($opensslVer -join " ").Trim()
        $output += "  $opensslStr${nl}"
        $fipsProv = $(timeout 5 openssl list -providers 2>/dev/null)
        $fipsProvStr = ($fipsProv -join $nl).Trim()
        if ($fipsProvStr -match "fips") {
            $output += "  [PASS] FIPS provider available${nl}"
        }
        else {
            $output += "  [INFO] FIPS provider not detected in OpenSSL${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: libgcrypt FIPS mode
    $output += "Check 3: libgcrypt FIPS Configuration${nl}"
    try {
        $gcryptPkg = $(timeout 5 dpkg -l libgcrypt20 2>/dev/null | grep "^ii")
        $gcryptStr = ($gcryptPkg -join $nl).Trim()
        if ($gcryptStr) {
            $output += "  $gcryptStr${nl}"
            $output += "  [PASS] libgcrypt20 installed${nl}"
        }
        else {
            $output += "  [FAIL] libgcrypt20 not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: PAM crypto modules
    $output += "Check 4: PAM Cryptographic Modules${nl}"
    try {
        $pamCrypto = $(timeout 5 sh -c "grep -r 'pam_unix\|pam_sssd\|pam_ldap' /etc/pam.d/common-auth 2>/dev/null" 2>&1)
        $pamStr = ($pamCrypto -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] PAM authentication modules configured${nl}"
        }
        else {
            $output += "  [FAIL] No PAM authentication modules found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 5: SSH crypto configuration
    $output += "Check 5: SSH Cryptographic Algorithms${nl}"
    try {
        $sshCiphers = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i ciphers" 2>&1)
        $sshStr = ($sshCiphers -join $nl).Trim()
        if ($sshStr) {
            $output += "  $sshStr${nl}"
            if ($sshStr -match "aes(128|256)-(ctr|gcm)") {
                $output += "  [PASS] FIPS-approved ciphers in use${nl}"
            }
            else {
                $output += "  [FAIL] Non-FIPS ciphers detected${nl}"
            }
        }
        else {
            $output += "  [INFO] Unable to query SSH daemon configuration${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($fipsStr -eq "1") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203650 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203650
        STIG ID    : SRG-OS-000121-GPOS-00062
        Rule ID    : SV-203650r958504_rule
        DiscussMD5 : 9b698b8f46d717b0b729c7acfaab8015
        CheckMD5   : e28f580ded36384a9fb34475a60e9321
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203650"
    $RuleID = "SV-203650r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203650: Uniquely identify and authenticate non-organizational users
    # All users must have unique accounts - no shared/generic accounts

    $FindingDetails += "--- Check 1: User Account Uniqueness ---" + $nl
    $allUsers = $(timeout 5 awk -F: '{print $1 ":" $3}' /etc/passwd 2>&1)
    $allUsersStr = ($allUsers -join $nl).Trim()
    $dupUIDs = $(timeout 5 awk -F: '{print $3}' /etc/passwd 2>&1 | sort 2>&1 | uniq -d 2>&1)
    $dupUIDStr = ($dupUIDs -join $nl).Trim()
    if ($dupUIDStr) {
        $FindingDetails += "  [FAIL] Duplicate UIDs detected:" + $nl
        foreach ($uid in ($dupUIDStr -split $nl)) {
            if ($uid.Trim()) { $FindingDetails += "    UID: $($uid.Trim())" + $nl }
        }
        $dupsFound = $true
    }
    else {
        $FindingDetails += "  [PASS] No duplicate UIDs found" + $nl
        $dupsFound = $false
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Generic/Shared Account Detection ---" + $nl
    $genericAccounts = $(timeout 5 awk -F: '($3 >= 1000 && $3 < 65534) {print $1}' /etc/passwd 2>&1)
    $genericStr = ($genericAccounts -join $nl).Trim()
    $genericFound = $false
    $genericPatterns = @("guest", "shared", "generic", "temp", "test", "demo", "anonymous")
    if ($genericStr) {
        foreach ($acct in ($genericStr -split $nl)) {
            $acctName = $acct.Trim().ToLower()
            foreach ($pattern in $genericPatterns) {
                if ($acctName -match $pattern) {
                    $FindingDetails += "  [WARN] Potential shared/generic account: $($acct.Trim())" + $nl
                    $genericFound = $true
                }
            }
        }
    }
    if (-not $genericFound) {
        $FindingDetails += "  [PASS] No generic/shared accounts detected" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: SSH Authentication Requirements ---" + $nl
    $sshdConfig = $(timeout 5 sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl).Trim()
    if ($sshdStr -match "permitrootlogin\s+(\w+)") {
        $FindingDetails += "  PermitRootLogin: $($matches[1])" + $nl
    }
    if ($sshdStr -match "passwordauthentication\s+(\w+)") {
        $FindingDetails += "  PasswordAuthentication: $($matches[1])" + $nl
    }
    if ($sshdStr -match "permitemptypasswords\s+(\w+)") {
        $FindingDetails += "  PermitEmptyPasswords: $($matches[1])" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: PAM Authentication Stack ---" + $nl
    $pamAuth = $(timeout 5 cat /etc/pam.d/common-auth 2>&1)
    $pamStr = ($pamAuth -join $nl).Trim()
    if ($pamStr -match "pam_unix") {
        $FindingDetails += "  [PASS] PAM unix authentication module loaded" + $nl
    }
    else {
        $FindingDetails += "  [INFO] PAM common-auth configuration:" + $nl
        $FindingDetails += "  $pamStr" + $nl
    }
    $FindingDetails += $nl

    if ($dupsFound -or $genericFound) {
        $Status = "Open"
        $FindingDetails += "RESULT: Issues detected with user account uniqueness." + $nl
    }
    else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: All user accounts are unique with individual authentication." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203651 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203651
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203651r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203651"
    $RuleID = "SV-203651r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203651) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203652 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203652
        STIG ID    : SRG-OS-000123-GPOS-00064
        Rule ID    : SV-203652r958508_rule
        Rule Title : The information system must automatically remove or disable emergency accounts after the crisis is resolved or 72 hours.
        DiscussMD5 : d7539b4d44342a1f1fc76e1e9154df5b
        CheckMD5   : ea94c39bef68f27d8893d026ca387adb
        FixMD5     : ef0bfbcbd07135ac0723add81ffc907a
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203652"
    $RuleID = "SV-203652r958508_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Identify accounts with near-term expiration (emergency/temp)
    $output += "Check 1: Accounts with Expiration Dates${nl}"
    try {
        $shadowContent = $(timeout 5 cat /etc/shadow 2>&1)
        $shadowStr = ($shadowContent -join $nl).Trim()
        $systemAccts = @("root", "daemon", "bin", "sys", "sync", "games", "man", "lp", "mail", "news", "uucp", "proxy", "www-data", "backup", "list", "irc", "gnats", "nobody", "systemd-network", "systemd-resolve", "messagebus", "sshd", "_apt", "systemd-timesync")
        $acctWithExpiry = @()
        $acctNoExpiry = @()

        foreach ($line in ($shadowStr -split $nl)) {
            if ($line -match "^([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):") {
                $acctName = $matches[1]
                $hashField = $matches[2]
                $expireField = $matches[8]

                if ($acctName -in $systemAccts) { continue }
                if ($hashField -match "^[!*]") { continue }

                if ($expireField -and $expireField -match "^\d+$") {
                    $expireDays = [int]$expireField
                    $expireDate = (Get-Date "1970-01-01").AddDays($expireDays)
                    $daysUntil = ($expireDate - (Get-Date)).Days
                    $output += "  $acctName : expires $($expireDate.ToString('yyyy-MM-dd')) ($daysUntil days from now)${nl}"
                    $acctWithExpiry += $acctName
                }
                else {
                    $acctNoExpiry += $acctName
                    $output += "  $acctName : no expiration set${nl}"
                }
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Automated account cleanup mechanism
    $output += "Check 2: Automated Emergency Account Cleanup${nl}"
    try {
        $cronCheck = $(timeout 10 grep -r "userdel\|usermod.*--expiredate\|chage.*-E" /etc/cron.d/ /etc/cron.daily/ /etc/cron.hourly/ 2>&1)
        $cronStr = ($cronCheck -join $nl).Trim()
        if ($cronStr -and $cronStr -notmatch "No such file") {
            $output += "  [PASS] Automated account cleanup cron jobs found${nl}"
            foreach ($line in ($cronStr -split $nl | Select-Object -First 3)) {
                $output += "    $line${nl}"
            }
        }
        else {
            $output += "  [INFO] No automated cleanup cron jobs found${nl}"
        }

        # Check systemd timers
        $timerCheck = $(timeout 5 systemctl list-timers --all 2>&1)
        $timerStr = ($timerCheck -join $nl).Trim()
        if ($timerStr -match "account.*clean|emergency.*expire|temp.*account") {
            $output += "  [PASS] Account cleanup systemd timer detected${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Emergency account documentation
    $output += "Check 3: Emergency Account Policy${nl}"
    $output += "  [INFO] Verify organizational procedures require:${nl}"
    $output += "    - Emergency accounts have expiration date within 72 hours of creation${nl}"
    $output += "    - Automated mechanism to disable/remove after crisis resolved${nl}"
    $output += "    - Documentation of emergency account creation/removal events${nl}"

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203653 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203653
        STIG ID    : SRG-OS-000125-GPOS-00065
        Rule ID    : SV-203653r958510_rule
        Rule Title : The operating system must employ strong authenticators in the establishment of nonlocal maintenance and diagnostic sessions.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203653"
    $RuleID = "SV-203653r958510_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203653 - Strong Authenticators for Nonlocal Maintenance Sessions" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: SSH public key authentication enabled
    $FindingDetails += "Check 1: SSH Public Key Authentication" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    $pubkeyEnabled = $false
    if ($sshdStr -match "(?m)^pubkeyauthentication\s+(\S+)") {
        $pubkeyVal = $matches[1].Trim()
        $FindingDetails += "PubkeyAuthentication: " + $pubkeyVal + $nl
        if ($pubkeyVal -eq "yes") {
            $pubkeyEnabled = $true
            $FindingDetails += "  PASS: Public key authentication is enabled" + $nl
        } else {
            $FindingDetails += "  FAIL: Public key authentication is disabled" + $nl
        }
    } else {
        $FindingDetails += "PubkeyAuthentication: not set (default: yes)" + $nl
        $pubkeyEnabled = $true
    }

    $FindingDetails += $nl

    # Check 2: Password-only authentication should be restricted
    $FindingDetails += "Check 2: Password Authentication Status" + $nl
    $FindingDetails += ("-" * 40) + $nl

    if ($sshdStr -match "(?m)^passwordauthentication\s+(\S+)") {
        $pwAuth = $matches[1].Trim()
        $FindingDetails += "PasswordAuthentication: " + $pwAuth + $nl
    }

    if ($sshdStr -match "(?m)^kbdinteractiveauthentication\s+(\S+)") {
        $kbdAuth = $matches[1].Trim()
        $FindingDetails += "KbdInteractiveAuthentication: " + $kbdAuth + $nl
    }

    $FindingDetails += $nl

    # Check 3: Root login restrictions
    $FindingDetails += "Check 3: Root Login Restrictions" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $rootRestricted = $false
    if ($sshdStr -match "(?m)^permitrootlogin\s+(\S+)") {
        $rootLogin = $matches[1].Trim()
        $FindingDetails += "PermitRootLogin: " + $rootLogin + $nl
        if ($rootLogin -eq "prohibit-password" -or $rootLogin -eq "forced-commands-only" -or $rootLogin -eq "no") {
            $rootRestricted = $true
            $FindingDetails += "  PASS: Root password login is restricted" + $nl
        } else {
            $FindingDetails += "  INFO: Root login with password is allowed" + $nl
        }
    }

    $FindingDetails += $nl

    # Check 4: Authorized keys exist for maintenance users
    $FindingDetails += "Check 4: SSH Authorized Keys" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $authKeysFound = $false
    $rootAuthKeys = "/root/.ssh/authorized_keys"
    if (Test-Path $rootAuthKeys) {
        $keyCount = (Get-Content $rootAuthKeys -ErrorAction SilentlyContinue | Where-Object { $_ -match "^ssh-" }).Count
        $FindingDetails += "Root authorized_keys: " + $keyCount + " key(s)" + $nl
        if ($keyCount -gt 0) { $authKeysFound = $true }
    } else {
        $FindingDetails += "Root authorized_keys: Not found" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($pubkeyEnabled -and ($authKeysFound -or $rootRestricted)) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Strong authenticators (public key) are employed for nonlocal maintenance" + $nl
    } else {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Strong authenticators not fully configured for nonlocal maintenance sessions" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203655 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203655
        STIG ID    : SRG-OS-000132-GPOS-00067
        Rule ID    : SV-203655r958514_rule
        DiscussMD5 : 31ace61573e2031c4d651c7586a437c1
        CheckMD5   : c4d23394505cdf2b71582a0adab0e349
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203655"
    $RuleID = "SV-203655r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203655: Separate user functionality from OS management functionality
    # Regular users should not have access to admin tools/directories

    $FindingDetails += "--- Check 1: Administrative Tool Access ---" + $nl
    $sbinPerms = $(timeout 5 stat -c '%a %U:%G' /usr/sbin 2>&1)
    $sbinStr = ("$sbinPerms").Trim()
    $FindingDetails += "  /usr/sbin permissions: $sbinStr" + $nl
    $adminBins = @("/usr/sbin/useradd", "/usr/sbin/userdel", "/usr/sbin/usermod", "/usr/sbin/visudo")
    foreach ($bin in $adminBins) {
        $binPerms = $(timeout 5 stat -c '%a %U:%G' $bin 2>&1)
        $binStr = ("$binPerms").Trim()
        if ($binStr -match "^\d") {
            $FindingDetails += "  $bin : $binStr" + $nl
        }
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Sudo Configuration ---" + $nl
    $sudoInstalled = $(timeout 5 dpkg -l sudo 2>&1)
    $sudoStr = ($sudoInstalled -join $nl).Trim()
    if ($sudoStr -match "^ii\s+sudo") {
        $FindingDetails += "  sudo: installed" + $nl
        $sudoGroup = $(timeout 5 grep "^%sudo" /etc/sudoers 2>&1)
        $sudoGrpStr = ($sudoGroup -join $nl).Trim()
        if ($sudoGrpStr) {
            $FindingDetails += "  sudo group rule: $sudoGrpStr" + $nl
        }
        $sudoMembers = $(timeout 5 getent group sudo 2>&1)
        $FindingDetails += "  sudo group members: $($sudoMembers -join $nl)" + $nl
        $FindingDetails += "  [PASS] Administrative access restricted via sudo" + $nl
    }
    else {
        $FindingDetails += "  sudo: NOT installed" + $nl
        $FindingDetails += "  [FAIL] No privilege separation mechanism" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: User Shell Restrictions ---" + $nl
    $nologinUsers = $(timeout 5 grep -c "/usr/sbin/nologin\|/bin/false" /etc/passwd 2>&1)
    $totalUsers = $(timeout 5 grep -c "^" /etc/passwd 2>&1)
    $FindingDetails += "  Total accounts: $totalUsers" + $nl
    $FindingDetails += "  Accounts with nologin/false shell: $nologinUsers" + $nl
    $loginUsers = $(timeout 5 awk -F: '($7 !~ /nologin|false/ && $3 >= 1000) {print $1}' /etc/passwd 2>&1)
    $loginStr = ($loginUsers -join $nl).Trim()
    if ($loginStr) {
        $FindingDetails += "  Interactive login accounts (UID >= 1000):" + $nl
        foreach ($user in ($loginStr -split $nl)) {
            if ($user.Trim()) { $FindingDetails += "    $($user.Trim())" + $nl }
        }
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Separate Namespaces ---" + $nl
    $nsSupport = $(timeout 5 ls /proc/self/ns/ 2>&1)
    $nsStr = ($nsSupport -join $nl).Trim()
    if ($nsStr -match "user|mnt|pid") {
        $FindingDetails += "  Linux namespace support: available (user, mnt, pid)" + $nl
        $FindingDetails += "  [PASS] Kernel supports namespace-based separation" + $nl
    }
    $FindingDetails += $nl

    if ($sudoStr -match "^ii\s+sudo") {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: User functionality separated from OS management via sudo," + $nl
        $FindingDetails += "restricted shells for service accounts, and file permission controls." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += "RESULT: No privilege separation mechanism detected." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203656 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203656
        STIG ID    : SRG-OS-000134-GPOS-00068
        Rule ID    : SV-203656r958518_rule
        DiscussMD5 : ad6bc360b259a47eddc4cb27cdb650ed
        CheckMD5   : b89ca55534166d6a11cc775662024de4
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203656"
    $RuleID = "SV-203656r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203656: Isolate security functions from nonsecurity functions
    # Kernel enforces process isolation, SELinux/AppArmor provide MAC

    $FindingDetails += "--- Check 1: AppArmor Status ---" + $nl
    $aaStatus = $(timeout 5 aa-status 2>&1)
    $aaStr = ($aaStatus -join $nl).Trim()
    if ($aaStr -match "(\d+) profiles are loaded") {
        $profileCount = $matches[1]
        $FindingDetails += "  AppArmor: active ($profileCount profiles loaded)" + $nl
        if ($aaStr -match "(\d+) profiles are in enforce mode") {
            $FindingDetails += "  Enforce mode: $($matches[1]) profiles" + $nl
        }
        if ($aaStr -match "(\d+) profiles are in complain mode") {
            $FindingDetails += "  Complain mode: $($matches[1]) profiles" + $nl
        }
        $FindingDetails += "  [PASS] AppArmor provides mandatory access control" + $nl
        $macActive = $true
    }
    else {
        $FindingDetails += "  AppArmor: not active or not installed" + $nl
        $macActive = $false
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Kernel Security Modules ---" + $nl
    $lsm = $(timeout 5 cat /sys/kernel/security/lsm 2>&1)
    $lsmStr = ("$lsm").Trim()
    $FindingDetails += "  Loaded LSMs: $lsmStr" + $nl
    if ($lsmStr -match "apparmor|selinux|tomoyo") {
        $FindingDetails += "  [PASS] MAC security module active in kernel" + $nl
        $macActive = $true
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Process Isolation ---" + $nl
    $procHide = $(timeout 5 cat /proc/sys/kernel/hidepid 2>&1)
    $procHideStr = ("$procHide").Trim()
    $FindingDetails += "  hidepid: $procHideStr" + $nl
    if ($procHideStr -eq "0") {
        $FindingDetails += "  [INFO] All users can see all processes (default)" + $nl
    }
    elseif ($procHideStr -match "1|2") {
        $FindingDetails += "  [PASS] Process visibility restricted" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Address Space Isolation ---" + $nl
    $aslr = $(timeout 5 cat /proc/sys/kernel/randomize_va_space 2>&1)
    $aslrStr = ("$aslr").Trim()
    $FindingDetails += "  ASLR (randomize_va_space): $aslrStr" + $nl
    if ($aslrStr -eq "2") {
        $FindingDetails += "  [PASS] Full ASLR enabled (stack, heap, mmap, VDSO)" + $nl
    }
    elseif ($aslrStr -eq "1") {
        $FindingDetails += "  [INFO] Partial ASLR enabled (stack, mmap, VDSO only)" + $nl
    }
    else {
        $FindingDetails += "  [FAIL] ASLR disabled" + $nl
    }
    $FindingDetails += $nl

    if ($macActive) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: Security functions isolated via kernel LSM (AppArmor)," + $nl
        $FindingDetails += "process isolation, and address space randomization." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += "RESULT: No mandatory access control (AppArmor/SELinux) detected." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203657 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203657
        STIG ID    : SRG-OS-000138-GPOS-00069
        Rule ID    : SV-203657r958524_rule
        Rule Title : Prevent unauthorized info transfer via shared system resources
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 84c677a60d23492ea6f4920fd90f260e
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203657"
    $RuleID = "SV-203657r958524_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: /proc/sys/fs/protected_hardlinks and protected_symlinks
    $output += "Check 1: Protected Hardlinks and Symlinks${nl}"
    try {
        $hardlinks = $(timeout 5 cat /proc/sys/fs/protected_hardlinks 2>/dev/null)
        $hardStr = ($hardlinks -join " ").Trim()
        $symlinks = $(timeout 5 cat /proc/sys/fs/protected_symlinks 2>/dev/null)
        $symStr = ($symlinks -join " ").Trim()
        $output += "  protected_hardlinks = $hardStr${nl}"
        $output += "  protected_symlinks = $symStr${nl}"
        if ($hardStr -eq "1" -and $symStr -eq "1") {
            $output += "  [PASS] Hardlink and symlink protections enabled${nl}"
        }
        else {
            $output += "  [FAIL] Hardlink/symlink protections not fully enabled${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: /tmp mount with noexec,nosuid,nodev
    $output += "Check 2: /tmp Mount Options${nl}"
    try {
        $tmpMount = $(timeout 5 sh -c "findmnt -n -o OPTIONS /tmp 2>/dev/null" 2>&1)
        $tmpStr = ($tmpMount -join " ").Trim()
        if ($tmpStr) {
            $output += "  /tmp options: $tmpStr${nl}"
            $tmpIssues = 0
            if ($tmpStr -notmatch "nosuid") { $output += "  [FAIL] nosuid not set on /tmp${nl}"; $tmpIssues++ }
            if ($tmpStr -notmatch "nodev") { $output += "  [FAIL] nodev not set on /tmp${nl}"; $tmpIssues++ }
            if ($tmpStr -notmatch "noexec") { $output += "  [FAIL] noexec not set on /tmp${nl}"; $tmpIssues++ }
            if ($tmpIssues -eq 0) {
                $output += "  [PASS] /tmp mounted with nosuid, nodev, noexec${nl}"
            }
        }
        else {
            $output += "  [INFO] /tmp not mounted as separate filesystem${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: /dev/shm mount options
    $output += "Check 3: /dev/shm Mount Options${nl}"
    try {
        $shmMount = $(timeout 5 sh -c "findmnt -n -o OPTIONS /dev/shm 2>/dev/null" 2>&1)
        $shmStr = ($shmMount -join " ").Trim()
        if ($shmStr) {
            $output += "  /dev/shm options: $shmStr${nl}"
            $shmIssues = 0
            if ($shmStr -notmatch "nosuid") { $output += "  [FAIL] nosuid not set on /dev/shm${nl}"; $shmIssues++ }
            if ($shmStr -notmatch "nodev") { $output += "  [FAIL] nodev not set on /dev/shm${nl}"; $shmIssues++ }
            if ($shmStr -notmatch "noexec") { $output += "  [FAIL] noexec not set on /dev/shm${nl}"; $shmIssues++ }
            if ($shmIssues -eq 0) {
                $output += "  [PASS] /dev/shm mounted with nosuid, nodev, noexec${nl}"
            }
        }
        else {
            $output += "  [INFO] /dev/shm not mounted${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: Core dump restrictions
    $output += "Check 4: Core Dump Restrictions${nl}"
    try {
        $coreLimits = $(timeout 5 sh -c "grep -v '^#' /etc/security/limits.conf 2>/dev/null | grep core" 2>&1)
        $coreStr = ($coreLimits -join $nl).Trim()
        $sysCore = $(timeout 5 cat /proc/sys/kernel/core_pattern 2>/dev/null)
        $sysCoreStr = ($sysCore -join " ").Trim()
        $output += "  core_pattern: $sysCoreStr${nl}"
        if ($coreStr) {
            $output += "  limits.conf: $coreStr${nl}"
        }
        $fsProtect = $(timeout 5 cat /proc/sys/fs/suid_dumpable 2>/dev/null)
        $fsProtStr = ($fsProtect -join " ").Trim()
        $output += "  suid_dumpable: $fsProtStr${nl}"
        if ($fsProtStr -eq "0") {
            $output += "  [PASS] SUID core dumps disabled${nl}"
        }
        else {
            $output += "  [FAIL] SUID core dumps not fully restricted (should be 0)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($hardStr -eq "1" -and $symStr -eq "1" -and $fsProtStr -eq "0") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203658 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203658
        STIG ID    : SRG-OS-000142-GPOS-00071
        Rule ID    : SV-203658r958528_rule
        Rule Title : Manage excess capacity/bandwidth to limit DoS effects
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : d0b1a712f58767e5bd524ea41d4178d6
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203658"
    $RuleID = "SV-203658r958528_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Firewall rate limiting (UFW/nftables/iptables)
    $output += "Check 1: Firewall Rate Limiting${nl}"
    try {
        $fwStatus = Get-FirewallStatus
        if ($fwStatus.Active) {
            $output += "  Firewall: $($fwStatus.Type) ACTIVE${nl}"
            if ($fwStatus.Type -eq "UFW") {
                $ufwRules = $(timeout 5 sh -c "ufw status verbose 2>/dev/null | grep -i 'limit\|rate'" 2>&1)
                $ufwStr = ($ufwRules -join $nl).Trim()
                if ($ufwStr) {
                    $output += "  Rate limiting rules found:${nl}  $ufwStr${nl}"
                    $output += "  [PASS] UFW rate limiting configured${nl}"
                }
                else {
                    $output += "  [INFO] No explicit rate limiting rules in UFW${nl}"
                }
            }
        }
        else {
            $output += "  [FAIL] No active firewall detected${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: TCP SYN flood protection
    $output += "Check 2: TCP SYN Flood Protection${nl}"
    try {
        $syncookies = $(timeout 5 cat /proc/sys/net/ipv4/tcp_syncookies 2>/dev/null)
        $syncStr = ($syncookies -join " ").Trim()
        $output += "  tcp_syncookies = $syncStr${nl}"
        if ($syncStr -eq "1") {
            $output += "  [PASS] SYN cookies enabled${nl}"
        }
        else {
            $output += "  [FAIL] SYN cookies not enabled${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Connection tracking limits
    $output += "Check 3: Connection Tracking${nl}"
    try {
        $connMax = $(timeout 5 cat /proc/sys/net/netfilter/nf_conntrack_max 2>/dev/null)
        $connStr = ($connMax -join " ").Trim()
        if ($connStr) {
            $output += "  nf_conntrack_max = $connStr${nl}"
            $output += "  [PASS] Connection tracking configured${nl}"
        }
        else {
            $output += "  [INFO] Connection tracking not available (nf_conntrack module may not be loaded)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: Resource limits (ulimits)
    $output += "Check 4: System Resource Limits${nl}"
    try {
        $limitsConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/limits.conf 2>/dev/null | grep -v '^\s*$'" 2>&1)
        $limitsStr = ($limitsConf -join $nl).Trim()
        if ($limitsStr) {
            $output += "  Custom limits configured:${nl}"
            foreach ($line in ($limitsStr -split $nl)) {
                $output += "    $line${nl}"
            }
            $output += "  [PASS] Resource limits defined${nl}"
        }
        else {
            $output += "  [INFO] No custom resource limits in limits.conf${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($syncStr -eq "1") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203659 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203659
        STIG ID    : SRG-OS-000163-GPOS-00072
        Rule ID    : SV-203659r970703_rule
        Rule Title : Terminate network connections at end of session or after inactivity timeout
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 65f1666297979185d6dfd73b793c34c6
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203659"
    $RuleID = "SV-203659r970703_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: SSH ClientAliveInterval and ClientAliveCountMax
    $output += "Check 1: SSH Session Timeout Configuration${nl}"
    try {
        $sshInterval = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i clientaliveinterval" 2>&1)
        $sshIntervalStr = ($sshInterval -join " ").Trim()
        $sshCount = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i clientalivecountmax" 2>&1)
        $sshCountStr = ($sshCount -join " ").Trim()
        $output += "  $sshIntervalStr${nl}"
        $output += "  $sshCountStr${nl}"
        $intervalOk = $false
        if ($sshIntervalStr -match "clientaliveinterval\s+(\d+)") {
            $intervalVal = [int]$Matches[1]
            if ($intervalVal -gt 0 -and $intervalVal -le 600) {
                $output += "  [PASS] ClientAliveInterval ($intervalVal seconds) within 10-minute limit${nl}"
                $intervalOk = $true
            }
            else {
                $output += "  [FAIL] ClientAliveInterval ($intervalVal) exceeds 600-second maximum${nl}"
            }
        }
        else {
            $output += "  [FAIL] ClientAliveInterval not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: TMOUT shell variable
    $output += "Check 2: Shell Inactivity Timeout (TMOUT)${nl}"
    try {
        $tmout = $(timeout 5 sh -c "grep -r 'TMOUT' /etc/profile /etc/profile.d/ /etc/bash.bashrc 2>/dev/null | grep -v '^#'" 2>&1)
        $tmoutStr = ($tmout -join $nl).Trim()
        if ($tmoutStr) {
            $output += "  $tmoutStr${nl}"
            if ($tmoutStr -match "TMOUT=(\d+)") {
                $tmoutVal = [int]$Matches[1]
                if ($tmoutVal -le 900) {
                    $output += "  [PASS] TMOUT=$tmoutVal (within 15-minute limit)${nl}"
                }
                else {
                    $output += "  [FAIL] TMOUT=$tmoutVal exceeds 900-second maximum${nl}"
                }
            }
        }
        else {
            $output += "  [FAIL] TMOUT not configured in login profiles${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: systemd-logind InactivityTimeout
    $output += "Check 3: systemd-logind Session Configuration${nl}"
    try {
        $logindConf = $(timeout 5 sh -c "grep -v '^#' /etc/systemd/logind.conf 2>/dev/null | grep -i 'IdleAction\|StopIdleSessionSec\|KillUserProcesses'" 2>&1)
        $logindStr = ($logindConf -join $nl).Trim()
        if ($logindStr) {
            $output += "  $logindStr${nl}"
            $output += "  [PASS] systemd-logind session management configured${nl}"
        }
        else {
            $output += "  [INFO] No custom systemd-logind idle settings${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: XO session timeout (if applicable)
    $output += "Check 4: XO Application Session Timeout${nl}"
    try {
        $xoConf = $(timeout 5 sh -c "grep -ri 'session\|timeout\|maxAge\|idle' /etc/xo-server/config.toml /opt/xo/xo-server/.xo-server.yaml 2>/dev/null | grep -v '^#'" 2>&1)
        $xoStr = ($xoConf -join $nl).Trim()
        if ($xoStr) {
            $output += "  $xoStr${nl}"
            $output += "  [INFO] XO session configuration found${nl}"
        }
        else {
            $output += "  [INFO] No explicit XO session timeout configuration${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($intervalOk) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203660 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203660
        STIG ID    : SRG-OS-000184-GPOS-00078
        Rule ID    : SV-203660r958550_rule
        Rule Title : Fail to a secure state if system initialization fails
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 273055e926fecb0033cf40a05d8b4702
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203660"
    $RuleID = "SV-203660r958550_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: systemd default target
    $output += "Check 1: Default Boot Target${nl}"
    try {
        $defaultTarget = $(timeout 5 systemctl get-default 2>&1)
        $targetStr = ($defaultTarget -join " ").Trim()
        $output += "  Default target: $targetStr${nl}"
        if ($targetStr -eq "multi-user.target") {
            $output += "  [PASS] System boots to multi-user (no GUI) — secure default${nl}"
        }
        elseif ($targetStr -eq "graphical.target") {
            $output += "  [INFO] System boots to graphical target${nl}"
        }
        else {
            $output += "  [INFO] Non-standard default target${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Emergency/rescue mode requires root authentication
    $output += "Check 2: Emergency/Rescue Mode Authentication${nl}"
    try {
        $suloginCheck = $(timeout 5 sh -c "grep -r 'sulogin\|ExecStart.*-sulogin' /usr/lib/systemd/system/emergency.service /usr/lib/systemd/system/rescue.service 2>/dev/null" 2>&1)
        $suloginStr = ($suloginCheck -join $nl).Trim()
        if ($suloginStr -match "sulogin") {
            $output += "  $suloginStr${nl}"
            $output += "  [PASS] Emergency/rescue modes require root authentication (sulogin)${nl}"
        }
        else {
            $output += "  [FAIL] sulogin not configured for emergency/rescue modes${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Ctrl-Alt-Delete reboot disabled
    $output += "Check 3: Ctrl-Alt-Delete Reboot${nl}"
    try {
        $ctrlAlt = $(timeout 5 systemctl is-masked ctrl-alt-del.target 2>&1)
        $ctrlStr = ($ctrlAlt -join " ").Trim()
        $output += "  ctrl-alt-del.target: $ctrlStr${nl}"
        if ($ctrlStr -eq "masked") {
            $output += "  [PASS] Ctrl-Alt-Delete reboot disabled${nl}"
        }
        else {
            $output += "  [FAIL] Ctrl-Alt-Delete reboot not masked${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: Kernel panic behavior
    $output += "Check 4: Kernel Panic Behavior${nl}"
    try {
        $panicVal = $(timeout 5 cat /proc/sys/kernel/panic 2>/dev/null)
        $panicStr = ($panicVal -join " ").Trim()
        $output += "  kernel.panic = $panicStr${nl}"
        $panicOops = $(timeout 5 cat /proc/sys/kernel/panic_on_oops 2>/dev/null)
        $oopsStr = ($panicOops -join " ").Trim()
        $output += "  kernel.panic_on_oops = $oopsStr${nl}"
        if ($oopsStr -eq "1") {
            $output += "  [PASS] System will panic on kernel oops (fail-secure)${nl}"
        }
        else {
            $output += "  [INFO] System continues on kernel oops${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($suloginStr -match "sulogin" -and $ctrlStr -eq "masked") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203661 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203661
        STIG ID    : SRG-OS-000185-GPOS-00079
        Rule ID    : SV-203661r958552_rule
        Rule Title : Protect confidentiality and integrity of information at rest
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : b99c9ec4c8cde62b2a38f89d90563cd9
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203661"
    $RuleID = "SV-203661r958552_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: LUKS/dm-crypt encrypted volumes
    $output += "Check 1: Disk Encryption (LUKS/dm-crypt)${nl}"
    try {
        $luksDevices = $(timeout 10 sh -c "lsblk -o NAME,FSTYPE,MOUNTPOINT 2>/dev/null | grep -i 'crypto_LUKS\|crypt'" 2>&1)
        $luksStr = ($luksDevices -join $nl).Trim()
        if ($luksStr) {
            $output += "  Encrypted volumes found:${nl}"
            foreach ($line in ($luksStr -split $nl)) {
                $output += "    $line${nl}"
            }
            $output += "  [PASS] LUKS encryption detected${nl}"
        }
        else {
            $output += "  [FAIL] No LUKS/dm-crypt encrypted volumes detected${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: /etc/crypttab
    $output += "Check 2: Encrypted Volume Configuration (/etc/crypttab)${nl}"
    try {
        $crypttab = $(timeout 5 sh -c "cat /etc/crypttab 2>/dev/null | grep -v '^#' | grep -v '^\s*$'" 2>&1)
        $cryptStr = ($crypttab -join $nl).Trim()
        if ($cryptStr) {
            $output += "  $cryptStr${nl}"
            $output += "  [PASS] Encrypted volumes defined in /etc/crypttab${nl}"
        }
        else {
            $output += "  [INFO] No entries in /etc/crypttab (or file not present)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Filesystem permissions on sensitive directories
    $output += "Check 3: Sensitive Directory Permissions${nl}"
    try {
        $sensitiveDirs = @("/etc/shadow", "/etc/gshadow", "/etc/ssl/private")
        foreach ($dir in $sensitiveDirs) {
            $perms = $(timeout 5 stat -c "%a %U:%G %n" $dir 2>/dev/null)
            $permStr = ($perms -join " ").Trim()
            if ($permStr) {
                $output += "  $permStr${nl}"
            }
        }
        $shadowPerms = $(timeout 5 stat -c "%a" /etc/shadow 2>/dev/null)
        $shadowStr = ($shadowPerms -join " ").Trim()
        if ($shadowStr -match "^[0-6][04]0$") {
            $output += "  [PASS] /etc/shadow has restrictive permissions${nl}"
        }
        else {
            $output += "  [FAIL] /etc/shadow permissions too permissive ($shadowStr)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: XO data directory permissions
    $output += "Check 4: XO Data Directory Protection${nl}"
    try {
        $xoDirs = @("/var/lib/xo-server", "/etc/xo-server", "/opt/xo")
        foreach ($xoDir in $xoDirs) {
            $xoPerms = $(timeout 5 stat -c "%a %U:%G %n" $xoDir 2>/dev/null)
            $xoStr = ($xoPerms -join " ").Trim()
            if ($xoStr) {
                $output += "  $xoStr${nl}"
            }
        }
        $output += "  [INFO] Verify XO data directories have appropriate access controls${nl}"
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status — LUKS or restrictive file permissions
    if ($luksStr -match "crypt") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203663 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203663
        STIG ID    : SRG-OS-000205-GPOS-00083
        Rule ID    : SV-203663r958564_rule
        Rule Title : Error messages provide necessary info without exploitable details
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : d1d2bde2aa595baeee464a17bea64e1f
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203663"
    $RuleID = "SV-203663r958564_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: /etc/issue and /etc/issue.net
    $output += "Check 1: Login Banner Configuration${nl}"
    try {
        $issueContent = $(timeout 5 cat /etc/issue 2>/dev/null)
        $issueStr = ($issueContent -join $nl).Trim()
        $output += "  /etc/issue:${nl}"
        if ($issueStr) {
            $output += "  $issueStr${nl}"
            if ($issueStr -match "\\\\[lnmrsv]|\\\\[oO]") {
                $output += "  [FAIL] /etc/issue contains OS identification escape sequences${nl}"
            }
            else {
                $output += "  [PASS] /etc/issue does not expose OS details via escape codes${nl}"
            }
        }
        else {
            $output += "  (empty)${nl}"
            $output += "  [PASS] /etc/issue is empty${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: /etc/issue.net for remote sessions
    $output += "Check 2: Remote Login Banner (/etc/issue.net)${nl}"
    try {
        $issueNet = $(timeout 5 cat /etc/issue.net 2>/dev/null)
        $issueNetStr = ($issueNet -join $nl).Trim()
        $output += "  /etc/issue.net:${nl}"
        if ($issueNetStr) {
            $output += "  $issueNetStr${nl}"
            if ($issueNetStr -match "\\\\[lnmrsv]|\\\\[oO]") {
                $output += "  [FAIL] /etc/issue.net contains OS identification escape sequences${nl}"
            }
            else {
                $output += "  [PASS] /etc/issue.net does not expose OS details${nl}"
            }
        }
        else {
            $output += "  (empty)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH banner configuration
    $output += "Check 3: SSH Banner Configuration${nl}"
    try {
        $sshBanner = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i banner" 2>&1)
        $bannerStr = ($sshBanner -join " ").Trim()
        $output += "  $bannerStr${nl}"
        if ($bannerStr -match "banner\s+/etc/issue") {
            $output += "  [PASS] SSH banner configured to use /etc/issue or /etc/issue.net${nl}"
        }
        elseif ($bannerStr -match "banner\s+none") {
            $output += "  [FAIL] SSH banner is set to none${nl}"
        }
        else {
            $output += "  [INFO] SSH banner uses custom file${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: System logging verbosity (not leaking sensitive data)
    $output += "Check 4: Syslog Error Message Configuration${nl}"
    try {
        $rsysConf = $(timeout 5 sh -c "grep -v '^#' /etc/rsyslog.conf 2>/dev/null | grep -v '^\s*$' | head -20" 2>&1)
        $rsysStr = ($rsysConf -join $nl).Trim()
        if ($rsysStr) {
            $output += "  rsyslog configured (first 20 active lines)${nl}"
            $output += "  [PASS] System logging configured to capture errors${nl}"
        }
        else {
            $output += "  [INFO] rsyslog.conf not found or empty${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    $issueOk = ($issueStr -notmatch "\\\\[lnmrsv]|\\\\[oO]") -or (-not $issueStr)
    $issueNetOk = ($issueNetStr -notmatch "\\\\[lnmrsv]|\\\\[oO]") -or (-not $issueNetStr)
    if ($issueOk -and $issueNetOk -and $rsysStr) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203664 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203664
        STIG ID    : SRG-OS-000206-GPOS-00084
        Rule ID    : SV-203664r958566_rule
        Rule Title : Reveal error messages only to authorized users
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 37c113e557135af92d3d0d2ec058550e
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203664"
    $RuleID = "SV-203664r958566_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: /var/log permissions (restrict error logs to authorized users)
    $output += "Check 1: System Log Directory Permissions${nl}"
    try {
        $logPerms = $(timeout 5 stat -c "%a %U:%G %n" /var/log 2>/dev/null)
        $logStr = ($logPerms -join " ").Trim()
        $output += "  $logStr${nl}"
        if ($logStr -match "^(\d+)\s") {
            $permVal = $Matches[1]
            if ([int]$permVal -le 755) {
                $output += "  [PASS] /var/log permissions restrict unauthorized access${nl}"
            }
            else {
                $output += "  [FAIL] /var/log permissions too permissive ($permVal)${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Key log file permissions
    $output += "Check 2: Individual Log File Permissions${nl}"
    try {
        $logFiles = @("/var/log/syslog", "/var/log/auth.log", "/var/log/kern.log", "/var/log/messages")
        $logIssues = 0
        foreach ($lf in $logFiles) {
            $lfPerms = $(timeout 5 stat -c "%a %U:%G %n" $lf 2>/dev/null)
            $lfStr = ($lfPerms -join " ").Trim()
            if ($lfStr) {
                $output += "  $lfStr${nl}"
                if ($lfStr -match "^(\d+)\s") {
                    $lfPerm = $Matches[1]
                    if ([int]$lfPerm -gt 640) {
                        $output += "  [FAIL] $lf permissions too permissive ($lfPerm)${nl}"
                        $logIssues++
                    }
                }
            }
        }
        if ($logIssues -eq 0) {
            $output += "  [PASS] Log files have appropriate permissions${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: journald configuration
    $output += "Check 3: journald Access Configuration${nl}"
    try {
        $jdConf = $(timeout 5 sh -c "grep -v '^#' /etc/systemd/journald.conf 2>/dev/null | grep -v '^\s*$'" 2>&1)
        $jdStr = ($jdConf -join $nl).Trim()
        if ($jdStr) {
            $output += "  $jdStr${nl}"
        }
        $jdStorage = $(timeout 5 sh -c "grep -i 'Storage' /etc/systemd/journald.conf 2>/dev/null | grep -v '^#'" 2>&1)
        $jdStorStr = ($jdStorage -join " ").Trim()
        if ($jdStorStr) {
            $output += "  Storage setting: $jdStorStr${nl}"
        }
        $output += "  [INFO] journald access controlled by systemd permissions${nl}"
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: Dmesg restriction
    $output += "Check 4: Kernel Message Restriction (dmesg)${nl}"
    try {
        $dmesgRestrict = $(timeout 5 cat /proc/sys/kernel/dmesg_restrict 2>/dev/null)
        $dmesgStr = ($dmesgRestrict -join " ").Trim()
        $output += "  kernel.dmesg_restrict = $dmesgStr${nl}"
        if ($dmesgStr -eq "1") {
            $output += "  [PASS] Kernel messages restricted to root${nl}"
        }
        else {
            $output += "  [FAIL] Kernel messages accessible to all users (should be 1)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($logIssues -eq 0 -and $dmesgStr -eq "1") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203665 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203665
        STIG ID    : SRG-OS-000228-GPOS-00088
        Rule ID    : SV-203665r958586_rule
        Rule Title : Public connection DoD banner
        DiscussMD5 : 179642ce1664f672230a1ec642585e03
        CheckMD5   : 736321e82ecfcc193e8e036f8fba7839
        FixMD5     : 475ce9616a5c79b8fa924f8fddebda02
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203665"
    $RuleID = "SV-203665r958586_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: SSH Banner for public connections
    $output += "Check 1: SSH Banner for Public/Remote Connections${nl}"
    $sshBannerPass = $false
    try {
        $sshBanner = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i '^banner'" 2>&1)
        $sshBannerStr = ($sshBanner -join $nl).Trim()
        if ($sshBannerStr -match "banner\s+(/\S+)") {
            $bannerFile = $matches[1]
            $output += "  SSH banner file: $bannerFile${nl}"
            $bannerContent = $(timeout 5 cat $bannerFile 2>&1)
            $bannerStr = ($bannerContent -join $nl).Trim()
            if ($bannerStr -match "USG|U\.S\. Government|consent to monitoring|authorized use") {
                $output += "  [PASS] DoD banner content verified in $bannerFile${nl}"
                $sshBannerPass = $true
            }
            else {
                $output += "  [FAIL] Banner file exists but missing DoD keywords${nl}"
            }
        }
        elseif ($sshBannerStr -match "banner\s+none") {
            $output += "  [FAIL] SSH banner set to none${nl}"
        }
        else {
            $output += "  [FAIL] SSH banner not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: /etc/motd (displayed after login)
    $output += "Check 2: Post-Login Message (/etc/motd)${nl}"
    try {
        $motdContent = $(timeout 5 cat /etc/motd 2>&1)
        $motdStr = ($motdContent -join $nl).Trim()
        if ($motdStr -match "USG|U\.S\. Government|consent to monitoring|authorized use") {
            $output += "  [PASS] DoD banner present in /etc/motd${nl}"
        }
        elseif ($motdStr) {
            $output += "  [INFO] /etc/motd has content but missing DoD banner keywords${nl}"
        }
        else {
            $output += "  [INFO] /etc/motd is empty or missing${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: /etc/issue.net (remote connections)
    $output += "Check 3: Remote Login Banner (/etc/issue.net)${nl}"
    try {
        $issueNet = $(timeout 5 cat /etc/issue.net 2>&1)
        $issueNetStr = ($issueNet -join $nl).Trim()
        if ($issueNetStr -match "USG|U\.S\. Government|consent to monitoring|authorized use") {
            $output += "  [PASS] DoD banner present in /etc/issue.net${nl}"
        }
        elseif ($issueNetStr) {
            $output += "  [INFO] /etc/issue.net has content but missing DoD keywords${nl}"
        }
        else {
            $output += "  [FAIL] /etc/issue.net is empty or missing${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($sshBannerPass) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203666 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203666
        STIG ID    : SRG-OS-000239-GPOS-00089
        Rule ID    : SV-203666r991551_rule
        Rule Title : The operating system must audit all account modifications.
        DiscussMD5 : 3761871ff35c5ac54793fa47e3231e0b
        CheckMD5   : 8594c9f9f472520a8aca87af063f23a7
        FixMD5     : fc502dfb96e355ca36ad1ca46ef83d79
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203666"
    $RuleID = "SV-203666r991551_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Verify auditd is running
    $output += "Check 1: Audit Service Status${nl}"
    try {
        $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
        $auditdStr = ($auditdStatus -join $nl).Trim()
        if ($auditdStr -eq "active") {
            $output += "  [PASS] auditd is active${nl}"
        }
        else {
            $output += "  [FAIL] auditd is not active: $auditdStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Audit rules for account modification files
    $output += "Check 2: Audit Rules for Account Modifications${nl}"
    try {
        $auditRules = $(timeout 5 auditctl -l 2>&1)
        $rulesStr = ($auditRules -join $nl).Trim()

        $requiredFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow", "/etc/security/opasswd")
        $foundRules = @()
        $missingRules = @()

        foreach ($file in $requiredFiles) {
            if ($rulesStr -match [regex]::Escape($file)) {
                $foundRules += $file
                $matchedRule = ($rulesStr -split $nl | Where-Object { $_ -match [regex]::Escape($file) }) | Select-Object -First 1
                $output += "  [PASS] Watch rule found: $matchedRule${nl}"
            }
            else {
                $missingRules += $file
                $output += "  [FAIL] No watch rule for: $file${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Persistent audit rules in rules.d
    $output += "Check 3: Persistent Audit Rules${nl}"
    try {
        $persistRules = $(timeout 10 grep -r "passwd\|shadow\|group\|gshadow\|opasswd" /etc/audit/rules.d/ 2>&1)
        $persistStr = ($persistRules -join $nl).Trim()
        if ($persistStr -and $persistStr -notmatch "No such file") {
            $output += "  [PASS] Persistent rules found in /etc/audit/rules.d/${nl}"
            foreach ($line in ($persistStr -split $nl | Select-Object -First 5)) {
                $output += "    $line${nl}"
            }
        }
        else {
            $output += "  [FAIL] No persistent rules for account files in /etc/audit/rules.d/${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($auditdStr -eq "active" -and $foundRules.Count -ge 3) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203667 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203667
        STIG ID    : SRG-OS-000240-GPOS-00090
        Rule ID    : SV-203667r991552_rule
        Rule Title : The operating system must audit all account disabling actions.
        DiscussMD5 : bca8dd964c2e420799352c5b5e89209b
        CheckMD5   : af23f946cbe7e03622c37a0b77f0a218
        FixMD5     : 4ecb24bcbaebede6a525ea060e07bf53
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203667"
    $RuleID = "SV-203667r991552_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Verify auditd is running
    $output += "Check 1: Audit Service Status${nl}"
    try {
        $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
        $auditdStr = ($auditdStatus -join $nl).Trim()
        if ($auditdStr -eq "active") {
            $output += "  [PASS] auditd is active${nl}"
        }
        else {
            $output += "  [FAIL] auditd is not active: $auditdStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Audit rules for account disabling files
    $output += "Check 2: Audit Rules for Account Disabling Actions${nl}"
    try {
        $auditRules = $(timeout 5 auditctl -l 2>&1)
        $rulesStr = ($auditRules -join $nl).Trim()

        $requiredFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow", "/etc/security/opasswd")
        $foundRules = @()
        $missingRules = @()

        foreach ($file in $requiredFiles) {
            if ($rulesStr -match [regex]::Escape($file)) {
                $foundRules += $file
                $matchedRule = ($rulesStr -split $nl | Where-Object { $_ -match [regex]::Escape($file) }) | Select-Object -First 1
                $output += "  [PASS] Watch rule found: $matchedRule${nl}"
            }
            else {
                $missingRules += $file
                $output += "  [FAIL] No watch rule for: $file${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Persistent audit rules in rules.d
    $output += "Check 3: Persistent Audit Rules${nl}"
    try {
        $persistRules = $(timeout 10 grep -r "passwd\|shadow\|group\|gshadow\|opasswd" /etc/audit/rules.d/ 2>&1)
        $persistStr = ($persistRules -join $nl).Trim()
        if ($persistStr -and $persistStr -notmatch "No such file") {
            $output += "  [PASS] Persistent rules found in /etc/audit/rules.d/${nl}"
            foreach ($line in ($persistStr -split $nl | Select-Object -First 5)) {
                $output += "    $line${nl}"
            }
        }
        else {
            $output += "  [FAIL] No persistent rules for account files in /etc/audit/rules.d/${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($auditdStr -eq "active" -and $foundRules.Count -ge 3) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203668 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203668
        STIG ID    : SRG-OS-000241-GPOS-00091
        Rule ID    : SV-203668r991553_rule
        Rule Title : The operating system must audit all account removal actions.
        DiscussMD5 : e17ca265049c657cb97367d40c88852e
        CheckMD5   : aa4b1681010b9a137c1dfd30a8bf5675
        FixMD5     : d6c9a7f75e4a9f0618088d8cee64ceee
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203668"
    $RuleID = "SV-203668r991553_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Verify auditd is running
    $output += "Check 1: Audit Service Status${nl}"
    try {
        $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
        $auditdStr = ($auditdStatus -join $nl).Trim()
        if ($auditdStr -eq "active") {
            $output += "  [PASS] auditd is active${nl}"
        }
        else {
            $output += "  [FAIL] auditd is not active: $auditdStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Audit rules for account removal files
    $output += "Check 2: Audit Rules for Account Removal Actions${nl}"
    try {
        $auditRules = $(timeout 5 auditctl -l 2>&1)
        $rulesStr = ($auditRules -join $nl).Trim()

        $requiredFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow", "/etc/security/opasswd")
        $foundRules = @()
        $missingRules = @()

        foreach ($file in $requiredFiles) {
            if ($rulesStr -match [regex]::Escape($file)) {
                $foundRules += $file
                $matchedRule = ($rulesStr -split $nl | Where-Object { $_ -match [regex]::Escape($file) }) | Select-Object -First 1
                $output += "  [PASS] Watch rule found: $matchedRule${nl}"
            }
            else {
                $missingRules += $file
                $output += "  [FAIL] No watch rule for: $file${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Persistent audit rules in rules.d
    $output += "Check 3: Persistent Audit Rules${nl}"
    try {
        $persistRules = $(timeout 10 grep -r "passwd\|shadow\|group\|gshadow\|opasswd" /etc/audit/rules.d/ 2>&1)
        $persistStr = ($persistRules -join $nl).Trim()
        if ($persistStr -and $persistStr -notmatch "No such file") {
            $output += "  [PASS] Persistent rules found in /etc/audit/rules.d/${nl}"
            foreach ($line in ($persistStr -split $nl | Select-Object -First 5)) {
                $output += "    $line${nl}"
            }
        }
        else {
            $output += "  [FAIL] No persistent rules for account files in /etc/audit/rules.d/${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($auditdStr -eq "active" -and $foundRules.Count -ge 3) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203669 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203669
        STIG ID    : SRG-OS-000250-GPOS-00093
        Rule ID    : SV-203669r991554_rule
        Rule Title : The operating system must implement cryptography to protect the integrity of remote access sessions.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203669"
    $RuleID = "SV-203669r991554_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203669 - Cryptographic Integrity for Remote Access Sessions" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    $allPass = $true

    # Check 1: SSH MAC algorithms (integrity protection for remote sessions)
    $FindingDetails += "Check 1: SSH MAC Algorithms (Integrity)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    $weakMACs = @("hmac-md5", "hmac-md5-96", "hmac-sha1-96", "umac-64@openssh.com")

    if ($sshdStr -match "(?m)^macs\s+(.+)$") {
        $macLine = $matches[1].Trim()
        $macList = $macLine -split ","
        $FindingDetails += "Configured MACs: " + $macLine + $nl

        $weakMacFound = $false
        foreach ($m in $macList) {
            $m = $m.Trim()
            if ($m -in $weakMACs) {
                $FindingDetails += "  FAIL: Weak MAC algorithm detected: " + $m + $nl
                $weakMacFound = $true
                $allPass = $false
            }
        }
        if (-not $weakMacFound) {
            $FindingDetails += "  PASS: All MAC algorithms provide adequate integrity protection" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH MAC configuration" + $nl
        $allPass = $false
    }

    $FindingDetails += $nl

    # Check 2: SSH host key algorithms (server authentication integrity)
    $FindingDetails += "Check 2: SSH Host Key Algorithms" + $nl
    $FindingDetails += ("-" * 40) + $nl

    if ($sshdStr -match "(?m)^hostkeyalgorithms\s+(.+)$") {
        $hkaLine = $matches[1].Trim()
        $FindingDetails += "Host key algorithms: " + $hkaLine + $nl

        $weakHKA = @("ssh-dss", "ssh-dsa")
        $weakHkaFound = $false
        $hkaList = $hkaLine -split ","
        foreach ($h in $hkaList) {
            $h = $h.Trim()
            if ($h -in $weakHKA) {
                $FindingDetails += "  FAIL: Weak host key algorithm: " + $h + $nl
                $weakHkaFound = $true
                $allPass = $false
            }
        }
        if (-not $weakHkaFound) {
            $FindingDetails += "  PASS: All host key algorithms meet integrity requirements" + $nl
        }
    } else {
        $FindingDetails += "Host key algorithms: Using OpenSSH defaults (acceptable)" + $nl
        # OpenSSH defaults exclude weak algorithms on Debian 12
    }

    $FindingDetails += $nl

    # Check 3: SSH protocol version
    $FindingDetails += "Check 3: SSH Protocol Version" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshVersion = $(ssh -V 2>&1)
    $sshVerStr = ($sshVersion -join $nl).Trim()
    $FindingDetails += "SSH version: " + $sshVerStr + $nl

    if ($sshVerStr -match "OpenSSH_(\d+)\.(\d+)") {
        $majorVer = [int]$matches[1]
        if ($majorVer -ge 7) {
            $FindingDetails += "  PASS: OpenSSH version supports SSH protocol 2 only" + $nl
        } else {
            $FindingDetails += "  FAIL: OpenSSH version may support deprecated protocol 1" + $nl
            $allPass = $false
        }
    } else {
        $FindingDetails += "  INFO: Could not parse SSH version" + $nl
    }

    $FindingDetails += $nl

    # Check 4: Insecure remote access services
    $FindingDetails += "Check 4: Insecure Remote Access Services" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $insecurePkgs = @("telnetd", "rsh-server", "rlogin", "rexecd")
    $insecureFound = $false
    foreach ($pkg in $insecurePkgs) {
        $pkgCheck = $(dpkg -l $pkg 2>&1)
        $pkgStr = ($pkgCheck -join $nl)
        if ($pkgStr -match "^ii\s") {
            $FindingDetails += "  FAIL: Insecure service installed: " + $pkg + $nl
            $insecureFound = $true
            $allPass = $false
        }
    }
    if (-not $insecureFound) {
        $FindingDetails += "  PASS: No insecure remote access services installed" + $nl
    }

    $FindingDetails += $nl

    # Check 5: SSH service active
    $FindingDetails += "Check 5: SSH Service Status" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshActive = $(systemctl is-active sshd 2>&1)
    $sshStr = ($sshActive -join $nl).Trim()
    if ($sshStr -ne "active") {
        $sshActive = $(systemctl is-active ssh 2>&1)
        $sshStr = ($sshActive -join $nl).Trim()
    }
    $FindingDetails += "SSH service status: " + $sshStr + $nl

    if ($sshStr -eq "active") {
        $FindingDetails += "  PASS: SSH is the active remote access method" + $nl
    } else {
        $FindingDetails += "  WARNING: SSH service not active" + $nl
        $allPass = $false
    }

    $FindingDetails += $nl

    # Status determination
    if ($allPass) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Cryptographic integrity protections implemented for remote access sessions" + $nl
    } else {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Remote access integrity protection deficiencies detected" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203670 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203670
        STIG ID    : SRG-OS-000254-GPOS-00095
        Rule ID    : SV-203670r991555_rule
        Rule Title : The operating system must initiate session audits at system start-up.
        DiscussMD5 : 96cf448f653f1b255bfd678004a12b19
        CheckMD5   : 37a2438734b73c2f87d9d438943a9dae
        FixMD5     : 6e6fdf69a4a7f6da45b2a27c08726599
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203670"
    $RuleID = "SV-203670r991555_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0
    $FindingDetails += "CHECK: Session audits initiated at system start-up" + $nl
    $FindingDetails += "======================================================" + $nl + $nl

    # Check 1: auditd enabled at boot
    $FindingDetails += "--- Check 1: auditd Enabled at Boot ---" + $nl
    $auditdEnabled = $(timeout 5 systemctl is-enabled auditd 2>&1)
    $FindingDetails += "  auditd enabled: $auditdEnabled" + $nl
    if ($auditdEnabled -eq "enabled") {
        $FindingDetails += "  [PASS] auditd starts at boot" + $nl
    }
    else {
        $FindingDetails += "  [FAIL] auditd is not enabled at boot" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 2: auditd currently running
    $FindingDetails += "--- Check 2: auditd Currently Active ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "  Service active: $auditdStatus" + $nl
    if ($auditdStatus -eq "active") {
        $FindingDetails += "  [PASS] auditd is currently running" + $nl
    }
    else {
        $FindingDetails += "  [FAIL] auditd is not running" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 3: Kernel audit parameter (audit=1 in boot params)
    $FindingDetails += "--- Check 3: Kernel Audit Boot Parameter ---" + $nl
    $cmdline = $(timeout 5 cat /proc/cmdline 2>&1)
    $FindingDetails += "  Kernel cmdline: $cmdline" + $nl
    if ($cmdline -match "audit=1") {
        $FindingDetails += "  [PASS] audit=1 set in kernel boot parameters" + $nl
    }
    else {
        $FindingDetails += "  [FAIL] audit=1 not found in kernel boot parameters" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    # Check 4: GRUB configuration for audit parameter
    $FindingDetails += "--- Check 4: GRUB Audit Configuration ---" + $nl
    $grubDefault = $(timeout 5 grep -i "GRUB_CMDLINE_LINUX" /etc/default/grub 2>&1)
    if ($grubDefault) {
        $FindingDetails += "  GRUB config: $grubDefault" + $nl
        if (($grubDefault -join " ") -match "audit=1") {
            $FindingDetails += "  [PASS] audit=1 configured in GRUB defaults" + $nl
        }
        else {
            $FindingDetails += "  [FAIL] audit=1 not in GRUB_CMDLINE_LINUX" + $nl
            $auditIssues++
        }
    }
    else {
        $FindingDetails += "  [INFO] /etc/default/grub not accessible" + $nl
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [INFO] XO Audit Plugin provides boot-time audit initialization (XO audit starts after application launch, not at OS boot)" + $nl
        $FindingDetails += "  [INFO] Partial coverage only — this check requires OS-level boot-time audit" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203671 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203671
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203671r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203671"
    $RuleID = "SV-203671r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203671) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203672 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203672
        STIG ID    : SRG-OS-000256-GPOS-00097
        Rule ID    : SV-203672r991557_rule
        Rule Title : The operating system must protect audit tools from unauthorized access.
        DiscussMD5 : fde4179bb09554f807700ad6d05cf831
        CheckMD5   : e1605000002a14808a05d9c038350543
        FixMD5     : 0078e534ea1e0a19682b43928f72eedf
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203672"
    $RuleID = "SV-203672r991557_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $auditTools = @(
        "/usr/sbin/auditctl",
        "/usr/sbin/auditd",
        "/usr/sbin/aureport",
        "/usr/sbin/ausearch",
        "/usr/sbin/autrace",
        "/usr/sbin/augenrules"
    )

    $FindingDetails += "CHECK 1: Audit Tool Binary Permissions" + $nl
    $FindingDetails += "--------------------------------------" + $nl
    $toolsChecked = 0
    foreach ($tool in $auditTools) {
        $toolPerms = $(timeout 5 stat -c "%a %U:%G %n" $tool 2>&1)
        if ($toolPerms -and $toolPerms -notmatch "No such file") {
            $toolsChecked++
            $FindingDetails += "$toolPerms" + $nl
            if ($toolPerms -match "^(\d+)\s") {
                $mode = [int]$matches[1]
                if ($mode -gt 755) {
                    $auditIssues++
                    $FindingDetails += "  FAIL: Permissions $($matches[1]) too permissive (expected 755 or less)" + $nl
                }
            }
        }
    }
    if ($toolsChecked -eq 0) {
        $auditIssues++
        $FindingDetails += "FAIL: No audit tool binaries found" + $nl
    }
    elseif ($auditIssues -eq 0) {
        $FindingDetails += "PASS: All audit tools have appropriate access permissions" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Tool Ownership" + $nl
    $FindingDetails += "-----------------------------" + $nl
    $ownerIssue = $false
    foreach ($tool in $auditTools) {
        $toolOwner = $(timeout 5 stat -c "%U:%G %n" $tool 2>&1)
        if ($toolOwner -and $toolOwner -notmatch "No such file") {
            if ($toolOwner -notmatch "^root:") {
                $ownerIssue = $true
                $auditIssues++
                $FindingDetails += "FAIL: $tool not owned by root ($toolOwner)" + $nl
            }
        }
    }
    if (-not $ownerIssue -and $toolsChecked -gt 0) {
        $FindingDetails += "PASS: All audit tools owned by root" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Audit Tool Package Integrity" + $nl
    $FindingDetails += "--------------------------------------" + $nl
    $dpkgVerify = $(timeout 10 dpkg --verify auditd 2>&1)
    if ($dpkgVerify) {
        $FindingDetails += ($dpkgVerify -join $nl) + $nl
        $verifyStr = ($dpkgVerify -join $nl)
        if ($verifyStr -match "missing|5") {
            $auditIssues++
            $FindingDetails += "FAIL: Package integrity issues detected" + $nl
        }
        else {
            $FindingDetails += "INFO: Package verification returned output (review above)" + $nl
        }
    }
    else {
        $FindingDetails += "PASS: dpkg --verify auditd returned no issues" + $nl
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit initialization settings; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203673 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203673
        STIG ID    : SRG-OS-000257-GPOS-00098
        Rule ID    : SV-203673r991558_rule
        Rule Title : The operating system must protect audit tools from unauthorized modification.
        DiscussMD5 : 2441ecf4de96f42d539e797af9d30edc
        CheckMD5   : 401b551a53bb667254087d83102078f1
        FixMD5     : 1597bc3cfbcc617888040c3fe73d2f23
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203673"
    $RuleID = "SV-203673r991558_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $auditTools = @(
        "/usr/sbin/auditctl",
        "/usr/sbin/auditd",
        "/usr/sbin/aureport",
        "/usr/sbin/ausearch",
        "/usr/sbin/autrace",
        "/usr/sbin/augenrules"
    )

    $FindingDetails += "CHECK 1: Audit Tool Write Permissions" + $nl
    $FindingDetails += "-------------------------------------" + $nl
    $toolsChecked = 0
    foreach ($tool in $auditTools) {
        $toolPerms = $(timeout 5 stat -c "%a %U:%G %n" $tool 2>&1)
        if ($toolPerms -and $toolPerms -notmatch "No such file") {
            $toolsChecked++
            $FindingDetails += "$toolPerms" + $nl
            if ($toolPerms -match "^(\d+)\s") {
                $mode = $matches[1]
                $groupWrite = [int]([string]$mode[1])
                $otherWrite = [int]([string]$mode[2])
                if ($groupWrite -band 2 -or $otherWrite -band 2) {
                    $auditIssues++
                    $FindingDetails += "  FAIL: Group or other write permission enabled ($mode)" + $nl
                }
            }
        }
    }
    if ($toolsChecked -eq 0) {
        $auditIssues++
        $FindingDetails += "FAIL: No audit tool binaries found" + $nl
    }
    elseif ($auditIssues -eq 0) {
        $FindingDetails += "PASS: No audit tools have group/other write permissions" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Tool SUID/SGID Bits" + $nl
    $FindingDetails += "-----------------------------------" + $nl
    $suidIssue = $false
    foreach ($tool in $auditTools) {
        $toolPerms = $(timeout 5 stat -c "%a %n" $tool 2>&1)
        if ($toolPerms -and $toolPerms -notmatch "No such file") {
            if ($toolPerms -match "^(\d+)\s") {
                $modeStr = $matches[1]
                if ($modeStr.Length -gt 3) {
                    $specialBits = [int]([string]$modeStr[0])
                    if ($specialBits -band 4 -or $specialBits -band 2) {
                        $suidIssue = $true
                        $auditIssues++
                        $FindingDetails += "FAIL: SUID/SGID set on $tool ($modeStr)" + $nl
                    }
                }
            }
        }
    }
    if (-not $suidIssue) {
        $FindingDetails += "PASS: No SUID/SGID bits set on audit tools" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Audit Configuration File Protection" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $confFiles = @("/etc/audit/auditd.conf", "/etc/audit/audit.rules")
    foreach ($cf in $confFiles) {
        $cfPerms = $(timeout 5 stat -c "%a %U:%G %n" $cf 2>&1)
        if ($cfPerms -and $cfPerms -notmatch "No such file") {
            $FindingDetails += "$cfPerms" + $nl
            if ($cfPerms -match "^(\d+)\s") {
                $cfMode = $matches[1]
                $cfGroup = [int]([string]$cfMode[1])
                $cfOther = [int]([string]$cfMode[2])
                if ($cfGroup -band 2 -or $cfOther -band 2) {
                    $auditIssues++
                    $FindingDetails += "  FAIL: Config file writable by group/other ($cfMode)" + $nl
                }
            }
        }
        else {
            $FindingDetails += "$cf : NOT FOUND" + $nl
        }
    }
    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit failure mode configuration; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $FindingDetails += "PASS: Audit configuration files protected from modification" + $nl
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203674 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203674
        STIG ID    : SRG-OS-000258-GPOS-00099
        Rule ID    : SV-203674r991559_rule
        Rule Title : The operating system must protect audit tools from unauthorized deletion.
        DiscussMD5 : 17d9abce8f31d50131746dd07dd5ab33
        CheckMD5   : 0d41a0a6156a88462b8673d68a86d214
        FixMD5     : 4f668a811e291c8c538b79bbf8ff2f51
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203674"
    $RuleID = "SV-203674r991559_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $auditTools = @(
        "/usr/sbin/auditctl",
        "/usr/sbin/auditd",
        "/usr/sbin/aureport",
        "/usr/sbin/ausearch",
        "/usr/sbin/autrace",
        "/usr/sbin/augenrules"
    )

    $FindingDetails += "CHECK 1: Audit Tool Directory Deletion Protection" + $nl
    $FindingDetails += "--------------------------------------------------" + $nl
    $dirPerms = $(timeout 5 stat -c "%a %U:%G %n" /usr/sbin 2>&1)
    if ($dirPerms -and $dirPerms -notmatch "No such file") {
        $FindingDetails += "$dirPerms" + $nl
        if ($dirPerms -match "^(\d+)\s") {
            $mode = $matches[1]
            $otherWrite = [int]($mode[-1])
            if ($otherWrite -band 2) {
                $auditIssues++
                $FindingDetails += "FAIL: /usr/sbin allows other-write (deletion risk)" + $nl
            }
            else {
                $FindingDetails += "PASS: /usr/sbin does not allow other-write" + $nl
            }
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: Cannot stat /usr/sbin" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Sticky Bit and Ownership on Parent Directory" + $nl
    $FindingDetails += "-----------------------------------------------------" + $nl
    if ($dirPerms -match "^(\d+)\s+(\S+)\s") {
        $mode = $matches[1]
        $owner = $matches[2]
        if ($mode.Length -eq 4 -and $mode[0] -eq "1") {
            $FindingDetails += "PASS: Sticky bit set on /usr/sbin" + $nl
        }
        else {
            $FindingDetails += "INFO: Sticky bit not set (standard for /usr/sbin)" + $nl
        }
        if ($owner -eq "root:root") {
            $FindingDetails += "PASS: /usr/sbin owned by root:root" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: /usr/sbin not owned by root:root ($owner)" + $nl
        }
    }

    $FindingDetails += $nl + "CHECK 3: Audit Tool Immutable Attributes" + $nl
    $FindingDetails += "-----------------------------------------" + $nl
    $toolsChecked = 0
    $immutableCount = 0
    foreach ($tool in $auditTools) {
        $lsattrOut = $(timeout 5 lsattr $tool 2>&1)
        if ($lsattrOut -and $lsattrOut -notmatch "No such file|Not supported|Inappropriate") {
            $toolsChecked++
            if ($lsattrOut -match "i") {
                $immutableCount++
            }
            $FindingDetails += "$lsattrOut" + $nl
        }
    }
    if ($toolsChecked -eq 0) {
        $FindingDetails += "INFO: No audit tool binaries found or lsattr not supported" + $nl
        $auditIssues++
    }
    elseif ($immutableCount -gt 0) {
        $FindingDetails += "PASS: $immutableCount of $toolsChecked tools have immutable attribute" + $nl
    }
    else {
        $FindingDetails += "INFO: No immutable attributes set on audit tools" + $nl
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [INFO] XO Audit Plugin provides audit record generation at the application layer (does not cover OS-level audit tool protection)" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203675 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203675
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203675r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203675"
    $RuleID = "SV-203675r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203675) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203676 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203676
        STIG ID    : SRG-OS-000266-GPOS-00101
        Rule ID    : SV-203676r991561_rule
        Rule Title : Enforce at least one special character in passwords
        DiscussMD5 : 15b707da51bf342b536d1be547c4516f
        CheckMD5   : 6d90f4e6729486d680e70e37e587faa4
        FixMD5     : 598a3ab78b88651b4bc8a8b37db7c709
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203676"
    $RuleID = "SV-203676r991561_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: pwquality.conf ocredit setting
    $output += "Check 1: pwquality.conf ocredit Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'ocredit'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "ocredit\s*=\s*(-?\d+)") {
            $ocreditVal = [int]$Matches[1]
            $output += "  ocredit = $ocreditVal${nl}"
            if ($ocreditVal -le -1) {
                $output += "  [PASS] Requires at least $([Math]::Abs($ocreditVal)) special character(s)${nl}"
            }
            else {
                $output += "  [FAIL] ocredit must be -1 or less (negative = required minimum)${nl}"
            }
        }
        else {
            $output += "  [FAIL] ocredit not configured in /etc/security/pwquality.conf${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: libpam-pwquality package installed
    $output += "Check 3: libpam-pwquality Package${nl}"
    try {
        $pkgCheck = $(timeout 5 sh -c "dpkg -l libpam-pwquality 2>/dev/null | grep '^ii'" 2>&1)
        $pkgStr = ($pkgCheck -join $nl).Trim()
        if ($pkgStr) {
            $output += "  $pkgStr${nl}"
            $output += "  [PASS] libpam-pwquality installed${nl}"
        }
        else {
            $output += "  [FAIL] libpam-pwquality not installed${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($pwqStr -match "ocredit\s*=\s*(-\d+)" -and $pamStr) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203677 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203677
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203677r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203677"
    $RuleID = "SV-203677r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203677) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203678 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203678
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203678r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203678"
    $RuleID = "SV-203678r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203678) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203679 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203679
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203679r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203679"
    $RuleID = "SV-203679r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203679) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203680 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203680
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203680r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203680"
    $RuleID = "SV-203680r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203680) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203681 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203681
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203681r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203681"
    $RuleID = "SV-203681r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203681) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203682 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203682
        STIG ID    : SRG-OS-000278-GPOS-00108
        Rule ID    : SV-203682r991567_rule
        Rule Title : The operating system must use cryptographic mechanisms to protect the integrity of audit tools.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203682"
    $RuleID = "SV-203682r991567_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203682 - Cryptographic Integrity of Audit Tools" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Verify AIDE (Advanced Intrusion Detection Environment) is installed
    $FindingDetails += "Check 1: File Integrity Monitoring Tool" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $aideInstalled = $false
    $tripwireInstalled = $false

    $aidePkg = $(dpkg -l aide 2>&1)
    $aideStr = ($aidePkg -join $nl)
    if ($aideStr -match "^ii\s") {
        $FindingDetails += "AIDE: Installed" + $nl
        $aideInstalled = $true
    } else {
        $FindingDetails += "AIDE: Not installed" + $nl
    }

    $tripwirePkg = $(dpkg -l tripwire 2>&1)
    $tripwireStr = ($tripwirePkg -join $nl)
    if ($tripwireStr -match "^ii\s") {
        $FindingDetails += "Tripwire: Installed" + $nl
        $tripwireInstalled = $true
    } else {
        $FindingDetails += "Tripwire: Not installed" + $nl
    }

    $FindingDetails += $nl

    # Check 2: Verify audit tool packages have not been tampered with
    $FindingDetails += "Check 2: Audit Package Integrity (dpkg -V)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $auditPkgs = @("auditd", "audispd-plugins", "libaudit1", "libaudit-common")
    $tamperFound = $false

    foreach ($pkg in $auditPkgs) {
        $pkgCheck = $(dpkg -l $pkg 2>&1)
        $pkgStr = ($pkgCheck -join $nl)
        if ($pkgStr -match "^ii\s") {
            $verifyResult = $(dpkg -V $pkg 2>&1)
            $verifyStr = ($verifyResult -join $nl).Trim()
            if ($verifyStr -ne "") {
                $FindingDetails += "  " + $pkg + ": MODIFIED - " + $verifyStr + $nl
                $tamperFound = $true
            } else {
                $FindingDetails += "  " + $pkg + ": Integrity OK" + $nl
            }
        }
    }

    $FindingDetails += $nl

    # Check 3: AIDE configuration (if installed)
    if ($aideInstalled) {
        $FindingDetails += "Check 3: AIDE Configuration" + $nl
        $FindingDetails += ("-" * 40) + $nl

        if (Test-Path /etc/aide/aide.conf) {
            $aideConf = Get-Content /etc/aide/aide.conf -ErrorAction SilentlyContinue
            $aideConfStr = ($aideConf -join $nl)

            if ($aideConfStr -match "sha256|sha512") {
                $FindingDetails += "AIDE uses cryptographic hashes (SHA-256/SHA-512)" + $nl
            } else {
                $FindingDetails += "AIDE configuration does not reference SHA-256/SHA-512 hashes" + $nl
            }

            $aideDbExists = Test-Path /var/lib/aide/aide.db
            $FindingDetails += "AIDE database exists: " + $aideDbExists + $nl
        } else {
            $FindingDetails += "AIDE config file not found at /etc/aide/aide.conf" + $nl
        }
        $FindingDetails += $nl
    }

    # Status determination
    if (-not $aideInstalled -and -not $tripwireInstalled) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - No file integrity monitoring tool installed (AIDE or Tripwire required)" + $nl
    } elseif ($tamperFound) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Audit tool package tampering detected" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Cryptographic integrity of audit tools verified" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203683 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203683
        STIG ID    : SRG-OS-000279-GPOS-00109
        Rule ID    : SV-203683r958636_rule
        Rule Title : Automatically terminate user session after inactivity or at shutdown
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 2a953cc9d7d4f473066baa9c9301b42b
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203683"
    $RuleID = "SV-203683r958636_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: SSH ClientAliveInterval
    $output += "Check 1: SSH Inactivity Timeout${nl}"
    try {
        $sshInterval = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i clientaliveinterval" 2>&1)
        $sshIntervalStr = ($sshInterval -join " ").Trim()
        $sshCount = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i clientalivecountmax" 2>&1)
        $sshCountStr = ($sshCount -join " ").Trim()
        $output += "  $sshIntervalStr${nl}"
        $output += "  $sshCountStr${nl}"
        $sshOk = $false
        if ($sshIntervalStr -match "clientaliveinterval\s+(\d+)") {
            $intervalVal = [int]$Matches[1]
            if ($intervalVal -gt 0 -and $intervalVal -le 600) {
                $output += "  [PASS] SSH inactivity timeout set to $intervalVal seconds${nl}"
                $sshOk = $true
            }
            else {
                $output += "  [FAIL] SSH inactivity timeout ($intervalVal) exceeds 600-second limit${nl}"
            }
        }
        else {
            $output += "  [FAIL] SSH ClientAliveInterval not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: TMOUT shell variable
    $output += "Check 2: Shell TMOUT Variable${nl}"
    try {
        $tmout = $(timeout 5 sh -c "grep -r 'TMOUT' /etc/profile /etc/profile.d/ /etc/bash.bashrc 2>/dev/null | grep -v '^#'" 2>&1)
        $tmoutStr = ($tmout -join $nl).Trim()
        $tmoutOk = $false
        if ($tmoutStr) {
            $output += "  $tmoutStr${nl}"
            if ($tmoutStr -match "TMOUT=(\d+)") {
                $tmoutVal = [int]$Matches[1]
                if ($tmoutVal -le 900) {
                    $output += "  [PASS] Shell TMOUT=$tmoutVal seconds${nl}"
                    $tmoutOk = $true
                }
                else {
                    $output += "  [FAIL] TMOUT=$tmoutVal exceeds 900-second limit${nl}"
                }
            }
        }
        else {
            $output += "  [FAIL] TMOUT not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: systemd-logind idle action
    $output += "Check 3: systemd-logind Idle Configuration${nl}"
    try {
        $logindConf = $(timeout 5 sh -c "grep -v '^#' /etc/systemd/logind.conf 2>/dev/null | grep -i 'IdleAction\|StopIdleSessionSec'" 2>&1)
        $logindStr = ($logindConf -join $nl).Trim()
        if ($logindStr) {
            $output += "  $logindStr${nl}"
            $output += "  [PASS] systemd-logind idle action configured${nl}"
        }
        else {
            $output += "  [INFO] No custom idle action in logind.conf${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: Screen lock / vlock
    $output += "Check 4: Terminal Lock Capability${nl}"
    try {
        $vlockPkg = $(timeout 5 sh -c "dpkg -l vlock 2>/dev/null | grep '^ii'" 2>&1)
        $vlockStr = ($vlockPkg -join " ").Trim()
        if ($vlockStr) {
            $output += "  $vlockStr${nl}"
            $output += "  [PASS] vlock terminal locking available${nl}"
        }
        else {
            $tmuxPkg = $(timeout 5 sh -c "which tmux 2>/dev/null" 2>&1)
            $tmuxStr = ($tmuxPkg -join " ").Trim()
            if ($tmuxStr -and $tmuxStr -notmatch "not found") {
                $output += "  tmux available at: $tmuxStr${nl}"
                $output += "  [INFO] tmux can provide session lock capability${nl}"
            }
            else {
                $output += "  [INFO] No terminal lock utility detected (vlock or tmux)${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($sshOk) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203684 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203684
        STIG ID    : SRG-OS-000280-GPOS-00110
        Rule ID    : SV-203684r958638_rule
        Rule Title : Provide logoff capability for user-initiated sessions
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 433c99c4c34d482edfa17351840f6f57
        FixMD5     : 00000000000000000000000000000000
        #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203684"
    $RuleID = "SV-203684r958638_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Shell logout/exit capability
    $output += "Check 1: Shell Logout Capability${nl}"
    try {
        $shellList = $(timeout 5 cat /etc/shells 2>/dev/null)
        $shellStr = ($shellList -join $nl).Trim()
        if ($shellStr) {
            $output += "  Valid shells:${nl}"
            foreach ($shell in ($shellStr -split $nl)) {
                $s = $shell.Trim()
                if ($s -and $s -notmatch "^#") {
                    $output += "    $s${nl}"
                }
            }
            $output += "  [PASS] Shell sessions support exit/logout commands${nl}"
        }
        else {
            $output += "  [INFO] /etc/shells not found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: SSH session termination
    $output += "Check 2: SSH Session Termination${nl}"
    try {
        $sshdActive = $(timeout 5 systemctl is-active sshd 2>/dev/null)
        $sshdStr = ($sshdActive -join " ").Trim()
        if ($sshdStr -ne "active") {
            $sshdActive = $(timeout 5 systemctl is-active ssh 2>/dev/null)
            $sshdStr = ($sshdActive -join " ").Trim()
        }
        $output += "  SSH service: $sshdStr${nl}"
        if ($sshdStr -eq "active") {
            $output += "  [PASS] SSH provides user-initiated session termination${nl}"
        }
        else {
            $output += "  [INFO] SSH service not active${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: XO web application logoff
    $output += "Check 3: XO Web Application Logoff${nl}"
    try {
        $xoProcess = $(timeout 5 sh -c "pgrep -fa 'xo-server' 2>/dev/null | head -3" 2>&1)
        $xoStr = ($xoProcess -join $nl).Trim()
        if ($xoStr) {
            $output += "  XO server process detected${nl}"
            $output += "  [PASS] XO web interface provides Sign Out button for user logoff${nl}"
        }
        else {
            $output += "  [INFO] XO server process not detected${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: systemd-logind session management
    $output += "Check 4: systemd-logind Session Management${nl}"
    try {
        $loginctl = $(timeout 5 loginctl list-sessions 2>/dev/null)
        $loginStr = ($loginctl -join $nl).Trim()
        if ($loginStr) {
            $output += "  Active sessions:${nl}"
            foreach ($line in ($loginStr -split $nl) | Select-Object -First 5) {
                $output += "    $line${nl}"
            }
            $output += "  [PASS] systemd-logind manages user sessions (loginctl terminate-session available)${nl}"
        }
        else {
            $output += "  [INFO] No active sessions or loginctl unavailable${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status — shell + SSH = logoff capability exists
    if ($shellStr -and $sshdStr -eq "active") {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203685 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203685
        STIG ID    : SRG-OS-000281-GPOS-00111
        Rule ID    : SV-203685r958640_rule
        Rule Title : The operating system must display an explicit logoff message to users indicating the reliable termination of authenticated communications sessions.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : f3903f30d3710ccf6aa808b46825e882
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203685"
    $RuleID = "SV-203685r958640_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Explicit Logoff Message ---" + $nl

    # Check 1: SSH logout message configuration
    $FindingDetails += $nl + "Check 1: SSH Logout Message" + $nl
    $sshdConfig = $(cat /etc/ssh/sshd_config 2>&1)
    $printLastLog = ($sshdConfig | Select-String -Pattern "^\s*PrintLastLog" | Select-Object -First 1)
    if ($printLastLog) {
        $FindingDetails += "  PrintLastLog setting: $($printLastLog.ToString().Trim())" + $nl
    }
    else {
        $FindingDetails += "  PrintLastLog: Not explicitly configured (default: yes)" + $nl
    }

    # Check 2: /etc/logout message or logout scripts
    $FindingDetails += $nl + "Check 2: System Logout Scripts" + $nl
    $logoutFiles = @("/etc/bash.bash_logout", "/etc/profile.d/logout.sh", "/root/.bash_logout")
    $logoutConfigured = $false
    foreach ($lf in $logoutFiles) {
        $lfContent = $(cat $lf 2>&1)
        if ($LASTEXITCODE -eq 0 -and $lfContent) {
            $FindingDetails += "  $lf : EXISTS" + $nl
            $hasEcho = ($lfContent | Select-String -Pattern "echo|printf|wall" | Select-Object -First 1)
            if ($hasEcho) {
                $FindingDetails += "    Contains logoff message command: $($hasEcho.ToString().Trim())" + $nl
                $logoutConfigured = $true
            }
            else {
                $FindingDetails += "    No explicit logoff message command found" + $nl
            }
        }
        else {
            $FindingDetails += "  $lf : NOT FOUND" + $nl
        }
    }

    # Check 3: PAM session close messages
    $FindingDetails += $nl + "Check 3: PAM Session Close" + $nl
    $pamCommonSession = $(cat /etc/pam.d/common-session 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $sessionClose = ($pamCommonSession | Select-String -Pattern "session.*close|pam_lastlog" | Select-Object -First 1)
        if ($sessionClose) {
            $FindingDetails += "  PAM session close configured: $($sessionClose.ToString().Trim())" + $nl
        }
        else {
            $FindingDetails += "  No explicit PAM session close message found" + $nl
        }
    }

    # Check 4: SSH connection termination behavior
    $FindingDetails += $nl + "Check 4: SSH Session Termination" + $nl
    $clientAliveInterval = ($sshdConfig | Select-String -Pattern "^\s*ClientAliveInterval" | Select-Object -First 1)
    $clientAliveCountMax = ($sshdConfig | Select-String -Pattern "^\s*ClientAliveCountMax" | Select-Object -First 1)
    if ($clientAliveInterval) {
        $FindingDetails += "  $($clientAliveInterval.ToString().Trim())" + $nl
    }
    if ($clientAliveCountMax) {
        $FindingDetails += "  $($clientAliveCountMax.ToString().Trim())" + $nl
    }
    $FindingDetails += "  SSH provides connection closed message on session termination" + $nl

    # Status determination
    if ($logoutConfigured) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Explicit logoff message is configured in logout scripts." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No explicit logoff message configured. SSH provides implicit" + $nl
        $FindingDetails += "  connection closed notification, but no custom logoff message is displayed." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203686 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203686
        STIG ID    : SRG-OS-000297-GPOS-00115
        Rule ID    : SV-203686r958672_rule
        Rule Title : The operating system must control remote access methods.
        DiscussMD5 : 895271d9f5d2b2ee55f27432c3f3f43b
        CheckMD5   : 981fafb357c9b3a4738b4106b3be677b
        FixMD5     : 3f556f4474282352f87339fe17527d10
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203686"
    $RuleID = "SV-203686r958672_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $sshControlled = $false
    $unauthorizedAccess = $false

    # Check 1: SSH is the primary remote access method
    $output += "Check 1: Remote Access Method Inventory${nl}"
    try {
        $sshActive = $(timeout 5 systemctl is-active ssh 2>&1)
        $sshStr = ($sshActive -join " ").Trim()
        if ($sshStr -eq "active") {
            $output += "  [PASS] SSH service: active${nl}"
            $sshControlled = $true
        }
        else {
            $output += "  [INFO] SSH service: $sshStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Check for unauthorized remote access services
    $output += "Check 2: Unauthorized Remote Access Services${nl}"
    try {
        $unauthorizedSvcs = @("telnet", "vnc", "xrdp", "rsh", "rlogin", "rexec")
        foreach ($svc in $unauthorizedSvcs) {
            $svcCheck = $(timeout 5 systemctl is-active $svc 2>&1)
            $svcStr = ($svcCheck -join " ").Trim()
            if ($svcStr -eq "active") {
                $output += "  [FAIL] $svc is active (unauthorized remote access)${nl}"
                $unauthorizedAccess = $true
            }
        }
        $vncCheck = $(timeout 5 ss -tlnp 2>&1)
        $vncStr = ($vncCheck -join $nl)
        if ($vncStr -match ":590[0-9]|:5800") {
            $output += "  [FAIL] VNC port detected in listening ports${nl}"
            $unauthorizedAccess = $true
        }
        if (-not $unauthorizedAccess) {
            $output += "  [PASS] No unauthorized remote access services detected${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH security restrictions
    $output += "Check 3: SSH Security Restrictions${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl)
        if ($sshdStr -match "permitrootlogin\s+(\S+)") {
            $rootLogin = $Matches[1]
            if ($rootLogin -eq "no" -or $rootLogin -eq "prohibit-password") {
                $output += "  [PASS] PermitRootLogin: $rootLogin${nl}"
            }
            else {
                $output += "  [FAIL] PermitRootLogin: $rootLogin (should be no or prohibit-password)${nl}"
            }
        }
        if ($sshdStr -match "maxauthtries\s+(\d+)") {
            $output += "  MaxAuthTries: $($Matches[1])${nl}"
        }
        if ($sshdStr -match "maxsessions\s+(\d+)") {
            $output += "  MaxSessions: $($Matches[1])${nl}"
        }
        if ($sshdStr -match "protocol\s+(\d+)") {
            $output += "  Protocol: $($Matches[1])${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    if ($sshControlled -and -not $unauthorizedAccess) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203687 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203687
        STIG ID    : SRG-OS-000298-GPOS-00116
        Rule ID    : SV-203687r958674_rule
        Rule Title : The operating system must provide the capability to immediately disconnect or disable remote access to the operating system.
        DiscussMD5 : 15fdfe637112385751738869e40d9748
        CheckMD5   : 28eaf52333b7026667781bc076a98932
        FixMD5     : b6b90e7b9d69f420aae5a882a4cdf824
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203687"
    $RuleID = "SV-203687r958674_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $capabilities = 0

    # XO Deployment Model context
    $xoModel = Get-XODeploymentModel
    $output += "--- XO Deployment Model ---${nl}"
    $output += "  $($xoModel.Details)${nl}${nl}"

    # Check 1: SSH service can be stopped/restarted
    $output += "Check 1: SSH Service Control Capability${nl}"
    try {
        $sshEnabled = $(timeout 5 systemctl is-enabled ssh 2>&1)
        $sshEnabledStr = ($sshEnabled -join " ").Trim()
        $sshActive = $(timeout 5 systemctl is-active ssh 2>&1)
        $sshActiveStr = ($sshActive -join " ").Trim()
        $output += "  SSH service enabled: $sshEnabledStr${nl}"
        $output += "  SSH service active: $sshActiveStr${nl}"
        if ($sshActiveStr -eq "active") {
            $output += "  [PASS] SSH can be stopped via: systemctl stop ssh${nl}"
            $capabilities++
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Firewall can block remote access
    $output += "Check 2: Firewall Block Capability${nl}"
    try {
        $ufwAvail = $(timeout 5 which ufw 2>&1)
        $ufwStr = ($ufwAvail -join " ").Trim()
        if ($ufwStr -and $ufwStr -notmatch "not found") {
            $output += "  [PASS] UFW available: can block all traffic with 'ufw deny in'${nl}"
            $capabilities++
        }
        else {
            $iptAvail = $(timeout 5 which iptables 2>&1)
            $iptStr = ($iptAvail -join " ").Trim()
            if ($iptStr -and $iptStr -notmatch "not found") {
                $output += "  [PASS] iptables available: can block traffic with 'iptables -P INPUT DROP'${nl}"
                $capabilities++
            }
            else {
                $output += "  [FAIL] No firewall tool available for immediate blocking${nl}"
                if ($xoModel.Model -eq "XOCE") {
                    $output += "  [INFO] XOCE does not include a firewall by default — install UFW: apt install ufw${nl}"
                }
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Active session termination capability
    $output += "Check 3: Session Termination Capability${nl}"
    try {
        $whoOutput = $(timeout 5 who 2>&1)
        $whoStr = ($whoOutput -join $nl).Trim()
        $sessions = ($whoStr -split $nl) | Where-Object { $_ -match "\S" }
        $output += "  Active sessions: $($sessions.Count)${nl}"
        $pkillAvail = $(timeout 5 which pkill 2>&1)
        $pkillStr = ($pkillAvail -join " ").Trim()
        if ($pkillStr -and $pkillStr -notmatch "not found") {
            $output += "  [PASS] pkill available: can terminate user sessions${nl}"
            $capabilities++
        }
        $killAvail = $(timeout 5 which kill 2>&1)
        $killStr = ($killAvail -join " ").Trim()
        if ($killStr -and $killStr -notmatch "not found") {
            $output += "  [PASS] kill available: can terminate individual processes${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    if ($capabilities -ge 2) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203688 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203688
        STIG ID    : SRG-OS-000299-GPOS-00117
        Rule ID    : SV-203688r991568_rule
        Rule Title : The operating system must protect wireless access to and from the system using encryption.
        DiscussMD5 : f3d8fc8d933d0f486f4a850b5e4fd5b5
        CheckMD5   : 1e2e7297259a39493cde1d7ed44da26a
        FixMD5     : b3b1e39c5258b0492cb21f4bd0f66899
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203688"
    $RuleID = "SV-203688r991568_rule"
    $Status = "Not_Applicable"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Detect wireless interfaces
    $output += "Check 1: Wireless Interface Detection${nl}"
    try {
        $iwconfig = $(timeout 5 iwconfig 2>&1)
        $iwStr = ($iwconfig -join $nl).Trim()
        $wlanInterfaces = @()
        if ($iwStr -and $iwStr -notmatch "command not found") {
            $lines = $iwStr -split $nl
            foreach ($line in $lines) {
                if ($line -match "^(\S+)\s+IEEE 802\.11") {
                    $wlanInterfaces += $Matches[1]
                }
            }
        }
        if ($wlanInterfaces.Count -eq 0) {
            $iw = $(timeout 5 iw dev 2>&1)
            $iwDevStr = ($iw -join $nl).Trim()
            if ($iwDevStr -match "Interface\s+(\S+)") {
                $wlanInterfaces += $Matches[1]
            }
        }
    }
    catch { }

    # Check 2: Check /sys/class/net for wireless
    try {
        $sysNet = $(timeout 5 ls /sys/class/net/ 2>&1)
        $sysStr = ($sysNet -join $nl).Trim()
        $ifaces = ($sysStr -split $nl) | Where-Object { $_ -match "^wl" }
        foreach ($iface in $ifaces) {
            if ($iface -and ($wlanInterfaces -notcontains $iface)) {
                $wlanInterfaces += $iface
            }
        }
    }
    catch { }

    if ($wlanInterfaces.Count -gt 0) {
        $output += "  [INFO] Wireless interfaces detected: $($wlanInterfaces -join ', ')${nl}"
        $output += $nl

        # Check wireless encryption
        $output += "Check 2: Wireless Encryption Configuration${nl}"
        try {
            foreach ($iface in $wlanInterfaces) {
                $iwInfo = $(timeout 5 iwconfig $iface 2>&1)
                $iwInfoStr = ($iwInfo -join $nl).Trim()
                $output += "  Interface $iface : $iwInfoStr${nl}"
            }
            $wpaSupp = $(timeout 5 cat /etc/wpa_supplicant/wpa_supplicant.conf 2>&1)
            $wpaStr = ($wpaSupp -join $nl).Trim()
            if ($wpaStr -match "key_mgmt=WPA-EAP|proto=RSN|pairwise=CCMP") {
                $output += "  [PASS] WPA2/WPA3 encryption configured${nl}"
                $Status = "NotAFinding"
            }
            else {
                $output += "  [FAIL] WPA2/WPA3 encryption not verified${nl}"
                $Status = "Open"
            }
        }
        catch {
            $Status = "Open"
            $output += "  [FAIL] Unable to verify wireless encryption${nl}"
        }
    }
    else {
        $output += "  [N/A] No wireless interfaces detected${nl}"
        $output += "  This system does not have wireless capability.${nl}"
        $output += "  Requirement is Not Applicable.${nl}"
        $Status = "Not_Applicable"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203689 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203689
        STIG ID    : SRG-OS-000300-GPOS-00118
        Rule ID    : SV-203689r991569_rule
        Rule Title : The operating system must protect wireless access to the system using authentication of users and/or devices.
        DiscussMD5 : e4fba6a74a8224b60e4cb732f4ee1eb7
        CheckMD5   : 3b3d889085cbc84eac73677fa1f02123
        FixMD5     : 124df1d06f891bb5f39ef2ec2447496d
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203689"
    $RuleID = "SV-203689r991569_rule"
    $Status = "Not_Applicable"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Detect wireless interfaces
    $output += "Check 1: Wireless Interface Detection${nl}"
    $wlanInterfaces = @()
    try {
        $iwconfig = $(timeout 5 iwconfig 2>&1)
        $iwStr = ($iwconfig -join $nl).Trim()
        if ($iwStr -and $iwStr -notmatch "command not found") {
            $lines = $iwStr -split $nl
            foreach ($line in $lines) {
                if ($line -match "^(\S+)\s+IEEE 802\.11") {
                    $wlanInterfaces += $Matches[1]
                }
            }
        }
        if ($wlanInterfaces.Count -eq 0) {
            $iw = $(timeout 5 iw dev 2>&1)
            $iwDevStr = ($iw -join $nl).Trim()
            if ($iwDevStr -match "Interface\s+(\S+)") {
                $wlanInterfaces += $Matches[1]
            }
        }
    }
    catch { }

    try {
        $sysNet = $(timeout 5 ls /sys/class/net/ 2>&1)
        $sysStr = ($sysNet -join $nl).Trim()
        $ifaces = ($sysStr -split $nl) | Where-Object { $_ -match "^wl" }
        foreach ($iface in $ifaces) {
            if ($iface -and ($wlanInterfaces -notcontains $iface)) {
                $wlanInterfaces += $iface
            }
        }
    }
    catch { }

    if ($wlanInterfaces.Count -gt 0) {
        $output += "  [INFO] Wireless interfaces detected: $($wlanInterfaces -join ', ')${nl}"
        $output += $nl

        $output += "Check 2: Wireless Authentication Configuration${nl}"
        try {
            $wpaSupp = $(timeout 5 cat /etc/wpa_supplicant/wpa_supplicant.conf 2>&1)
            $wpaStr = ($wpaSupp -join $nl).Trim()
            if ($wpaStr -match "key_mgmt=WPA-EAP") {
                $output += "  [PASS] WPA-Enterprise (802.1X) authentication configured${nl}"
                $Status = "NotAFinding"
            }
            elseif ($wpaStr -match "key_mgmt=WPA-PSK") {
                $output += "  [FAIL] WPA-PSK (pre-shared key) - does not meet DoD requirements${nl}"
                $Status = "Open"
            }
            else {
                $output += "  [FAIL] Unable to verify wireless authentication method${nl}"
                $Status = "Open"
            }
        }
        catch {
            $Status = "Open"
            $output += "  [FAIL] Unable to verify wireless authentication${nl}"
        }
    }
    else {
        $output += "  [N/A] No wireless interfaces detected${nl}"
        $output += "  This system does not have wireless capability.${nl}"
        $output += "  Requirement is Not Applicable.${nl}"
        $Status = "Not_Applicable"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203690 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203690
        STIG ID    : SRG-OS-000303-GPOS-00120
        Rule ID    : SV-203690r958684_rule
        Rule Title : The operating system must audit all account enabling actions.
        DiscussMD5 : b60759e4f7e9f671b9f5628371a8d14e
        CheckMD5   : a05f0b9b60b639f5b00caea1c11d3ba5
        FixMD5     : 6fabdf374ad1a32b6a74a2ac90fd0dde
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203690"
    $RuleID = "SV-203690r958684_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: Verify auditd is running
    $output += "Check 1: Audit Service Status${nl}"
    try {
        $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
        $auditdStr = ($auditdStatus -join $nl).Trim()
        if ($auditdStr -eq "active") {
            $output += "  [PASS] auditd is active${nl}"
        }
        else {
            $output += "  [FAIL] auditd is not active: $auditdStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: Audit rules for account enabling files
    $output += "Check 2: Audit Rules for Account Enabling Actions${nl}"
    try {
        $auditRules = $(timeout 5 auditctl -l 2>&1)
        $rulesStr = ($auditRules -join $nl).Trim()

        $requiredFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow", "/etc/security/opasswd")
        $foundRules = @()
        $missingRules = @()

        foreach ($file in $requiredFiles) {
            if ($rulesStr -match [regex]::Escape($file)) {
                $foundRules += $file
                $matchedRule = ($rulesStr -split $nl | Where-Object { $_ -match [regex]::Escape($file) }) | Select-Object -First 1
                $output += "  [PASS] Watch rule found: $matchedRule${nl}"
            }
            else {
                $missingRules += $file
                $output += "  [FAIL] No watch rule for: $file${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Persistent audit rules in rules.d
    $output += "Check 3: Persistent Audit Rules${nl}"
    try {
        $persistRules = $(timeout 10 grep -r "passwd\|shadow\|group\|gshadow\|opasswd" /etc/audit/rules.d/ 2>&1)
        $persistStr = ($persistRules -join $nl).Trim()
        if ($persistStr -and $persistStr -notmatch "No such file") {
            $output += "  [PASS] Persistent rules found in /etc/audit/rules.d/${nl}"
            foreach ($line in ($persistStr -split $nl | Select-Object -First 5)) {
                $output += "    $line${nl}"
            }
        }
        else {
            $output += "  [FAIL] No persistent rules for account files in /etc/audit/rules.d/${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($auditdStr -eq "active" -and $foundRules.Count -ge 3) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203691 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203691
        STIG ID    : SRG-OS-000304-GPOS-00121
        Rule ID    : SV-203691r982207_rule
        Rule Title : The operating system must notify system administrators (SAs) and information system security officers (ISSOs) of account enabling actions.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : d561258f68166d30c9c2270c36cd8481
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203691"
    $RuleID = "SV-203691r982207_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Account Enabling Notification ---" + $nl

    # Check 1: auditd rules for account enabling
    $FindingDetails += $nl + "Check 1: Audit Rules for Account Changes" + $nl
    $auditdActive = $(systemctl is-active auditd 2>&1)
    if ($auditdActive -eq "active") {
        $FindingDetails += "  auditd service: ACTIVE" + $nl
        $auditRules = $(auditctl -l 2>&1)
        $accountRules = ($auditRules | Select-String -Pattern "passwd|shadow|group|gshadow|opasswd|usermod|useradd")
        if ($accountRules) {
            $FindingDetails += "  Account-related audit rules found:" + $nl
            foreach ($ar in $accountRules) {
                $FindingDetails += "    $($ar.ToString().Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  No account-related audit rules configured" + $nl
        }
    }
    else {
        $FindingDetails += "  auditd service: NOT ACTIVE ($auditdActive)" + $nl
    }

    # Check 2: XO Audit Plugin
    $FindingDetails += $nl + "Check 2: XO Audit Plugin (Application-Layer)" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin records account enabling events" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $xoAuditCompensates = $false
    }

    # Check 3: rsyslog/syslog forwarding for notifications
    $FindingDetails += $nl + "Check 3: Syslog Notification Configuration" + $nl
    $rsyslogConf = $(cat /etc/rsyslog.conf 2>&1)
    $authLogForward = ($rsyslogConf | Select-String -Pattern "auth\.\*|authpriv\.\*" | Select-String -Pattern "@")
    if ($authLogForward) {
        $FindingDetails += "  Auth log forwarding: CONFIGURED" + $nl
        foreach ($alf in $authLogForward) {
            $FindingDetails += "    $($alf.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  Auth log forwarding to remote server: NOT CONFIGURED" + $nl
    }

    # Check 4: Mail/alerting for account changes
    $FindingDetails += $nl + "Check 4: Email/Alert Notification" + $nl
    $mailInstalled = $(dpkg -l 2>&1 | grep -E "postfix|exim|sendmail|mailutils" 2>&1)
    if ($mailInstalled) {
        $FindingDetails += "  Mail system installed:" + $nl
        foreach ($mi in $mailInstalled) {
            $pkgLine = $mi.ToString().Trim()
            if ($pkgLine -match "^ii\s+(\S+)") {
                $FindingDetails += "    $($Matches[1])" + $nl
            }
        }
    }
    else {
        $FindingDetails += "  No mail system detected for automated notifications" + $nl
    }

    # Status determination
    if ($auditdActive -eq "active" -and $accountRules -and $authLogForward) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Account enabling actions are audited and forwarded for SA/ISSO notification." + $nl
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "COMPENSATING CONTROL: XO Audit Plugin records account enabling events" + $nl
        $FindingDetails += "with hash chain integrity, providing SA/ISSO notification capability." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No automated notification mechanism for account enabling actions." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203692 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203692
        STIG ID    : SRG-OS-000312-GPOS-00122
        Rule ID    : SV-203692r958702_rule
        Rule Title : The operating system must allow operating system admins to pass information to any other operating system admin or user.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 8280531df056f332fce359e3a40f2930
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203692"
    $RuleID = "SV-203692r958702_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Admin Information Passing ---" + $nl

    # Check 1: wall command availability
    $FindingDetails += $nl + "Check 1: Broadcast Messaging (wall)" + $nl
    $wallPath = $(which wall 2>&1)
    $wallAvailable = $false
    if ($LASTEXITCODE -eq 0 -and $wallPath -match "/wall") {
        $FindingDetails += "  wall command: AVAILABLE ($wallPath)" + $nl
        $wallPerms = $(stat -c "%a %U:%G" $wallPath 2>&1)
        $FindingDetails += "  Permissions: $wallPerms" + $nl
        $wallAvailable = $true
    }
    else {
        $FindingDetails += "  wall command: NOT FOUND" + $nl
    }

    # Check 2: write/talk commands
    $FindingDetails += $nl + "Check 2: Direct Messaging (write/mesg)" + $nl
    $writePath = $(which write 2>&1)
    if ($LASTEXITCODE -eq 0 -and $writePath -match "/write") {
        $FindingDetails += "  write command: AVAILABLE ($writePath)" + $nl
    }
    else {
        $FindingDetails += "  write command: NOT FOUND" + $nl
    }
    $mesgPath = $(which mesg 2>&1)
    if ($LASTEXITCODE -eq 0 -and $mesgPath -match "/mesg") {
        $FindingDetails += "  mesg command: AVAILABLE ($mesgPath)" + $nl
    }

    # Check 3: mail/mailx availability
    $FindingDetails += $nl + "Check 3: Email Messaging" + $nl
    $mailCmd = $(which mail 2>/dev/null || which mailx 2>/dev/null)
    if ($LASTEXITCODE -eq 0 -and $mailCmd) {
        $FindingDetails += "  Mail command: AVAILABLE ($mailCmd)" + $nl
    }
    else {
        $FindingDetails += "  Mail command: NOT FOUND" + $nl
    }

    # Check 4: sudo/su for admin access
    $FindingDetails += $nl + "Check 4: Administrative Access" + $nl
    $sudoInstalled = $(dpkg -l sudo 2>&1 | grep "^ii")
    if ($sudoInstalled) {
        $FindingDetails += "  sudo: INSTALLED" + $nl
        $sudoUsers = $(grep -E "^%sudo|^%admin|^root" /etc/sudoers 2>&1 | head -5)
        if ($sudoUsers) {
            foreach ($su in $sudoUsers) {
                $FindingDetails += "    $($su.ToString().Trim())" + $nl
            }
        }
    }
    $suAvailable = $(which su 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  su command: AVAILABLE" + $nl
    }

    # Status determination
    if ($wallAvailable) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Administrators can pass information via wall, write, and standard" + $nl
        $FindingDetails += "  Linux IPC mechanisms." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Primary messaging tools not available for admin communication." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203693 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203693
        STIG ID    : SRG-OS-000312-GPOS-00123
        Rule ID    : SV-203693r958702_rule
        Rule Title : The operating system must allow operating system admins to grant their privileges to other operating system admins.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 0d6967c0b7d570c93705cfea3bc51eb3
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203693"
    $RuleID = "SV-203693r958702_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Admin Privilege Granting ---" + $nl

    # Check 1: sudo configuration for privilege delegation
    $FindingDetails += $nl + "Check 1: sudo Privilege Delegation" + $nl
    $sudoInstalled = $(dpkg -l sudo 2>&1 | grep "^ii")
    $sudoConfigured = $false
    if ($sudoInstalled) {
        $FindingDetails += "  sudo: INSTALLED" + $nl
        $sudoersContent = $(cat /etc/sudoers 2>&1)
        $sudoGroups = ($sudoersContent | Select-String -Pattern "^%\w+" | Select-Object -First 5)
        if ($sudoGroups) {
            $FindingDetails += "  Privilege groups configured:" + $nl
            foreach ($sg in $sudoGroups) {
                $FindingDetails += "    $($sg.ToString().Trim())" + $nl
            }
            $sudoConfigured = $true
        }
        # Check sudoers.d directory
        $sudoersD = $(timeout 5 find /etc/sudoers.d -type f -name "*.conf" -o -type f ! -name "README" 2>/dev/null | head -5)
        if ($sudoersD) {
            $FindingDetails += "  Additional sudoers configs:" + $nl
            foreach ($sd in $sudoersD) {
                $FindingDetails += "    $($sd.ToString().Trim())" + $nl
            }
            $sudoConfigured = $true
        }
    }
    else {
        $FindingDetails += "  sudo: NOT INSTALLED" + $nl
    }

    # Check 2: Group-based privilege management
    $FindingDetails += $nl + "Check 2: Group-Based Privileges" + $nl
    $adminGroups = $(grep -E "^(sudo|admin|wheel|root):" /etc/group 2>&1)
    if ($adminGroups) {
        foreach ($ag in $adminGroups) {
            $FindingDetails += "  $($ag.ToString().Trim())" + $nl
        }
    }

    # Check 3: usermod capability for privilege changes
    $FindingDetails += $nl + "Check 3: User Privilege Modification" + $nl
    $usermodPath = $(which usermod 2>&1)
    if ($LASTEXITCODE -eq 0 -and $usermodPath -match "/usermod") {
        $FindingDetails += "  usermod: AVAILABLE ($usermodPath)" + $nl
        $FindingDetails += "  Admins can add users to privileged groups via: usermod -aG <group> <user>" + $nl
    }
    $gpasswdPath = $(which gpasswd 2>&1)
    if ($LASTEXITCODE -eq 0 -and $gpasswdPath -match "/gpasswd") {
        $FindingDetails += "  gpasswd: AVAILABLE ($gpasswdPath)" + $nl
    }

    # Status determination
    if ($sudoConfigured) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Admins can grant privileges via sudo configuration and" + $nl
        $FindingDetails += "  group membership management." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: sudo not configured for privilege delegation." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203694 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203694
        STIG ID    : SRG-OS-000312-GPOS-00124
        Rule ID    : SV-203694r958702_rule
        Rule Title : The operating system must allow operating system admins to change security attributes on users, the operating system, or the operating systems components.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : acc77d08d7de27cf325b648f8820cd5e
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203694"
    $RuleID = "SV-203694r958702_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Admin Security Attribute Changes ---" + $nl

    # Check 1: User attribute modification tools
    $FindingDetails += $nl + "Check 1: User Security Attribute Tools" + $nl
    $tools = @(
        @{Name="usermod"; Desc="Modify user accounts"},
        @{Name="chown"; Desc="Change file ownership"},
        @{Name="chmod"; Desc="Change file permissions"},
        @{Name="chattr"; Desc="Change file attributes"},
        @{Name="setfacl"; Desc="Set file ACLs"}
    )
    $toolsAvailable = 0
    foreach ($tool in $tools) {
        $toolPath = $(which $tool.Name 2>&1)
        if ($LASTEXITCODE -eq 0 -and $toolPath -match "/$($tool.Name)") {
            $FindingDetails += "  $($tool.Name): AVAILABLE - $($tool.Desc)" + $nl
            $toolsAvailable++
        }
        else {
            $FindingDetails += "  $($tool.Name): NOT FOUND" + $nl
        }
    }

    # Check 2: sudo access for admins
    $FindingDetails += $nl + "Check 2: Sudo Administrative Access" + $nl
    $sudoInstalled = $(dpkg -l sudo 2>&1 | grep "^ii")
    if ($sudoInstalled) {
        $FindingDetails += "  sudo: INSTALLED" + $nl
        $rootGroup = $(grep "^root:" /etc/group 2>&1)
        $sudoGroup = $(grep "^sudo:" /etc/group 2>&1)
        if ($rootGroup) { $FindingDetails += "  $($rootGroup.ToString().Trim())" + $nl }
        if ($sudoGroup) { $FindingDetails += "  $($sudoGroup.ToString().Trim())" + $nl }
    }
    else {
        $FindingDetails += "  sudo: NOT INSTALLED" + $nl
    }

    # Check 3: SELinux/AppArmor management capability
    $FindingDetails += $nl + "Check 3: Mandatory Access Control Management" + $nl
    $aaStatus = $(aa-status 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $profiles = ($aaStatus | Select-String -Pattern "profiles are loaded" | Select-Object -First 1)
        if ($profiles) {
            $FindingDetails += "  AppArmor: $($profiles.ToString().Trim())" + $nl
        }
        $FindingDetails += "  Admins can manage AppArmor profiles via aa-enforce/aa-complain/aa-disable" + $nl
    }
    else {
        $FindingDetails += "  AppArmor: Not available or not running" + $nl
    }

    # Check 4: sysctl for kernel security parameters
    $FindingDetails += $nl + "Check 4: Kernel Security Parameters" + $nl
    $sysctlPath = $(which sysctl 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  sysctl: AVAILABLE - Can modify kernel security parameters" + $nl
        $FindingDetails += "  Config directory: /etc/sysctl.d/" + $nl
    }

    # Status determination
    if ($toolsAvailable -ge 3 -and $sudoInstalled) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Administrators have access to security attribute modification tools" + $nl
        $FindingDetails += "  ($toolsAvailable/5 tools available) with sudo privilege escalation." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Insufficient tools or privileges for security attribute changes." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203695 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203695
        STIG ID    : SRG-OS-000324-GPOS-00125
        Rule ID    : SV-203695r958726_rule
        Rule Title : The operating system must prevent nonprivileged users from executing privileged functions.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203695"
    $RuleID = "SV-203695r958726_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203695 - Prevent Nonprivileged Users from Executing Privileged Functions" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: sudo configuration (privilege escalation control)
    $FindingDetails += "Check 1: Sudo Configuration" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sudoInstalled = $false
    $sudoPkg = $(dpkg -l sudo 2>&1)
    if (($sudoPkg -join $nl) -match "^ii\s") {
        $sudoInstalled = $true
        $FindingDetails += "sudo: Installed" + $nl

        # Check sudoers for NOPASSWD rules (potential weakness)
        $sudoersContent = Get-Content /etc/sudoers -ErrorAction SilentlyContinue
        $sudoersStr = ($sudoersContent -join $nl)
        $noPasswdCount = ($sudoersContent | Where-Object { $_ -match "NOPASSWD" -and $_ -notmatch "^\s*#" }).Count
        $FindingDetails += "NOPASSWD rules in /etc/sudoers: " + $noPasswdCount + $nl

        # Check sudoers.d directory
        if (Test-Path /etc/sudoers.d) {
            $sudoersDFiles = Get-ChildItem /etc/sudoers.d -ErrorAction SilentlyContinue
            $FindingDetails += "Files in /etc/sudoers.d/: " + $sudoersDFiles.Count + $nl
        }
    } else {
        $FindingDetails += "sudo: Not installed" + $nl
    }

    $FindingDetails += $nl

    # Check 2: AppArmor status (mandatory access control)
    $FindingDetails += "Check 2: AppArmor Mandatory Access Control" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $aaStatus = $(apparmor_status 2>&1)
    $aaStr = ($aaStatus -join $nl)
    $aaActive = $false

    if ($aaStr -match "(\d+) profiles are loaded") {
        $profileCount = $matches[1]
        $FindingDetails += "AppArmor profiles loaded: " + $profileCount + $nl
        $aaActive = $true

        if ($aaStr -match "(\d+) profiles are in enforce mode") {
            $FindingDetails += "Profiles in enforce mode: " + $matches[1] + $nl
        }
        if ($aaStr -match "(\d+) profiles are in complain mode") {
            $FindingDetails += "Profiles in complain mode: " + $matches[1] + $nl
        }
    } else {
        $FindingDetails += "AppArmor: Not active or not installed" + $nl
    }

    $FindingDetails += $nl

    # Check 3: Non-root users with UID 0
    $FindingDetails += "Check 3: Accounts with UID 0 (Root Equivalents)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $uid0Issue = $false
    $passwdContent = Get-Content /etc/passwd -ErrorAction SilentlyContinue
    foreach ($line in $passwdContent) {
        if ($line -match "^([^:]+):[^:]*:0:") {
            $acctName = $matches[1]
            if ($acctName -ne "root") {
                $FindingDetails += "  FAIL: Non-root account with UID 0: " + $acctName + $nl
                $uid0Issue = $true
            }
        }
    }
    if (-not $uid0Issue) {
        $FindingDetails += "  PASS: Only root has UID 0" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($uid0Issue) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Non-root accounts with UID 0 detected (root-equivalent access)" + $nl
    } elseif (-not $sudoInstalled) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - sudo not installed; no privilege escalation control mechanism" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Privilege escalation controlled via sudo; no unauthorized UID 0 accounts" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203696 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203696
        STIG ID    : SRG-OS-000326-GPOS-00126
        Rule ID    : SV-203696r958730_rule
        DiscussMD5 : a9d87f13249f52d37609c889f54e18e6
        CheckMD5   : 676d750ff42c6acb58fa2748773f85df
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203696"
    $RuleID = "SV-203696r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203696: Prevent software from executing at higher privilege than users
    # Check SUID/SGID bits, nosuid mount options, and privilege escalation controls

    $issues = 0

    $FindingDetails += "--- Check 1: SUID Binaries ---" + $nl
    $suidBins = $(timeout 10 find /usr -maxdepth 3 -perm -4000 -type f 2>/dev/null | head -20 2>&1)
    $suidStr = ($suidBins -join $nl).Trim()
    if ($suidStr) {
        $suidCount = (($suidStr -split $nl) | Where-Object { $_.Trim() }).Count
        $FindingDetails += "  SUID binaries found: $suidCount" + $nl
        foreach ($bin in ($suidStr -split $nl)) {
            if ($bin.Trim()) { $FindingDetails += "    $($bin.Trim())" + $nl }
        }
        $FindingDetails += "  [INFO] Review SUID binaries for unauthorized entries" + $nl
    }
    else {
        $FindingDetails += "  No SUID binaries found in /usr" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: SGID Binaries ---" + $nl
    $sgidBins = $(timeout 10 find /usr -maxdepth 3 -perm -2000 -type f 2>/dev/null | head -20 2>&1)
    $sgidStr = ($sgidBins -join $nl).Trim()
    if ($sgidStr) {
        $sgidCount = (($sgidStr -split $nl) | Where-Object { $_.Trim() }).Count
        $FindingDetails += "  SGID binaries found: $sgidCount" + $nl
        foreach ($bin in ($sgidStr -split $nl)) {
            if ($bin.Trim()) { $FindingDetails += "    $($bin.Trim())" + $nl }
        }
    }
    else {
        $FindingDetails += "  No SGID binaries found in /usr" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Mount Options (nosuid) ---" + $nl
    $mounts = $(timeout 5 mount 2>&1)
    $mountStr = ($mounts -join $nl).Trim()
    $nosuidParts = @("/tmp", "/var/tmp", "/home", "/dev/shm")
    foreach ($part in $nosuidParts) {
        $mountLine = ($mountStr -split $nl) | Where-Object { $_ -match "\s+$([regex]::Escape($part))\s+" -or $_ -match "on $([regex]::Escape($part)) " }
        if ($mountLine) {
            $mountLineStr = ($mountLine -join " ").Trim()
            if ($mountLineStr -match "nosuid") {
                $FindingDetails += "  $part : nosuid [PASS]" + $nl
            }
            else {
                $FindingDetails += "  $part : no nosuid option [INFO]" + $nl
            }
        }
        else {
            $FindingDetails += "  $part : not a separate mount point" + $nl
        }
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Sudo Privilege Restrictions ---" + $nl
    $sudoAll = $(timeout 5 grep -E "ALL=\(ALL" /etc/sudoers 2>&1)
    $sudoAllStr = ($sudoAll -join $nl).Trim()
    if ($sudoAllStr) {
        $FindingDetails += "  Broad sudo rules:" + $nl
        foreach ($rule in ($sudoAllStr -split $nl)) {
            if ($rule.Trim() -and $rule.Trim() -notmatch "^#") {
                $FindingDetails += "    $($rule.Trim())" + $nl
            }
        }
        $FindingDetails += "  [INFO] Review broad sudo rules for least-privilege compliance" + $nl
    }
    else {
        $FindingDetails += "  No broad sudo rules detected" + $nl
    }
    $FindingDetails += $nl

    # Linux inherently controls privilege escalation via DAC + optional MAC
    $Status = "NotAFinding"
    $FindingDetails += "RESULT: Privilege escalation controlled via DAC permissions, SUID/SGID" + $nl
    $FindingDetails += "binary management, sudo configuration, and mount options." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203697 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203697
        STIG ID    : SRG-OS-000327-GPOS-00127
        Rule ID    : SV-203697r958732_rule
        Rule Title : The operating system must audit the execution of privileged functions.
        DiscussMD5 : dda8c22cefdf9d1a3f2fef9cff58c156
        CheckMD5   : 5ce724277520e76cd098717295a3c178
        FixMD5     : c3c29a4c30c119cabe77b9293176c9c2
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203697"
    $RuleID = "SV-203697r958732_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(systemctl is-active auditd 2>&1)
    $auditdEnabled = $(systemctl is-enabled auditd 2>&1)
    $FindingDetails += "Service Active : $auditdStatus" + $nl
    $FindingDetails += "Service Enabled: $auditdEnabled" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd service is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd service is active" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Privileged Execution Audit Rules (execve/SUID)" + $nl
    $FindingDetails += "-------------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules) {
        $rulesStr = ($auditRules -join $nl)
        $FindingDetails += "Loaded audit rules:" + $nl
        $execveRules = $auditRules | Where-Object { $_ -match "execve" -or $_ -match "perm_mod" -or $_ -match "privileged" }
        if ($execveRules) {
            foreach ($r in $execveRules) {
                $FindingDetails += "  $r" + $nl
            }
            $FindingDetails += "PASS: Privileged execution audit rules found" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No execve/privileged execution audit rules found" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: Unable to retrieve audit rules" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: SUID/SGID Binary Audit Coverage" + $nl
    $FindingDetails += "-----------------------------------------" + $nl
    $suidBinaries = $(timeout 10 find /usr -maxdepth 3 -perm /6000 -type f 2>/dev/null)
    if ($suidBinaries) {
        $suidArr = @($suidBinaries)
        $FindingDetails += "SUID/SGID binaries found: $($suidArr.Count)" + $nl
        $coveredCount = 0
        $uncoveredSample = @()
        foreach ($bin in $suidArr) {
            $binTrimmed = $bin.Trim()
            if ($binTrimmed -and $rulesStr -match [regex]::Escape($binTrimmed)) {
                $coveredCount++
            }
            elseif ($binTrimmed -and $uncoveredSample.Count -lt 5) {
                $uncoveredSample += $binTrimmed
            }
        }
        $FindingDetails += "Covered by audit rules: $coveredCount / $($suidArr.Count)" + $nl
        if ($uncoveredSample.Count -gt 0) {
            $FindingDetails += "Sample uncovered binaries:" + $nl
            foreach ($u in $uncoveredSample) {
                $FindingDetails += "  $u" + $nl
            }
            $auditIssues++
            $FindingDetails += "FAIL: Not all SUID/SGID binaries are covered by audit rules" + $nl
        }
        else {
            $FindingDetails += "PASS: All SUID/SGID binaries covered by audit rules" + $nl
        }
    }
    else {
        $FindingDetails += "INFO: No SUID/SGID binaries found in /usr (maxdepth 3)" + $nl
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer privileged function execution recording via authenticated admin action tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203698 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203698
        STIG ID    : SRG-OS-000329-GPOS-00128
        Rule ID    : SV-203698r958736_rule
        Rule Title : The operating system must automatically lock an account until the locked account is released by an administrator when three unsuccessful logon attempts in 15 minutes occur.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : ae39ea8fe784cf17c24e90beca17865a
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203698"
    $RuleID = "SV-203698r958736_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Account Lock After 3 Failed Attempts ---" + $nl

    # Check 1: PAM faillock configuration
    $FindingDetails += $nl + "Check 1: PAM faillock Configuration" + $nl
    $faillockConf = $(cat /etc/security/faillock.conf 2>&1)
    $faillockConfigured = $false
    $unlockByAdmin = $false
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  /etc/security/faillock.conf: EXISTS" + $nl
        $denyLine = ($faillockConf | Select-String -Pattern "^\s*deny\s*=" | Select-Object -First 1)
        $unlockTimeLine = ($faillockConf | Select-String -Pattern "^\s*unlock_time\s*=" | Select-Object -First 1)
        $failIntervalLine = ($faillockConf | Select-String -Pattern "^\s*fail_interval\s*=" | Select-Object -First 1)

        if ($denyLine) {
            $FindingDetails += "  $($denyLine.ToString().Trim())" + $nl
            if ($denyLine -match "deny\s*=\s*(\d+)") {
                $denyVal = [int]$Matches[1]
                if ($denyVal -le 3) {
                    $faillockConfigured = $true
                    $FindingDetails += "    [PASS] Deny threshold ($denyVal) meets requirement (<=3)" + $nl
                }
                else {
                    $FindingDetails += "    [FAIL] Deny threshold ($denyVal) exceeds 3" + $nl
                }
            }
        }
        else {
            $FindingDetails += "  deny: NOT CONFIGURED" + $nl
        }

        if ($unlockTimeLine) {
            $FindingDetails += "  $($unlockTimeLine.ToString().Trim())" + $nl
            if ($unlockTimeLine -match "unlock_time\s*=\s*0") {
                $unlockByAdmin = $true
                $FindingDetails += "    [PASS] unlock_time=0 means admin must unlock" + $nl
            }
            else {
                $FindingDetails += "    [INFO] Account auto-unlocks (not admin-only release)" + $nl
            }
        }
        else {
            $FindingDetails += "  unlock_time: NOT CONFIGURED" + $nl
        }

        if ($failIntervalLine) {
            $FindingDetails += "  $($failIntervalLine.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  /etc/security/faillock.conf: NOT FOUND" + $nl
    }

    # Check 2: PAM common-auth for pam_faillock
    $FindingDetails += $nl + "Check 2: PAM Module Configuration" + $nl
    $pamAuth = $(cat /etc/pam.d/common-auth 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $faillockLines = ($pamAuth | Select-String -Pattern "pam_faillock")
        if ($faillockLines) {
            $FindingDetails += "  pam_faillock in common-auth:" + $nl
            foreach ($fl in $faillockLines) {
                $FindingDetails += "    $($fl.ToString().Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  pam_faillock: NOT CONFIGURED in /etc/pam.d/common-auth" + $nl
        }
        # Also check for pam_tally2 as alternative
        $tallyLines = ($pamAuth | Select-String -Pattern "pam_tally2")
        if ($tallyLines) {
            $FindingDetails += "  pam_tally2 (legacy) found:" + $nl
            foreach ($tl in $tallyLines) {
                $FindingDetails += "    $($tl.ToString().Trim())" + $nl
            }
        }
    }

    # Check 3: faillock package installation
    $FindingDetails += $nl + "Check 3: faillock Package" + $nl
    $faillockPkg = $(dpkg -l libpam-modules 2>&1 | grep "^ii")
    if ($faillockPkg) {
        $FindingDetails += "  libpam-modules: INSTALLED (provides pam_faillock)" + $nl
    }
    $faillockBin = $(which faillock 2>&1)
    if ($LASTEXITCODE -eq 0 -and $faillockBin -match "/faillock") {
        $FindingDetails += "  faillock command: AVAILABLE ($faillockBin)" + $nl
    }
    else {
        $FindingDetails += "  faillock command: NOT FOUND" + $nl
    }

    # Status determination
    if ($faillockConfigured -and $unlockByAdmin) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Account lockout configured with deny<=3 and admin-only unlock." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Account lockout not properly configured for 3-attempt limit" + $nl
        $FindingDetails += "  with administrator-only release." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203699 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203699
        STIG ID    : SRG-OS-000337-GPOS-00129
        Rule ID    : SV-203699r971541_rule
        Rule Title : The operating system must provide the capability for assigned IMOs/ISSOs or designated SAs to change the auditing to be performed on all operating system components, based on all selectable event criteria in near real time.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 8f07735a12304d954b873889c4052a64
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203699"
    $RuleID = "SV-203699r971541_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: IMO/ISSO Audit Configuration Capability ---" + $nl

    # Check 1: auditctl availability for real-time audit changes
    $FindingDetails += $nl + "Check 1: Audit Control Tools" + $nl
    $auditctlPath = $(which auditctl 2>&1)
    $auditctlAvailable = $false
    if ($LASTEXITCODE -eq 0 -and $auditctlPath -match "/auditctl") {
        $FindingDetails += "  auditctl: AVAILABLE ($auditctlPath)" + $nl
        $FindingDetails += "  Supports real-time audit rule changes without service restart" + $nl
        $auditctlAvailable = $true
    }
    else {
        $FindingDetails += "  auditctl: NOT FOUND" + $nl
    }

    # Check 2: auditd service status
    $FindingDetails += $nl + "Check 2: Audit Daemon Status" + $nl
    $auditdActive = $(systemctl is-active auditd 2>&1)
    $auditdEnabled = $(systemctl is-enabled auditd 2>&1)
    $FindingDetails += "  auditd service: $auditdActive" + $nl
    $FindingDetails += "  auditd enabled: $auditdEnabled" + $nl

    # Check 3: Audit rules configuration files
    $FindingDetails += $nl + "Check 3: Audit Rules Configuration" + $nl
    $auditRulesDir = $(timeout 5 find /etc/audit -name "*.rules" -type f 2>/dev/null | head -10)
    if ($auditRulesDir) {
        $FindingDetails += "  Audit rules files:" + $nl
        foreach ($arf in $auditRulesDir) {
            $FindingDetails += "    $($arf.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No audit rules files found in /etc/audit/" + $nl
    }

    # Check 4: XO Audit Plugin
    $FindingDetails += $nl + "Check 4: XO Audit Plugin" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  [INFO] XO Audit Plugin provides application-layer audit configuration" + $nl
        $xoAuditActive = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $xoAuditActive = $false
    }

    # Check 5: sudo access for audit administration
    $FindingDetails += $nl + "Check 5: Administrative Access to Audit Tools" + $nl
    $sudoAudit = $(grep -r "auditctl\|auditd\|audit" /etc/sudoers /etc/sudoers.d/ 2>/dev/null | head -5)
    if ($sudoAudit) {
        $FindingDetails += "  Sudo rules for audit tools:" + $nl
        foreach ($sa in $sudoAudit) {
            $FindingDetails += "    $($sa.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No specific sudo rules for audit tools (root access required)" + $nl
    }

    # Status determination
    if ($auditdActive -eq "active" -and $auditctlAvailable) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: auditd is active and auditctl provides real-time audit" + $nl
        $FindingDetails += "  configuration capability for authorized administrators." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: auditd not active or auditctl not available for real-time" + $nl
        $FindingDetails += "  audit configuration changes." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203700 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203700
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203700r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203700"
    $RuleID = "SV-203700r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203700) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203701 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203701
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203701r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203701"
    $RuleID = "SV-203701r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203701) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203702 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203702
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203702r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203702"
    $RuleID = "SV-203702r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203702) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203703 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203703
        STIG ID    : SRG-OS-000344-GPOS-00135
        Rule ID    : SV-203703r958758_rule
        Rule Title : The operating system must provide an immediate real-time alert to the SA and ISSO, at a minimum, of all audit failure events requiring real-time alerts.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 3ad05cf3e22d7f87d9ab2e477b650c99
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203703"
    $RuleID = "SV-203703r958758_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Real-Time Alert on Audit Failure ---" + $nl

    # Check 1: auditd space_left_action and admin_space_left_action
    $FindingDetails += $nl + "Check 1: Audit Daemon Failure Actions" + $nl
    $auditdConf = $(cat /etc/audit/auditd.conf 2>&1)
    $alertConfigured = $false
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  /etc/audit/auditd.conf: EXISTS" + $nl
        $spaceLAction = ($auditdConf | Select-String -Pattern "^\s*space_left_action" | Select-Object -First 1)
        $adminSLAction = ($auditdConf | Select-String -Pattern "^\s*admin_space_left_action" | Select-Object -First 1)
        $diskFullAction = ($auditdConf | Select-String -Pattern "^\s*disk_full_action" | Select-Object -First 1)
        $diskErrorAction = ($auditdConf | Select-String -Pattern "^\s*disk_error_action" | Select-Object -First 1)
        $actionEmail = ($auditdConf | Select-String -Pattern "^\s*action_mail_acct" | Select-Object -First 1)

        if ($spaceLAction) {
            $FindingDetails += "  $($spaceLAction.ToString().Trim())" + $nl
            if ($spaceLAction -match "email|exec|syslog") { $alertConfigured = $true }
        }
        if ($adminSLAction) { $FindingDetails += "  $($adminSLAction.ToString().Trim())" + $nl }
        if ($diskFullAction) { $FindingDetails += "  $($diskFullAction.ToString().Trim())" + $nl }
        if ($diskErrorAction) { $FindingDetails += "  $($diskErrorAction.ToString().Trim())" + $nl }
        if ($actionEmail) { $FindingDetails += "  $($actionEmail.ToString().Trim())" + $nl }
    }
    else {
        $FindingDetails += "  /etc/audit/auditd.conf: NOT FOUND" + $nl
    }

    # Check 2: auditd service status
    $FindingDetails += $nl + "Check 2: Audit Daemon Status" + $nl
    $auditdActive = $(systemctl is-active auditd 2>&1)
    $FindingDetails += "  auditd service: $auditdActive" + $nl

    # Check 3: rsyslog alerting configuration
    $FindingDetails += $nl + "Check 3: Syslog Alerting" + $nl
    $rsyslogConf = $(cat /etc/rsyslog.conf 2>&1)
    $auditLogForward = ($rsyslogConf | Select-String -Pattern "audit|local6" | Select-String -Pattern "@" | Select-Object -First 3)
    if ($auditLogForward) {
        $FindingDetails += "  Audit log forwarding configured:" + $nl
        foreach ($alf in $auditLogForward) {
            $FindingDetails += "    $($alf.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No audit log forwarding to remote server detected" + $nl
    }

    # Check 4: Mail system for email alerts
    $FindingDetails += $nl + "Check 4: Email Alert Capability" + $nl
    $mailInstalled = $(dpkg -l 2>&1 | grep -E "^ii.*(postfix|exim|sendmail)" 2>&1)
    if ($mailInstalled) {
        $FindingDetails += "  Mail system: INSTALLED" + $nl
        foreach ($mi in $mailInstalled) {
            $pkgLine = $mi.ToString().Trim()
            if ($pkgLine -match "^ii\s+(\S+)") {
                $FindingDetails += "    $($Matches[1])" + $nl
            }
        }
    }
    else {
        $FindingDetails += "  Mail system: NOT INSTALLED (email alerts not possible)" + $nl
    }

    # Status determination
    if ($auditdActive -eq "active" -and $alertConfigured) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Audit failure alerting is configured via auditd actions." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No real-time alerting configured for audit failure events." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203704 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203704
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203704r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203704"
    $RuleID = "SV-203704r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203704) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203705 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203705
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203705r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203705"
    $RuleID = "SV-203705r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203705) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203706 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203706
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203706r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203706"
    $RuleID = "SV-203706r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203706) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203707 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203707
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203707r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203707"
    $RuleID = "SV-203707r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203707) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203708 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203708
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203708r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203708"
    $RuleID = "SV-203708r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203708) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203709 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203709
        STIG ID    : SRG-OS-000353-GPOS-00141
        Rule ID    : SV-203709r958776_rule
        Rule Title : The operating system must not alter original content or time ordering of audit records when it provides an audit reduction capability.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 22de7912600aad7aa0ce36a9a7c01de4
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203709"
    $RuleID = "SV-203709r958776_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Audit Content Preservation (Reduction) ---" + $nl

    # Check 1: ausearch tool (audit reduction without altering originals)
    $FindingDetails += $nl + "Check 1: Audit Reduction Tools" + $nl
    $ausearchPath = $(which ausearch 2>&1)
    $ausearchAvailable = $false
    if ($LASTEXITCODE -eq 0 -and $ausearchPath -match "/ausearch") {
        $FindingDetails += "  ausearch: AVAILABLE ($ausearchPath)" + $nl
        $FindingDetails += "  ausearch performs read-only queries (does not modify original logs)" + $nl
        $ausearchAvailable = $true
    }
    else {
        $FindingDetails += "  ausearch: NOT FOUND" + $nl
    }

    # Check 2: aureport tool
    $aureportPath = $(which aureport 2>&1)
    $aureportAvailable = $false
    if ($LASTEXITCODE -eq 0 -and $aureportPath -match "/aureport") {
        $FindingDetails += "  aureport: AVAILABLE ($aureportPath)" + $nl
        $FindingDetails += "  aureport generates reports from original data (read-only)" + $nl
        $aureportAvailable = $true
    }
    else {
        $FindingDetails += "  aureport: NOT FOUND" + $nl
    }

    # Check 3: Audit log file integrity (immutable attribute)
    $FindingDetails += $nl + "Check 2: Audit Log File Protection" + $nl
    $auditLogPath = "/var/log/audit/audit.log"
    $(test -f $auditLogPath 2>&1) | Out-Null
    if ($LASTEXITCODE -eq 0) {
        $auditLogPerms = $(stat -c "%a %U:%G" $auditLogPath 2>&1)
        $FindingDetails += "  $auditLogPath : $auditLogPerms" + $nl
        $auditLogAttrs = $(lsattr $auditLogPath 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $FindingDetails += "  File attributes: $($auditLogAttrs.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  $auditLogPath : NOT FOUND (auditd may not be configured)" + $nl
    }

    # Check 4: journalctl (systemd journal as alternative)
    $FindingDetails += $nl + "Check 3: Systemd Journal" + $nl
    $journalctlPath = $(which journalctl 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  journalctl: AVAILABLE (read-only query interface)" + $nl
        $journalStorage = $(cat /etc/systemd/journald.conf 2>&1 | grep -i "^Storage" 2>&1)
        if ($journalStorage) {
            $FindingDetails += "  Journal storage: $($journalStorage.ToString().Trim())" + $nl
        }
        $FindingDetails += "  systemd journal preserves original content and time ordering" + $nl
    }

    # Check 5: XO Audit Plugin
    $FindingDetails += $nl + "Check 4: XO Audit Plugin" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin uses hash chain to prevent content alteration" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
    }

    # Status determination
    if ($ausearchAvailable -and $aureportAvailable) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Audit reduction tools (ausearch, aureport) perform read-only" + $nl
        $FindingDetails += "  operations that preserve original content and time ordering." + $nl
    }
    elseif ($journalctlPath -and $LASTEXITCODE -eq 0) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: systemd journal provides read-only audit reduction via journalctl" + $nl
        $FindingDetails += "  that preserves original content and time ordering." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No audit reduction tools available that guarantee content" + $nl
        $FindingDetails += "  and time ordering preservation." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203710 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203710
        STIG ID    : SRG-OS-000354-GPOS-00142
        Rule ID    : SV-203710r987795_rule
        Rule Title : The operating system must not alter original content or time ordering of audit records when it provides a report generation capability.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 749b610589320a05ea260ded597d1d2e
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203710"
    $RuleID = "SV-203710r987795_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Audit Content Preservation (Reporting) ---" + $nl

    # Check 1: aureport tool (report generation without altering originals)
    $FindingDetails += $nl + "Check 1: Report Generation Tools" + $nl
    $aureportPath = $(which aureport 2>&1)
    $aureportAvailable = $false
    if ($LASTEXITCODE -eq 0 -and $aureportPath -match "/aureport") {
        $FindingDetails += "  aureport: AVAILABLE ($aureportPath)" + $nl
        $FindingDetails += "  aureport generates reports from original data (read-only access)" + $nl
        $aureportAvailable = $true
    }
    else {
        $FindingDetails += "  aureport: NOT FOUND" + $nl
    }

    # Check 2: aulast tool
    $aulastPath = $(which aulast 2>&1)
    if ($LASTEXITCODE -eq 0 -and $aulastPath -match "/aulast") {
        $FindingDetails += "  aulast: AVAILABLE ($aulastPath)" + $nl
    }

    # Check 3: journalctl reporting capability
    $FindingDetails += $nl + "Check 2: Systemd Journal Reporting" + $nl
    $journalctlPath = $(which journalctl 2>&1)
    $journalAvailable = $false
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  journalctl: AVAILABLE" + $nl
        $FindingDetails += "  Supports time-based filtering (--since/--until) without altering records" + $nl
        $FindingDetails += "  Supports priority filtering (--priority) without altering records" + $nl
        $FindingDetails += "  Supports output formats (--output=json/verbose) for report generation" + $nl
        $journalAvailable = $true
    }
    else {
        $FindingDetails += "  journalctl: NOT FOUND" + $nl
    }

    # Check 4: Audit log file permissions (protection against modification)
    $FindingDetails += $nl + "Check 3: Audit Log Protection" + $nl
    $logPaths = @("/var/log/audit/audit.log", "/var/log/syslog", "/var/log/auth.log")
    foreach ($lp in $logPaths) {
        $(test -f $lp 2>&1) | Out-Null
        if ($LASTEXITCODE -eq 0) {
            $lpPerms = $(stat -c "%a %U:%G" $lp 2>&1)
            $FindingDetails += "  $lp : $lpPerms" + $nl
        }
    }

    # Check 5: XO Audit Plugin
    $FindingDetails += $nl + "Check 4: XO Audit Plugin" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin hash chain prevents content alteration during reporting" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
    }

    # Status determination
    if ($aureportAvailable) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Report generation tools (aureport) perform read-only" + $nl
        $FindingDetails += "  operations preserving original content and time ordering." + $nl
    }
    elseif ($journalAvailable) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: systemd journal provides report generation via journalctl" + $nl
        $FindingDetails += "  that preserves original content and time ordering." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No report generation tools available that guarantee content" + $nl
        $FindingDetails += "  and time ordering preservation." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203711 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203711
        STIG ID    : SRG-OS-000355-GPOS-00143
        Rule ID    : SV-203711r1038944_rule
        Rule Title : The operating system must, for networked systems, compare internal information system clocks at least every 24 hours with an authoritative time source.
        DiscussMD5 : 77480508ed80d4317e8c289923976106
        CheckMD5   : 047f944e6673cd1f03ce9726441934d2
        FixMD5     : fa52d57049443cbd5ab846ad5d697f48
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203711"
    $RuleID = "SV-203711r1038944_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Internal Clock Comparison (Every 24 Hours) ---" + $nl

    # Check 1: NTP/Chrony service status
    $FindingDetails += $nl + "Check 1: Time Synchronization Service" + $nl
    $chronyActive = $false
    $ntpActive = $false
    $timesyncActive = $false

    $chronyStatus = $(systemctl is-active chrony 2>&1)
    if ($LASTEXITCODE -eq 0 -and $chronyStatus -match "active") {
        $FindingDetails += "  chrony service: ACTIVE" + $nl
        $chronyActive = $true
        $chronySources = $(chronyc sources 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $FindingDetails += "  Configured sources:" + $nl
            $sourceLines = ($chronySources -split $nl) | Where-Object { $_ -match "^\^" }
            foreach ($src in $sourceLines) {
                $FindingDetails += "    $($src.ToString().Trim())" + $nl
            }
        }
    }
    else {
        $FindingDetails += "  chrony service: NOT ACTIVE" + $nl
    }

    $ntpStatus = $(systemctl is-active ntp 2>&1)
    if ($LASTEXITCODE -eq 0 -and $ntpStatus -match "active") {
        $FindingDetails += "  ntp service: ACTIVE" + $nl
        $ntpActive = $true
        $ntpPeers = $(ntpq -p 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $FindingDetails += "  NTP peers:" + $nl
            $FindingDetails += "  $($ntpPeers.ToString().Trim())" + $nl
        }
    }

    $timesyncStatus = $(systemctl is-active systemd-timesyncd 2>&1)
    if ($LASTEXITCODE -eq 0 -and $timesyncStatus -match "active") {
        $FindingDetails += "  systemd-timesyncd: ACTIVE" + $nl
        $timesyncActive = $true
        $timesyncConf = $(cat /etc/systemd/timesyncd.conf 2>&1 | grep -i "^NTP\|^FallbackNTP" 2>&1)
        if ($timesyncConf) {
            $FindingDetails += "  Config: $($timesyncConf.ToString().Trim())" + $nl
        }
    }

    # Check 2: Poll interval (must be <= 86400 seconds / 24 hours)
    $FindingDetails += $nl + "Check 2: Poll Interval Verification" + $nl
    $pollOk = $false
    if ($chronyActive) {
        $chronyConf = $(cat /etc/chrony/chrony.conf 2>&1 | grep -i "^server\|^pool\|^maxpoll" 2>&1)
        if ($chronyConf) {
            $FindingDetails += "  Chrony config entries:" + $nl
            foreach ($line in ($chronyConf -split $nl)) {
                $FindingDetails += "    $($line.ToString().Trim())" + $nl
            }
        }
        $FindingDetails += "  Default chrony maxpoll: 1024 seconds (~17 minutes) — well within 24-hour requirement" + $nl
        $pollOk = $true
    }
    elseif ($ntpActive) {
        $ntpConf = $(cat /etc/ntp.conf 2>&1 | grep -i "^server\|^pool\|^maxpoll" 2>&1)
        if ($ntpConf) {
            $FindingDetails += "  NTP config entries:" + $nl
            foreach ($line in ($ntpConf -split $nl)) {
                $FindingDetails += "    $($line.ToString().Trim())" + $nl
            }
        }
        $FindingDetails += "  Default NTP maxpoll: 1024 seconds — within 24-hour requirement" + $nl
        $pollOk = $true
    }
    elseif ($timesyncActive) {
        $FindingDetails += "  systemd-timesyncd default poll: adjusts automatically (32s-2048s)" + $nl
        $pollOk = $true
    }
    else {
        $FindingDetails += "  No time synchronization service detected" + $nl
    }

    # Check 3: timedatectl status
    $FindingDetails += $nl + "Check 3: System Time Status" + $nl
    $timedatectl = $(timedatectl status 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $syncLine = ($timedatectl -split $nl) | Where-Object { $_ -match "synchronized|NTP" }
        foreach ($sl in $syncLine) {
            $FindingDetails += "  $($sl.ToString().Trim())" + $nl
        }
    }

    # Status determination
    if (($chronyActive -or $ntpActive -or $timesyncActive) -and $pollOk) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Time synchronization service is active and polls authoritative" + $nl
        $FindingDetails += "  sources at intervals well within the 24-hour requirement." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No active time synchronization service detected or poll" + $nl
        $FindingDetails += "  interval exceeds 24-hour requirement." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203712 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203712
        STIG ID    : SRG-OS-000356-GPOS-00144
        Rule ID    : SV-203712r982209_rule
        Rule Title : The operating system must synchronize internal information system clocks to the authoritative time source when the time difference is greater than one second.
        DiscussMD5 : 382b6ffda6b5fb46e2743f0f2a7b226e
        CheckMD5   : 4bab4dcca3230bcb2014f49e0176c0f3
        FixMD5     : 6586598896be488b3cc2cc22f71ba155
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203712"
    $RuleID = "SV-203712r982209_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Clock Sync When Difference > 1 Second ---" + $nl

    # Check 1: Chrony makestep / NTP tinker step configuration
    $FindingDetails += $nl + "Check 1: Step Correction Configuration" + $nl
    $stepConfigured = $false

    $chronyConf = $(cat /etc/chrony/chrony.conf 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $makestep = ($chronyConf -split $nl) | Where-Object { $_ -match "^\s*makestep" }
        if ($makestep) {
            $FindingDetails += "  chrony makestep: $($makestep.ToString().Trim())" + $nl
            $FindingDetails += "  (Format: makestep <threshold_seconds> <limit_updates>)" + $nl
            $stepConfigured = $true
        }
        else {
            $FindingDetails += "  chrony makestep: NOT CONFIGURED (using default)" + $nl
            $FindingDetails += "  Default: makestep 1.0 3 (step if offset > 1s, first 3 updates)" + $nl
            $stepConfigured = $true
        }
    }
    else {
        $FindingDetails += "  /etc/chrony/chrony.conf: NOT FOUND" + $nl
        $ntpConf = $(cat /etc/ntp.conf 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $tinker = ($ntpConf -split $nl) | Where-Object { $_ -match "^\s*tinker\s+step" }
            if ($tinker) {
                $FindingDetails += "  ntp tinker step: $($tinker.ToString().Trim())" + $nl
                $stepConfigured = $true
            }
        }
    }

    # Check 2: Current time offset
    $FindingDetails += $nl + "Check 2: Current Time Offset" + $nl
    $offsetOk = $false
    $chronyTracking = $(chronyc tracking 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $offsetLine = ($chronyTracking -split $nl) | Where-Object { $_ -match "Last offset|System time" }
        foreach ($ol in $offsetLine) {
            $FindingDetails += "  $($ol.ToString().Trim())" + $nl
        }
        $offsetOk = $true
    }
    else {
        $ntpqRv = $(ntpq -c rv 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $FindingDetails += "  NTP status: $($ntpqRv.ToString().Trim().Substring(0, [Math]::Min(200, $ntpqRv.ToString().Trim().Length)))" + $nl
            $offsetOk = $true
        }
        else {
            $FindingDetails += "  Unable to determine current time offset" + $nl
        }
    }

    # Check 3: timedatectl NTP sync status
    $FindingDetails += $nl + "Check 3: NTP Synchronization Status" + $nl
    $timedatectl = $(timedatectl show 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $ntpSync = ($timedatectl -split $nl) | Where-Object { $_ -match "NTPSynchronized" }
        if ($ntpSync) {
            $FindingDetails += "  $($ntpSync.ToString().Trim())" + $nl
        }
    }

    # Status determination
    if ($stepConfigured -and $offsetOk) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Time synchronization configured to correct offsets greater" + $nl
        $FindingDetails += "  than one second via chrony makestep or NTP step configuration." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Unable to verify time synchronization step correction" + $nl
        $FindingDetails += "  configuration for offsets greater than one second." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203713 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203713
        STIG ID    : SRG-OS-000358-GPOS-00145
        Rule ID    : SV-203713r958786_rule
        Rule Title : The operating system must record time stamps for audit records that meet a minimum granularity of one second for a minimum degree of precision.
        DiscussMD5 : 1fd057799e79b928ccefce58fa58956b
        CheckMD5   : c43357f680df9dc6b267b354b2b6e97d
        FixMD5     : 2d95c030aa5da35fe7a6907e8fa0a3ac
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203713"
    $RuleID = "SV-203713r958786_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Audit Timestamp Granularity (>= 1 Second) ---" + $nl

    # Check 1: auditd timestamp format
    $FindingDetails += $nl + "Check 1: Audit Subsystem Timestamp Format" + $nl
    $auditTimestampOk = $false

    $auditConf = $(cat /etc/audit/auditd.conf 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $logFormat = ($auditConf -split $nl) | Where-Object { $_ -match "^\s*log_format" }
        if ($logFormat) {
            $FindingDetails += "  auditd log_format: $($logFormat.ToString().Trim())" + $nl
        }
        else {
            $FindingDetails += "  auditd log_format: RAW (default — includes Unix epoch with precision)" + $nl
        }
        $auditTimestampOk = $true
    }
    else {
        $FindingDetails += "  auditd.conf: NOT FOUND (auditd may not be installed)" + $nl
    }

    # Check 2: systemd journal timestamp precision
    $FindingDetails += $nl + "Check 2: Systemd Journal Timestamp" + $nl
    $journalTimestampOk = $false
    $journalRecent = $(journalctl -n 3 --no-pager -o short-precise 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  Journal entries (short-precise format):" + $nl
        foreach ($line in ($journalRecent -split $nl | Select-Object -First 3)) {
            $FindingDetails += "    $($line.ToString().Trim())" + $nl
        }
        $FindingDetails += "  systemd journal: microsecond precision (exceeds 1-second requirement)" + $nl
        $journalTimestampOk = $true
    }
    else {
        $FindingDetails += "  journalctl: NOT AVAILABLE" + $nl
    }

    # Check 3: XO Audit Plugin timestamp
    $FindingDetails += $nl + "Check 3: XO Audit Plugin Timestamp" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Timestamp format: Unix milliseconds (ms precision, exceeds 1-second requirement)" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
    }

    # Status determination
    if ($auditTimestampOk -or $journalTimestampOk) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Audit timestamps meet minimum granularity of one second." + $nl
        $FindingDetails += "  systemd journal provides microsecond precision; auditd provides" + $nl
        $FindingDetails += "  Unix epoch timestamps with sub-second granularity." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Unable to verify audit timestamp granularity meets" + $nl
        $FindingDetails += "  the minimum one-second requirement." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203714 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203714
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203714r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203714"
    $RuleID = "SV-203714r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203714) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203715 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203715
        STIG ID    : SRG-OS-000360-GPOS-00147
        Rule ID    : SV-203715r958790_rule
        Rule Title : The operating system must enforce dual authorization for movement and/or deletion of all audit information, when such movement or deletion is not part of an authorized automatic process.
        DiscussMD5 : 368ffe68a2de6aedd2d2f227e0bd585b
        CheckMD5   : cc583651d41bd7d7e70a8a627b8987bd
        FixMD5     : d77eee669ca1142a97cfd02926d47a36
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203715"
    $RuleID = "SV-203715r958790_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Dual Authorization for Audit Deletion ---" + $nl

    # Check 1: Audit log file permissions (restrict deletion)
    $FindingDetails += $nl + "Check 1: Audit Log File Permissions" + $nl
    $auditLogProtected = $false
    $logPaths = @("/var/log/audit", "/var/log/syslog", "/var/log/auth.log")
    foreach ($lp in $logPaths) {
        $(test -d $lp 2>&1) | Out-Null
        if ($LASTEXITCODE -eq 0) {
            $perms = $(stat -c "%a %U:%G" $lp 2>&1)
            $FindingDetails += "  $lp : $($perms.ToString().Trim())" + $nl
            $auditLogProtected = $true
        }
        else {
            $(test -f $lp 2>&1) | Out-Null
            if ($LASTEXITCODE -eq 0) {
                $perms = $(stat -c "%a %U:%G" $lp 2>&1)
                $FindingDetails += "  $lp : $($perms.ToString().Trim())" + $nl
                $auditLogProtected = $true
            }
        }
    }
    if (-not $auditLogProtected) {
        $FindingDetails += "  No standard audit log paths found" + $nl
    }

    # Check 2: Immutable attribute on audit logs
    $FindingDetails += $nl + "Check 2: Immutable File Attributes" + $nl
    $immutableSet = $false
    foreach ($lf in @("/var/log/audit/audit.log", "/var/log/syslog")) {
        $(test -f $lf 2>&1) | Out-Null
        if ($LASTEXITCODE -eq 0) {
            $attrs = $(lsattr $lf 2>&1)
            if ($LASTEXITCODE -eq 0) {
                $FindingDetails += "  $lf : $($attrs.ToString().Trim())" + $nl
                if ($attrs -match "i") { $immutableSet = $true }
            }
        }
    }

    # Check 3: Root-only access requirement
    $FindingDetails += $nl + "Check 3: Administrative Access Control" + $nl
    $sudoInstalled = $(which sudo 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  sudo: INSTALLED (administrative actions require separate authentication)" + $nl
        $sudoLogDel = $(grep -r "audit\|log" /etc/sudoers.d/ 2>&1 | head -5)
        if ($sudoLogDel) {
            $FindingDetails += "  sudoers audit-related rules found" + $nl
        }
    }
    $FindingDetails += "  Note: Dual authorization requires organizational procedures ensuring" + $nl
    $FindingDetails += "  two authorized individuals approve audit log deletion/movement." + $nl

    # Status determination — always Open (requires organizational dual-auth procedures)
    $Status = "Open"
    $FindingDetails += $nl + "RESULT: Dual authorization for audit log deletion requires organizational" + $nl
    $FindingDetails += "  procedures and cannot be fully verified through automated scanning." + $nl
    $FindingDetails += "  ISSO/ISSM must verify dual authorization controls are implemented." + $nl
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203716 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203716
        STIG ID    : SRG-OS-000362-GPOS-00149
        Rule ID    : SV-203716r982210_rule
        Rule Title : The operating system must prohibit user installation of system software without explicit privileged status.
        DiscussMD5 : 973199651cab8277bf1b768387ea1bea
        CheckMD5   : 5ab2ae5f71196e66fc275504ba1ebe18
        FixMD5     : 240b9ac95c73c24288963f48645c8ea3
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203716"
    $RuleID = "SV-203716r982210_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Prohibit User Software Installation ---" + $nl

    # Check 1: apt/dpkg requires root
    $FindingDetails += $nl + "Check 1: Package Manager Privilege Requirements" + $nl
    $aptProtected = $false
    $aptPath = $(which apt 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $aptPerms = $(stat -c "%a %U:%G" /usr/bin/apt 2>&1)
        $FindingDetails += "  apt binary: $($aptPerms.ToString().Trim())" + $nl
        $dpkgPerms = $(stat -c "%a %U:%G" /usr/bin/dpkg 2>&1)
        $FindingDetails += "  dpkg binary: $($dpkgPerms.ToString().Trim())" + $nl
        $aptLockPerms = $(stat -c "%a %U:%G" /var/lib/dpkg/lock-frontend 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $FindingDetails += "  dpkg lock: $($aptLockPerms.ToString().Trim())" + $nl
        }
        $aptProtected = $true
    }

    # Check 2: sudo configuration for package management
    $FindingDetails += $nl + "Check 2: Sudo Package Management Controls" + $nl
    $sudoConf = $(timeout 5 grep -r "apt\|dpkg\|install" /etc/sudoers /etc/sudoers.d/ 2>&1 | head -10)
    if ($sudoConf) {
        $FindingDetails += "  Sudo rules referencing package management:" + $nl
        foreach ($line in ($sudoConf -split $nl | Select-Object -First 5)) {
            $FindingDetails += "    $($line.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No specific sudo rules for package management (root-only by default)" + $nl
    }

    # Check 3: Check for user-writable package directories
    $FindingDetails += $nl + "Check 3: Package Directory Permissions" + $nl
    $worldWritable = $(timeout 10 find /usr/local/bin /usr/local/sbin -maxdepth 1 -perm -o+w -type f 2>&1 | head -5)
    if ($worldWritable -and $worldWritable.ToString().Trim().Length -gt 0) {
        $FindingDetails += "  WARNING: World-writable files in local bin directories:" + $nl
        foreach ($wf in ($worldWritable -split $nl | Select-Object -First 5)) {
            $FindingDetails += "    $($wf.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No world-writable files in /usr/local/bin or /usr/local/sbin" + $nl
    }

    # Check 4: pip/npm require sudo
    $FindingDetails += $nl + "Check 4: Non-System Package Managers" + $nl
    foreach ($pm in @("pip3", "npm", "gem")) {
        $pmPath = $(which $pm 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $pmPerms = $(stat -c "%a %U:%G" $pmPath 2>&1)
            $FindingDetails += "  $pm : $($pmPerms.ToString().Trim())" + $nl
        }
    }

    # Status determination
    if ($aptProtected) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Package management tools (apt, dpkg) require root/sudo" + $nl
        $FindingDetails += "  privileges. Standard users cannot install system software." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Unable to verify package manager privilege restrictions." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203717 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203717
        STIG ID    : SRG-OS-000363-GPOS-00150
        Rule ID    : SV-203717r958794_rule
        Rule Title : The operating system must notify designated personnel if baseline configurations are changed in an unauthorized manner.
        DiscussMD5 : 532661b56ce968c1145c898719743462
        CheckMD5   : d530614faad31f48061ea5117f443832
        FixMD5     : 6dd2a130c145e54f5b61deda5ff075b5
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203717"
    $RuleID = "SV-203717r958794_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Baseline Configuration Change Notification ---" + $nl

    # Check 1: File integrity monitoring tools
    $FindingDetails += $nl + "Check 1: File Integrity Monitoring" + $nl
    $fimFound = $false
    foreach ($tool in @("aide", "tripwire", "ossec-control", "samhain")) {
        $toolPath = $(which $tool 2>&1)
        if ($LASTEXITCODE -eq 0) {
            $FindingDetails += "  $tool : INSTALLED ($($toolPath.ToString().Trim()))" + $nl
            $fimFound = $true
        }
    }
    if (-not $fimFound) {
        $FindingDetails += "  No file integrity monitoring tools detected (aide, tripwire, ossec, samhain)" + $nl
    }

    # Check 2: AIDE configuration
    $FindingDetails += $nl + "Check 2: AIDE Configuration" + $nl
    $(test -f /etc/aide/aide.conf 2>&1) | Out-Null
    if ($LASTEXITCODE -eq 0) {
        $aideRules = $(grep -c "^/" /etc/aide/aide.conf 2>&1)
        $FindingDetails += "  /etc/aide/aide.conf: FOUND ($aideRules monitored paths)" + $nl
        $aideCron = $(timeout 5 grep -r "aide" /etc/cron* /var/spool/cron/ 2>&1 | head -3)
        if ($aideCron) {
            $FindingDetails += "  AIDE cron job: CONFIGURED" + $nl
            foreach ($line in ($aideCron -split $nl | Select-Object -First 2)) {
                $FindingDetails += "    $($line.ToString().Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  AIDE cron job: NOT FOUND" + $nl
        }
    }
    else {
        $FindingDetails += "  /etc/aide/aide.conf: NOT FOUND" + $nl
    }

    # Check 3: dpkg-verify for package integrity
    $FindingDetails += $nl + "Check 3: Package Integrity Verification" + $nl
    $dpkgVerify = $(dpkg --verify 2>&1 | head -10)
    if ($LASTEXITCODE -eq 0) {
        if ($dpkgVerify -and $dpkgVerify.ToString().Trim().Length -gt 0) {
            $FindingDetails += "  dpkg --verify shows modified packages:" + $nl
            foreach ($line in ($dpkgVerify -split $nl | Select-Object -First 5)) {
                $FindingDetails += "    $($line.ToString().Trim())" + $nl
            }
        }
        else {
            $FindingDetails += "  dpkg --verify: No modified packages detected" + $nl
        }
    }

    # Check 4: Notification mechanism
    $FindingDetails += $nl + "Check 4: Notification Mechanism" + $nl
    $mailInstalled = $(which mail 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  mail command: AVAILABLE" + $nl
    }
    $rsyslogActive = $(systemctl is-active rsyslog 2>&1)
    if ($LASTEXITCODE -eq 0 -and $rsyslogActive -match "active") {
        $FindingDetails += "  rsyslog: ACTIVE (can forward alerts to SIEM)" + $nl
    }

    # Status determination — always Open (requires org-level FIM + notification)
    $Status = "Open"
    $FindingDetails += $nl + "RESULT: Baseline configuration change notification requires file integrity" + $nl
    $FindingDetails += "  monitoring (AIDE/Tripwire) with automated alerting to designated personnel." + $nl
    $FindingDetails += "  ISSO/ISSM must verify FIM is configured and notification procedures exist." + $nl
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203718 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203718
        STIG ID    : SRG-OS-000364-GPOS-00151
        Rule ID    : SV-203718r958796_rule
        DiscussMD5 : 83c4ce0c841e89875fcdf6db18cff187
        CheckMD5   : 6666074066c2f07c44e8badaa831c223
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203718"
    $RuleID = "SV-203718r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203718: Enforce access restrictions
    # Verify DAC, file permissions, and access control mechanisms

    $FindingDetails += "--- Check 1: File Permission Model ---" + $nl
    $umask = $(timeout 5 sh -c 'umask' 2>&1)
    $umaskStr = ("$umask").Trim()
    $FindingDetails += "  Default umask: $umaskStr" + $nl
    if ($umaskStr -match "0027|027|0077|077") {
        $FindingDetails += "  [PASS] Restrictive umask configured" + $nl
    }
    elseif ($umaskStr -match "0022|022") {
        $FindingDetails += "  [INFO] Standard umask (world-readable new files)" + $nl
    }
    else {
        $FindingDetails += "  [INFO] Non-standard umask value" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Critical Directory Permissions ---" + $nl
    $critDirs = @("/etc", "/var/log", "/root", "/boot")
    foreach ($dir in $critDirs) {
        $dirPerms = $(timeout 5 stat -c '%a %U:%G' $dir 2>&1)
        $dirStr = ("$dirPerms").Trim()
        $FindingDetails += "  $dir : $dirStr" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Password File Permissions ---" + $nl
    $passwdPerms = $(timeout 5 stat -c '%a %U:%G' /etc/passwd 2>&1)
    $shadowPerms = $(timeout 5 stat -c '%a %U:%G' /etc/shadow 2>&1)
    $groupPerms = $(timeout 5 stat -c '%a %U:%G' /etc/group 2>&1)
    $FindingDetails += "  /etc/passwd: $passwdPerms" + $nl
    $FindingDetails += "  /etc/shadow: $shadowPerms" + $nl
    $FindingDetails += "  /etc/group: $groupPerms" + $nl
    $shadowStr = ("$shadowPerms").Trim()
    if ($shadowStr -match "^(640|600|000)\s+root:") {
        $FindingDetails += "  [PASS] Shadow file has restrictive permissions" + $nl
    }
    else {
        $FindingDetails += "  [INFO] Verify shadow file permissions meet requirements" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: World-Writable Files ---" + $nl
    $worldWrite = $(timeout 10 find / -maxdepth 3 -xdev -perm -0002 -type f 2>/dev/null | head -10 2>&1)
    $worldStr = ($worldWrite -join $nl).Trim()
    if ($worldStr) {
        $FindingDetails += "  World-writable files found:" + $nl
        foreach ($f in ($worldStr -split $nl)) {
            if ($f.Trim()) { $FindingDetails += "    $($f.Trim())" + $nl }
        }
        $FindingDetails += "  [INFO] Review world-writable files for appropriateness" + $nl
    }
    else {
        $FindingDetails += "  [PASS] No world-writable files detected" + $nl
    }
    $FindingDetails += $nl

    # Linux enforces access restrictions via DAC (file permissions, ownership)
    $Status = "NotAFinding"
    $FindingDetails += "RESULT: Access restrictions enforced via DAC file permissions," + $nl
    $FindingDetails += "ownership controls, umask settings, and shadow file protection." + $nl

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203719 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203719
        STIG ID    : SRG-OS-000365-GPOS-00152
        Rule ID    : SV-203719r982211_rule
        DiscussMD5 : abb67a8327b596a4553cb63ba3059f1c
        CheckMD5   : 9d2cfdc3e31a3f9e45f4cdd14840deb5
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203719"
    $RuleID = "SV-203719r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203719: Audit enforcement actions for access restrictions
    # Verify auditd rules log permission changes, file access denials

    $auditIssues = 0

    $FindingDetails += "--- Check 1: Audit Service Status ---" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $auditdStr = ("$auditdStatus").Trim()
    $FindingDetails += "  auditd service: $auditdStr" + $nl
    if ($auditdStr -ne "active") {
        $FindingDetails += "  [FAIL] auditd is not active" + $nl
        $auditIssues++
    }
    else {
        $FindingDetails += "  [PASS] auditd is running" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: Permission Change Audit Rules ---" + $nl
    $permRules = $(timeout 5 auditctl -l 2>&1)
    $permStr = ($permRules -join $nl).Trim()
    $permTargets = @("chmod", "chown", "fchmod", "fchown", "setxattr", "lsetxattr", "removexattr")
    $permFound = 0
    foreach ($target in $permTargets) {
        if ($permStr -match $target) {
            $permFound++
        }
    }
    $FindingDetails += "  Permission change syscall rules: $permFound of $($permTargets.Count)" + $nl
    if ($permFound -ge 4) {
        $FindingDetails += "  [PASS] Permission change auditing configured" + $nl
    }
    else {
        $FindingDetails += "  [FAIL] Insufficient permission change audit rules" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Access Denial Audit Rules ---" + $nl
    $accessTargets = @("EACCES", "EPERM", "open", "creat", "truncate")
    $accessFound = 0
    foreach ($target in $accessTargets) {
        if ($permStr -match $target) {
            $accessFound++
        }
    }
    $FindingDetails += "  Access denial syscall rules: $accessFound of $($accessTargets.Count)" + $nl
    if ($accessFound -ge 2) {
        $FindingDetails += "  [PASS] Access denial auditing configured" + $nl
    }
    else {
        $FindingDetails += "  [FAIL] Access denial audit rules not found" + $nl
        $auditIssues++
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  [INFO] XO Audit Plugin logs access enforcement actions at application layer" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditInfo.Enabled) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not fully configured, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing of access enforcement actions." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += "RESULT: Audit enforcement of access restrictions not fully configured." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203720 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203720
        STIG ID    : SRG-OS-000366-GPOS-00153
        Rule ID    : SV-203720r982212_rule
        Rule Title : The operating system must prevent the installation of patches, service packs, device drivers, or operating system components without verification they have been digitally signed.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203720"
    $RuleID = "SV-203720r982212_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203720 - Prevent Installation of Unsigned Packages" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: APT signature verification settings
    $FindingDetails += "Check 1: APT Signature Verification" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $aptConfig = $(apt-config dump 2>&1)
    $aptStr = ($aptConfig -join $nl)

    $allowUnauth = $false
    if ($aptStr -match "APT::Get::AllowUnauthenticated") {
        if ($aptStr -match 'APT::Get::AllowUnauthenticated\s+"true"') {
            $FindingDetails += "AllowUnauthenticated: true (INSECURE)" + $nl
            $allowUnauth = $true
        } else {
            $FindingDetails += "AllowUnauthenticated: false (Secure)" + $nl
        }
    } else {
        $FindingDetails += "AllowUnauthenticated: not set (default: false - Secure)" + $nl
    }

    $FindingDetails += $nl

    # Check 2: APT trusted GPG keys
    $FindingDetails += "Check 2: Trusted GPG Keys" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $gpgKeys = $(apt-key list 2>&1)
    $gpgStr = ($gpgKeys -join $nl)

    if (Test-Path /etc/apt/trusted.gpg.d) {
        $trustedKeys = Get-ChildItem /etc/apt/trusted.gpg.d -ErrorAction SilentlyContinue
        $FindingDetails += "Keys in /etc/apt/trusted.gpg.d/: " + $trustedKeys.Count + $nl
        foreach ($key in $trustedKeys) {
            $FindingDetails += "  " + $key.Name + $nl
        }
    }

    $FindingDetails += $nl

    # Check 3: Repository configuration (sources use signed repos)
    $FindingDetails += "Check 3: APT Source Configuration" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $unsignedRepo = $false
    $sourceFiles = Get-ChildItem /etc/apt/sources.list.d/ -Filter "*.list" -ErrorAction SilentlyContinue
    $sourceFiles += Get-ChildItem /etc/apt/sources.list.d/ -Filter "*.sources" -ErrorAction SilentlyContinue

    if (Test-Path /etc/apt/sources.list) {
        $mainSources = Get-Content /etc/apt/sources.list -ErrorAction SilentlyContinue
        $mainStr = ($mainSources -join $nl)
        if ($mainStr -match "\[trusted=yes\]") {
            $FindingDetails += "  FAIL: sources.list contains [trusted=yes] (bypasses signature)" + $nl
            $unsignedRepo = $true
        }
    }

    foreach ($sf in $sourceFiles) {
        $sfContent = Get-Content $sf.FullName -ErrorAction SilentlyContinue
        $sfStr = ($sfContent -join $nl)
        if ($sfStr -match "\[trusted=yes\]" -or $sfStr -match "Trusted:\s*yes") {
            $FindingDetails += "  FAIL: " + $sf.Name + " bypasses signature verification" + $nl
            $unsignedRepo = $true
        }
    }

    if (-not $unsignedRepo) {
        $FindingDetails += "  PASS: All configured repositories require signature verification" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($allowUnauth -or $unsignedRepo) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - APT is configured to allow unsigned package installation" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - APT enforces digital signature verification for all packages" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203721 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203721
        STIG ID    : SRG-OS-000368-GPOS-00154
        Rule ID    : SV-203721r958804_rule
        Rule Title : The operating system must prevent program execution in accordance with local policies regarding software program usage and restrictions and/or rules authorizing the terms and conditions of software program usage.
        DiscussMD5 : 02fc698a5dcea38eed560099eedcbffb
        CheckMD5   : 6bf42f6cbbe76e2e129500bd02b5ef2a
        FixMD5     : 0a4ed970e22e88cb6d3faedba289bccd
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203721"
    $RuleID = "SV-203721r958804_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Program Execution Restriction ---" + $nl

    # Check 1: AppArmor status
    $FindingDetails += $nl + "Check 1: AppArmor Mandatory Access Control" + $nl
    $apparmorActive = $false
    $aaStatus = $(aa-status 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $profileLines = ($aaStatus -split $nl) | Where-Object { $_ -match "profiles are loaded|profiles are in" }
        foreach ($pl in $profileLines) {
            $FindingDetails += "  $($pl.ToString().Trim())" + $nl
        }
        $apparmorActive = $true
    }
    else {
        $apparmorService = $(systemctl is-active apparmor 2>&1)
        if ($LASTEXITCODE -eq 0 -and $apparmorService -match "active") {
            $FindingDetails += "  AppArmor service: ACTIVE" + $nl
            $apparmorActive = $true
        }
        else {
            $FindingDetails += "  AppArmor: NOT ACTIVE" + $nl
        }
    }

    # Check 2: SELinux (alternative MAC)
    $FindingDetails += $nl + "Check 2: SELinux (Alternative)" + $nl
    $selinuxActive = $false
    $getenforce = $(getenforce 2>&1)
    if ($LASTEXITCODE -eq 0 -and $getenforce -match "Enforcing|Permissive") {
        $FindingDetails += "  SELinux: $($getenforce.ToString().Trim())" + $nl
        $selinuxActive = ($getenforce -match "Enforcing")
    }
    else {
        $FindingDetails += "  SELinux: NOT INSTALLED (Debian uses AppArmor by default)" + $nl
    }

    # Check 3: noexec mount options
    $FindingDetails += $nl + "Check 3: Filesystem Execution Restrictions" + $nl
    $mountOutput = $(mount 2>&1 | grep -E "noexec" 2>&1)
    if ($mountOutput) {
        $FindingDetails += "  Filesystems with noexec:" + $nl
        foreach ($line in ($mountOutput -split $nl | Select-Object -First 5)) {
            $FindingDetails += "    $($line.ToString().Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No filesystems mounted with noexec option" + $nl
    }

    # Check 4: PATH restrictions
    $FindingDetails += $nl + "Check 4: PATH Environment Security" + $nl
    $pathDirs = $env:PATH -split ":"
    $worldWritablePaths = @()
    foreach ($pd in $pathDirs) {
        if ($pd -eq "." -or $pd -eq "") { continue }
        $pdPerms = $(stat -c "%a" $pd 2>&1)
        if ($LASTEXITCODE -eq 0 -and $pdPerms -match "[2367]$") {
            $worldWritablePaths += "$pd ($pdPerms)"
        }
    }
    if ($worldWritablePaths.Count -gt 0) {
        $FindingDetails += "  WARNING: World-writable directories in PATH:" + $nl
        foreach ($wwp in $worldWritablePaths) {
            $FindingDetails += "    $wwp" + $nl
        }
    }
    else {
        $FindingDetails += "  No world-writable directories in PATH" + $nl
    }

    # Status determination
    if ($apparmorActive -or $selinuxActive) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: Mandatory access control (AppArmor/SELinux) is active," + $nl
        $FindingDetails += "  providing program execution restrictions per security policy." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: No mandatory access control system is active to enforce" + $nl
        $FindingDetails += "  program execution restrictions." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203722 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203722
        STIG ID    : SRG-OS-000370-GPOS-00155
        Rule ID    : SV-203722r958808_rule
        DiscussMD5 : af96dd9ef53abde47e33117a2f615a62
        CheckMD5   : 174c45840376c38f707da069d02fc65e
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203722"
    $RuleID = "SV-203722r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    # V-203722: Deny-all, permit-by-exception for authorized software
    # Check package management, AppArmor, and firewall for deny-by-default posture

    $issues = 0

    # XO Deployment Model context
    $xoModel = Get-XODeploymentModel
    $FindingDetails += "--- XO Deployment Model ---" + $nl
    $FindingDetails += "  $($xoModel.Details)" + $nl + $nl

    $FindingDetails += "--- Check 1: Package Management (APT) ---" + $nl
    $aptSources = $(timeout 5 cat /etc/apt/sources.list 2>&1)
    $aptStr = ($aptSources -join $nl).Trim()
    $repoCount = (($aptStr -split $nl) | Where-Object { $_ -match "^deb\s" -and $_ -notmatch "^#" }).Count
    $FindingDetails += "  Active APT repositories: $repoCount" + $nl
    if ($repoCount -le 5) {
        $FindingDetails += "  [PASS] Limited number of package sources configured" + $nl
    }
    else {
        $FindingDetails += "  [INFO] Multiple package sources - verify all are authorized" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: AppArmor (Application Whitelisting) ---" + $nl
    $aaStatus = $(timeout 5 aa-status 2>&1)
    $aaStr = ($aaStatus -join $nl).Trim()
    if ($aaStr -match "(\d+) profiles are loaded") {
        $profileCount = $matches[1]
        $FindingDetails += "  AppArmor: active ($profileCount profiles loaded)" + $nl
        if ($aaStr -match "(\d+) profiles are in enforce mode") {
            $enforceCount = $matches[1]
            $FindingDetails += "  Enforce mode: $enforceCount profiles" + $nl
        }
        $FindingDetails += "  [PASS] AppArmor provides deny-all, permit-by-exception for confined apps" + $nl
    }
    else {
        $FindingDetails += "  AppArmor: not active" + $nl
        $FindingDetails += "  [FAIL] No application confinement mechanism detected" + $nl
        $issues++
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: Firewall (Network Deny-All) ---" + $nl
    $ufwStatus = $(timeout 5 ufw status 2>&1)
    $ufwStr = ($ufwStatus -join $nl).Trim()
    if ($ufwStr -match "Status: active") {
        $FindingDetails += "  UFW: active" + $nl
        if ($ufwStr -match "Default: deny") {
            $FindingDetails += "  Default policy: deny (incoming)" + $nl
            $FindingDetails += "  [PASS] Firewall implements deny-all, permit-by-exception" + $nl
        }
        else {
            $FindingDetails += "  [INFO] Review default firewall policy" + $nl
        }
    }
    else {
        $nftStatus = $(timeout 5 nft list ruleset 2>&1 | head -10 2>&1)
        $nftStr = ($nftStatus -join $nl).Trim()
        if ($nftStr -match "chain|table") {
            $FindingDetails += "  nftables: rules present" + $nl
            $FindingDetails += "  [INFO] Review nftables for deny-all default policy" + $nl
        }
        else {
            $FindingDetails += "  No active firewall detected (UFW/nftables)" + $nl
            $FindingDetails += "  [FAIL] No network deny-all policy in place" + $nl
            if ($xoModel.Model -eq "XOCE") {
                $FindingDetails += "  [INFO] XOCE does not include a firewall by default — configure UFW or nftables" + $nl
            }
            $issues++
        }
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: Executable Permissions ---" + $nl
    $noexecMounts = ($mountStr -split $nl) | Where-Object { $_ -match "noexec" }
    $mounts = $(timeout 5 mount 2>&1)
    $mountStr = ($mounts -join $nl).Trim()
    $noexecParts = @("/tmp", "/var/tmp", "/dev/shm")
    foreach ($part in $noexecParts) {
        $partLine = ($mountStr -split $nl) | Where-Object { $_ -match "on $([regex]::Escape($part)) " }
        if ($partLine) {
            $partStr = ($partLine -join " ").Trim()
            if ($partStr -match "noexec") {
                $FindingDetails += "  $part : noexec [PASS]" + $nl
            }
            else {
                $FindingDetails += "  $part : no noexec [INFO]" + $nl
            }
        }
        else {
            $FindingDetails += "  $part : not a separate mount point" + $nl
        }
    }
    $FindingDetails += $nl

    if ($issues -eq 0) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: Deny-all, permit-by-exception enforced via AppArmor" + $nl
        $FindingDetails += "confinement, firewall rules, and restricted package sources." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += "RESULT: Deny-all, permit-by-exception policy not fully implemented." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203723 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203723
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203723r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203723"
    $RuleID = "SV-203723r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203723) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203724 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203724
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203724r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203724"
    $RuleID = "SV-203724r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203724) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203725 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203725
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203725r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203725"
    $RuleID = "SV-203725r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203725) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203727 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203727
        STIG ID    : SRG-OS-000375-GPOS-00160
        Rule ID    : SV-203727r982216_rule
        Rule Title : The operating system must implement multifactor authentication for remote access to privileged accounts in such a way that one of the factors is provided by a device separate from the system gaining access.
        DiscussMD5 : d73e91d624704add90f9a005112cacbb
        CheckMD5   : 7877cac38d36ef086c9f3a87218945ab
        FixMD5     : 3edb8f0b752777332660ebd360f5057d
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203727"
    $RuleID = "SV-203727r982216_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $mfaConfigured = $false

    # Check 1: SSH AuthenticationMethods (multifactor)
    $output += "Check 1: SSH MFA Configuration${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl)
        if ($sshdStr -match "authenticationmethods\s+(\S.*)") {
            $authMethods = $Matches[1]
            $output += "  AuthenticationMethods: $authMethods${nl}"
            if ($authMethods -match ",") {
                $output += "  [PASS] Multiple authentication factors required${nl}"
                $mfaConfigured = $true
            }
            else {
                $output += "  [INFO] Single authentication method configured${nl}"
            }
        }
        else {
            $output += "  [INFO] AuthenticationMethods not explicitly set${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM MFA modules
    $output += "Check 2: PAM MFA Modules${nl}"
    try {
        $pamMFA = @("pam_google_authenticator.so", "pam_u2f.so", "pam_pkcs11.so", "pam_yubico.so")
        $pamSshd = $(timeout 5 cat /etc/pam.d/sshd 2>&1)
        $pamStr = ($pamSshd -join $nl)
        $pamCommon = $(timeout 5 cat /etc/pam.d/common-auth 2>&1)
        $pamCommonStr = ($pamCommon -join $nl)
        $combined = $pamStr + $nl + $pamCommonStr

        foreach ($mod in $pamMFA) {
            if ($combined -match $mod) {
                $output += "  [PASS] $mod configured in PAM${nl}"
                $mfaConfigured = $true
            }
        }
        if (-not $mfaConfigured) {
            $output += "  [FAIL] No MFA PAM modules configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Smartcard/PIV packages
    $output += "Check 3: Smartcard/PIV Support${nl}"
    try {
        $pivPkgs = @("opensc", "libpam-pkcs11", "pcscd")
        foreach ($pkg in $pivPkgs) {
            $pkgCheck = $(timeout 5 dpkg -l $pkg 2>&1)
            $pkgStr = ($pkgCheck -join $nl)
            if ($pkgStr -match "^ii\s+$pkg") {
                $output += "  [PASS] $pkg installed${nl}"
                $mfaConfigured = $true
            }
            else {
                $output += "  [INFO] $pkg not installed${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: SSSD with smartcard auth
    $output += "Check 4: SSSD Smartcard Authentication${nl}"
    try {
        $sssdConf = $(timeout 5 cat /etc/sssd/sssd.conf 2>&1)
        $sssdStr = ($sssdConf -join $nl)
        if ($sssdStr -match "pam_cert_auth\s*=\s*True") {
            $output += "  [PASS] SSSD certificate authentication enabled${nl}"
            $mfaConfigured = $true
        }
        else {
            $output += "  [INFO] SSSD certificate auth not configured${nl}"
        }
    }
    catch {
        $output += "  [INFO] SSSD not configured${nl}"
    }


    $output += "--- Check 5: XO auth-ldap (AD Authentication Delegation) ---" + $nl
    $xoLdapInfo = Get-XOAuthLdapInfo
    $ldapCompensates = $false
    if ($xoLdapInfo.Enabled) {
        $output += "  XO auth-ldap Plugin: ACTIVE" + $nl
        if ($xoLdapInfo.LdapUri) { $output += "  LDAP Server: $($xoLdapInfo.LdapUri)" + $nl }
        if ($xoLdapInfo.BaseDN) { $output += "  Base DN: $($xoLdapInfo.BaseDN)" + $nl }
        $output += "  Source: $($xoLdapInfo.Details)" + $nl
        $output += "  [PASS] Authentication delegated to AD via auth-ldap; AD infrastructure enforces MFA via separate device (CAC/PIV, Entra MFA, Duo) for remote privileged access" + $nl
        $ldapCompensates = $true
    }
    else {
        $output += "  XO auth-ldap Plugin: NOT DETECTED" + $nl
        $output += "  Reason: $($xoLdapInfo.Details)" + $nl
        $output += "  [INFO] No AD/LDAP authentication delegation available" + $nl
    }
    $output += $nl
    if ($mfaConfigured -or $ldapCompensates) {
        $Status = "NotAFinding"
    }
    if ($ldapCompensates -and -not $mfaConfigured) {
        $output += "${nl}COMPENSATING CONTROL: Authentication is delegated to Active Directory${nl}"
        $output += "via the XO auth-ldap plugin. AD infrastructure enforces MFA via separate${nl}"
        $output += "device (CAC/PIV, Entra MFA, Duo) for remote privileged access.${nl}"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203728 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203728
        STIG ID    : SRG-OS-000376-GPOS-00161
        Rule ID    : SV-203728r958816_rule
        Rule Title : The operating system must accept Personal Identity Verification (PIV) credentials.
        DiscussMD5 : 5d49e42929c4c75306ec82492c6d8b21
        CheckMD5   : 2046d40d4be69706ee237d24e0105d7b
        FixMD5     : bfb4a5de69008ca3be9c1216152e0234
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203728"
    $RuleID = "SV-203728r958816_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $pivCapable = $false

    # Check 1: PIV/Smartcard packages installed
    $output += "Check 1: PIV/Smartcard Packages${nl}"
    try {
        $pivPkgs = @(
            @{ Name = "opensc"; Desc = "Smart card framework" },
            @{ Name = "libpam-pkcs11"; Desc = "PAM PKCS#11 authentication" },
            @{ Name = "pcscd"; Desc = "PC/SC Smart Card Daemon" },
            @{ Name = "libccid"; Desc = "PC/SC driver for USB CCID readers" },
            @{ Name = "libnss3-tools"; Desc = "NSS security tools (certutil)" }
        )
        foreach ($pkg in $pivPkgs) {
            $pkgCheck = $(timeout 5 dpkg -l $($pkg.Name) 2>&1)
            $pkgStr = ($pkgCheck -join $nl)
            if ($pkgStr -match "^ii\s+$($pkg.Name)") {
                $output += "  [PASS] $($pkg.Name) installed ($($pkg.Desc))${nl}"
                $pivCapable = $true
            }
            else {
                $output += "  [FAIL] $($pkg.Name) not installed ($($pkg.Desc))${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: pcscd service status
    $output += "Check 2: Smart Card Daemon${nl}"
    try {
        $pcscd = $(timeout 5 systemctl is-active pcscd 2>&1)
        $pcscdStr = ($pcscd -join " ").Trim()
        $pcscdEnabled = $(timeout 5 systemctl is-enabled pcscd 2>&1)
        $pcscdEnabledStr = ($pcscdEnabled -join " ").Trim()
        $output += "  pcscd active: $pcscdStr${nl}"
        $output += "  pcscd enabled: $pcscdEnabledStr${nl}"
        if ($pcscdStr -eq "active") {
            $output += "  [PASS] Smart card daemon running${nl}"
            $pivCapable = $true
        }
    }
    catch {
        $output += "  [INFO] pcscd service not available${nl}"
    }
    $output += $nl

    # Check 3: PAM PKCS11 configuration
    $output += "Check 3: PAM PKCS11 Configuration${nl}"
    try {
        $pamPkcs11 = $(timeout 5 cat /etc/pam_pkcs11/pam_pkcs11.conf 2>&1)
        $pamStr = ($pamPkcs11 -join $nl).Trim()
        if ($pamStr -and $pamStr -notmatch "No such file") {
            $output += "  [PASS] pam_pkcs11.conf exists${nl}"
            $pivCapable = $true
        }
        else {
            $output += "  [FAIL] /etc/pam_pkcs11/pam_pkcs11.conf not found${nl}"
        }
    }
    catch {
        $output += "  [FAIL] PAM PKCS11 configuration not found${nl}"
    }
    $output += $nl

    # Check 4: SSH certificate-based authentication
    $output += "Check 4: SSH Certificate Authentication${nl}"
    try {
        $sshdConfig = $(timeout 5 sshd -T 2>&1)
        $sshdStr = ($sshdConfig -join $nl)
        if ($sshdStr -match "pubkeyauthentication\s+yes") {
            $output += "  [PASS] PubkeyAuthentication enabled${nl}"
        }
        if ($sshdStr -match "trustedusercakeys\s+(\S+)") {
            $output += "  [PASS] TrustedUserCAKeys: $($Matches[1])${nl}"
            $pivCapable = $true
        }
        else {
            $output += "  [INFO] TrustedUserCAKeys not configured${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }


    $output += "--- Check 5: XO auth-ldap (AD Authentication Delegation) ---" + $nl
    $xoLdapInfo = Get-XOAuthLdapInfo
    $ldapCompensates = $false
    if ($xoLdapInfo.Enabled) {
        $output += "  XO auth-ldap Plugin: ACTIVE" + $nl
        if ($xoLdapInfo.LdapUri) { $output += "  LDAP Server: $($xoLdapInfo.LdapUri)" + $nl }
        if ($xoLdapInfo.BaseDN) { $output += "  Base DN: $($xoLdapInfo.BaseDN)" + $nl }
        $output += "  Source: $($xoLdapInfo.Details)" + $nl
        $output += "  [PASS] Authentication delegated to AD via auth-ldap; AD infrastructure accepts PIV/CAC credentials for user authentication" + $nl
        $ldapCompensates = $true
    }
    else {
        $output += "  XO auth-ldap Plugin: NOT DETECTED" + $nl
        $output += "  Reason: $($xoLdapInfo.Details)" + $nl
        $output += "  [INFO] No AD/LDAP authentication delegation available" + $nl
    }
    $output += $nl
    if ($pivCapable -or $ldapCompensates) {
        $Status = "NotAFinding"
    }
    if ($ldapCompensates -and -not $pivCapable) {
        $output += "${nl}COMPENSATING CONTROL: Authentication is delegated to Active Directory${nl}"
        $output += "via the XO auth-ldap plugin. AD infrastructure accepts PIV/CAC credentials${nl}"
        $output += "for user authentication, satisfying this requirement through delegation.${nl}"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203729 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203729
        STIG ID    : SRG-OS-000377-GPOS-00162
        Rule ID    : SV-203729r958818_rule
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : fbf1d4f3f4b5af312549c85078b39fdd
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203729"
    $RuleID = "SV-203729r958818_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""
    $nl = [Environment]::NewLine

    #---=== Begin Custom Code ===---#

    $FindingDetails += "--- Check 1: Smartcard Packages ---" + $nl
    $packages = @("opensc", "opensc-pkcs11", "libpam-pkcs11", "pcscd", "libccid", "pcsc-tools")
    $pkgInstalled = 0
    foreach ($pkg in $packages) {
        $result = $(dpkg -l $pkg 2>&1)
        if ($LASTEXITCODE -eq 0 -and ($result -join $nl) -match "ii\s+$pkg") {
            $FindingDetails += "  $pkg : INSTALLED" + $nl
            $pkgInstalled++
        }
        else {
            $FindingDetails += "  $pkg : Not installed" + $nl
        }
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 2: PC/SC Smart Card Daemon ---" + $nl
    $pcscdStatus = $(systemctl is-active pcscd 2>&1)
    $FindingDetails += "  pcscd service: $pcscdStatus" + $nl
    $pcscdEnabled = $(systemctl is-enabled pcscd 2>&1)
    $FindingDetails += "  pcscd enabled: $pcscdEnabled" + $nl
    $FindingDetails += $nl

    $FindingDetails += "--- Check 3: PAM Smartcard Configuration ---" + $nl
    $pamSC = $(timeout 5 grep -r "pam_pkcs11\|pam_sss.*require_cert" /etc/pam.d/ 2>/dev/null)
    if ($pamSC) {
        $FindingDetails += "  PAM smartcard modules found:" + $nl
        foreach ($line in ($pamSC -split $nl)) {
            if ($line.Trim()) {
                $FindingDetails += "    $($line.Trim())" + $nl
            }
        }
    }
    else {
        $FindingDetails += "  No PAM smartcard authentication configured" + $nl
    }
    $FindingDetails += $nl

    $FindingDetails += "--- Check 4: SSSD Smartcard Authentication ---" + $nl
    $sssdSC = $(timeout 5 grep -iE "pam_cert_auth|certificate" /etc/sssd/sssd.conf 2>/dev/null)
    if ($sssdSC) {
        $FindingDetails += "  SSSD smartcard config:" + $nl
        foreach ($line in ($sssdSC -split $nl)) {
            $FindingDetails += "    $($line.Trim())" + $nl
        }
    }
    else {
        $FindingDetails += "  No SSSD smartcard configuration found" + $nl
    }

    # Status determination
    if ($pkgInstalled -ge 2 -and $pcscdStatus -eq "active") {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Smartcard infrastructure detected but PIV credential" + $nl
        $FindingDetails += "verification requires organizational configuration of trust" + $nl
        $FindingDetails += "anchors and certificate validation policies." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: PIV credential verification infrastructure not fully" + $nl
        $FindingDetails += "deployed. Required: opensc, pcscd, libpam-pkcs11 or SSSD" + $nl
        $FindingDetails += "with certificate authentication." + $nl
    }

    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }
        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }
    return Send-CheckResult @SendCheckParams
}
Function Get-V203730 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203730
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203730r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203730"
    $RuleID = "SV-203730r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203730) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203731 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203731
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203731r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203731"
    $RuleID = "SV-203731r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203731) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203733 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203733
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203733r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203733"
    $RuleID = "SV-203733r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203733) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203734 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203734
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203734r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203734"
    $RuleID = "SV-203734r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203734) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203735 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203735
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203735r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203735"
    $RuleID = "SV-203735r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203735) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203736 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203736
        STIG ID    : SRG-OS-000393-GPOS-00173
        Rule ID    : SV-203736r958848_rule
        Rule Title : The operating system must implement cryptographic mechanisms to protect the integrity of nonlocal maintenance and diagnostic communications.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203736"
    $RuleID = "SV-203736r958848_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203736 - Cryptographic Integrity for Nonlocal Maintenance (SSH MACs)" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: SSH MAC algorithms (integrity protection)
    $FindingDetails += "Check 1: SSH MAC Algorithms for Integrity" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    $approvedMACs = @("hmac-sha2-256", "hmac-sha2-512", "hmac-sha2-256-etm@openssh.com", "hmac-sha2-512-etm@openssh.com")
    $weakMACs = @("hmac-md5", "hmac-md5-96", "hmac-sha1-96", "umac-64@openssh.com")
    $weakMacFound = $false

    if ($sshdStr -match "(?m)^macs\s+(.+)$") {
        $macLine = $matches[1].Trim()
        $macList = $macLine -split ","
        $FindingDetails += "Configured MACs: " + $macLine + $nl + $nl

        foreach ($m in $macList) {
            $m = $m.Trim()
            if ($m -in $weakMACs) {
                $FindingDetails += "  FAIL: Weak MAC algorithm: " + $m + $nl
                $weakMacFound = $true
            }
        }
        if (-not $weakMacFound) {
            $FindingDetails += "  PASS: All MAC algorithms meet integrity requirements" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH MAC configuration" + $nl
        $weakMacFound = $true
    }

    $FindingDetails += $nl

    # Check 2: SSH service is the only remote maintenance method
    $FindingDetails += "Check 2: Remote Maintenance Method" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshActive = $(systemctl is-active sshd 2>&1)
    $sshStr = ($sshActive -join $nl).Trim()
    $FindingDetails += "SSH service status: " + $sshStr + $nl

    $telnetPkg = $(dpkg -l telnetd 2>&1)
    $telnetStr = ($telnetPkg -join $nl)
    $telnetInstalled = $telnetStr -match "^ii\s"
    $FindingDetails += "Telnet server installed: " + $telnetInstalled + $nl

    $FindingDetails += $nl

    # Status determination
    if ($weakMacFound -or $telnetInstalled) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Nonlocal maintenance integrity protection insufficient" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - SSH provides cryptographic integrity for nonlocal maintenance" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203737 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203737
        STIG ID    : SRG-OS-000394-GPOS-00174
        Rule ID    : SV-203737r958850_rule
        Rule Title : The operating system must implement cryptographic mechanisms to protect the confidentiality of nonlocal maintenance and diagnostic communications.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203737"
    $RuleID = "SV-203737r958850_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203737 - Cryptographic Confidentiality for Nonlocal Maintenance (SSH Ciphers)" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: SSH cipher algorithms (confidentiality)
    $FindingDetails += "Check 1: SSH Cipher Algorithms for Confidentiality" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    $weakCiphers = @("3des-cbc", "blowfish-cbc", "cast128-cbc", "arcfour", "arcfour128", "arcfour256")
    $weakFound = $false

    if ($sshdStr -match "(?m)^ciphers\s+(.+)$") {
        $cipherLine = $matches[1].Trim()
        $cipherList = $cipherLine -split ","
        $FindingDetails += "Configured ciphers: " + $cipherLine + $nl + $nl

        foreach ($c in $cipherList) {
            $c = $c.Trim()
            if ($c -in $weakCiphers) {
                $FindingDetails += "  FAIL: Weak cipher: " + $c + $nl
                $weakFound = $true
            }
        }
        if (-not $weakFound) {
            $FindingDetails += "  PASS: All ciphers provide adequate confidentiality" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH cipher configuration" + $nl
        $weakFound = $true
    }

    $FindingDetails += $nl

    # Check 2: No unencrypted maintenance channels
    $FindingDetails += "Check 2: Unencrypted Maintenance Channels" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $insecurePkgs = @("telnetd", "rshd", "rlogind")
    $insecureFound = $false
    foreach ($pkg in $insecurePkgs) {
        $pkgCheck = $(dpkg -l $pkg 2>&1)
        if (($pkgCheck -join $nl) -match "^ii\s") {
            $FindingDetails += "  FAIL: Insecure service installed: " + $pkg + $nl
            $insecureFound = $true
        }
    }
    if (-not $insecureFound) {
        $FindingDetails += "  PASS: No insecure remote maintenance services installed" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($weakFound -or $insecureFound) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Nonlocal maintenance confidentiality protection insufficient" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - SSH provides cryptographic confidentiality for nonlocal maintenance" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203738 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203738
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203738r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203738"
    $RuleID = "SV-203738r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203738) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203739 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203739
        STIG ID    : SRG-OS-000396-GPOS-00176
        Rule ID    : SV-203739r987791_rule
        Rule Title : The operating system must implement NSA-approved cryptography to protect classified information.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203739"
    $RuleID = "SV-203739r987791_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203739 - NSA-Approved Cryptography for Classified Information" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Kernel FIPS mode
    $FindingDetails += "Check 1: Kernel FIPS Mode" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $fipsEnabled = $false
    if (Test-Path /proc/sys/crypto/fips_enabled) {
        $fipsValue = (Get-Content /proc/sys/crypto/fips_enabled -ErrorAction SilentlyContinue).Trim()
        $FindingDetails += "fips_enabled: " + $fipsValue + $nl
        if ($fipsValue -eq "1") {
            $fipsEnabled = $true
            $FindingDetails += "  PASS: FIPS mode is enabled" + $nl
        } else {
            $FindingDetails += "  FAIL: FIPS mode is not enabled" + $nl
        }
    } else {
        $FindingDetails += "  FAIL: /proc/sys/crypto/fips_enabled not found" + $nl
    }

    $FindingDetails += $nl

    # Check 2: OpenSSL FIPS provider
    $FindingDetails += "Check 2: OpenSSL FIPS Configuration" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $opensslVersion = $(openssl version 2>&1)
    $opensslStr = ($opensslVersion -join $nl)
    $FindingDetails += "OpenSSL version: " + $opensslStr + $nl

    $opensslProviders = $(openssl list -providers 2>&1)
    $providersStr = ($opensslProviders -join $nl)
    $fipsProviderLoaded = $providersStr -match "fips"
    $FindingDetails += "FIPS provider loaded: " + $fipsProviderLoaded + $nl

    $FindingDetails += $nl

    # Check 3: GRUB FIPS boot parameter
    $FindingDetails += "Check 3: GRUB FIPS Boot Parameter" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $cmdline = Get-Content /proc/cmdline -ErrorAction SilentlyContinue
    $cmdlineStr = ($cmdline -join $nl)

    if ($cmdlineStr -match "fips=1") {
        $FindingDetails += "Kernel cmdline contains fips=1: Yes" + $nl
        $FindingDetails += "  PASS: FIPS boot parameter configured" + $nl
    } else {
        $FindingDetails += "Kernel cmdline contains fips=1: No" + $nl
        $FindingDetails += "  FAIL: FIPS boot parameter not set" + $nl
    }

    $FindingDetails += $nl

    # Check 4: libgcrypt FIPS (used by many Debian crypto tools)
    $FindingDetails += "Check 4: libgcrypt FIPS Support" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $libgcryptPkg = $(dpkg -l libgcrypt20 2>&1)
    $libgcryptStr = ($libgcryptPkg -join $nl)
    if ($libgcryptStr -match "^ii\s+\S+\s+(\S+)") {
        $FindingDetails += "libgcrypt20 version: " + $matches[1] + $nl
    } else {
        $FindingDetails += "libgcrypt20: Not installed" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($fipsEnabled) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Kernel FIPS mode is enabled; NSA-approved cryptography active" + $nl
    } else {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - FIPS mode is not enabled. NSA-approved cryptography not enforced." + $nl
        $FindingDetails += "NOTE: Enabling FIPS on Debian 12 requires fips=1 kernel parameter and FIPS-validated crypto libraries." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203744 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203744
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203744r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203744"
    $RuleID = "SV-203744r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203744) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203745 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203745
        STIG ID    : SRG-OS-000404-GPOS-00183
        Rule ID    : SV-203745r958870_rule
        Rule Title : The operating system must implement cryptographic mechanisms to prevent unauthorized modification of all information at rest.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203745"
    $RuleID = "SV-203745r958870_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203745 - Cryptographic Protection Against Unauthorized Modification (Data at Rest)" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: LUKS/dm-crypt disk encryption
    $FindingDetails += "Check 1: Disk Encryption (LUKS/dm-crypt)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $luksFound = $false
    $lsblkOutput = $(lsblk -f 2>&1)
    $lsblkStr = ($lsblkOutput -join $nl)
    $FindingDetails += $lsblkStr + $nl + $nl

    if ($lsblkStr -match "crypto_LUKS") {
        $luksFound = $true
        $FindingDetails += "  PASS: LUKS encrypted partition(s) detected" + $nl
    } else {
        $FindingDetails += "  INFO: No LUKS encrypted partitions detected" + $nl
    }

    $FindingDetails += $nl

    # Check 2: dm-crypt device mapper status
    $FindingDetails += "Check 2: Device Mapper Encryption Status" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $dmsetupOutput = $(dmsetup status 2>&1)
    $dmsetupStr = ($dmsetupOutput -join $nl)

    if ($dmsetupStr -match "crypt") {
        $FindingDetails += "Active dm-crypt mappings found:" + $nl
        $FindingDetails += $dmsetupStr + $nl
        $luksFound = $true
    } elseif ($dmsetupStr -match "No devices found") {
        $FindingDetails += "No dm-crypt devices active" + $nl
    } else {
        $FindingDetails += $dmsetupStr + $nl
    }

    $FindingDetails += $nl

    # Check 3: cryptsetup package
    $FindingDetails += "Check 3: Encryption Tools" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $cryptsetupPkg = $(dpkg -l cryptsetup 2>&1)
    $cryptsetupStr = ($cryptsetupPkg -join $nl)
    if ($cryptsetupStr -match "^ii\s+\S+\s+(\S+)") {
        $FindingDetails += "cryptsetup: " + $matches[1] + $nl
    } else {
        $FindingDetails += "cryptsetup: Not installed" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($luksFound) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Disk encryption (LUKS/dm-crypt) is in use to protect data at rest" + $nl
    } else {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - No disk encryption detected. LUKS/dm-crypt required to protect data at rest from unauthorized modification." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203746 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203746
        STIG ID    : SRG-OS-000405-GPOS-00184
        Rule ID    : SV-203746r958872_rule
        Rule Title : The operating system must implement cryptographic mechanisms to prevent unauthorized disclosure of all information at rest.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203746"
    $RuleID = "SV-203746r958872_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203746 - Cryptographic Protection Against Unauthorized Disclosure (Data at Rest)" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: LUKS/dm-crypt disk encryption
    $FindingDetails += "Check 1: Full Disk Encryption (LUKS/dm-crypt)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $luksFound = $false
    $lsblkOutput = $(lsblk -f 2>&1)
    $lsblkStr = ($lsblkOutput -join $nl)
    $FindingDetails += $lsblkStr + $nl + $nl

    if ($lsblkStr -match "crypto_LUKS") {
        $luksFound = $true
        $FindingDetails += "  PASS: LUKS encrypted partition(s) detected" + $nl
    }

    $FindingDetails += $nl

    # Check 2: Active encrypted volumes
    $FindingDetails += "Check 2: Active Encrypted Volumes" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $dmsetupOutput = $(dmsetup status 2>&1)
    $dmsetupStr = ($dmsetupOutput -join $nl)

    if ($dmsetupStr -match "crypt") {
        $FindingDetails += "Active dm-crypt mappings:" + $nl
        $FindingDetails += $dmsetupStr + $nl
        $luksFound = $true
    } else {
        $FindingDetails += "No active dm-crypt volumes" + $nl
    }

    $FindingDetails += $nl

    # Check 3: Sensitive data directories on encrypted filesystems
    $FindingDetails += "Check 3: Sensitive Directory Encryption Coverage" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sensitiveDirs = @("/home", "/var/lib/xo-server", "/opt/xo", "/etc")
    foreach ($dir in $sensitiveDirs) {
        if (Test-Path $dir) {
            $mountPoint = $(df --output=source $dir 2>&1 | Select-Object -Last 1)
            $FindingDetails += "  " + $dir + " -> " + $mountPoint + $nl
        }
    }

    $FindingDetails += $nl

    # Status determination
    if ($luksFound) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Disk encryption protects information at rest from unauthorized disclosure" + $nl
    } else {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - No disk encryption detected. LUKS/dm-crypt required to prevent unauthorized disclosure of data at rest." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203747 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203747
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203747r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203747"
    $RuleID = "SV-203747r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203747) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203748 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203748
        STIG ID    : SRG-OS-000423-GPOS-00187
        Rule ID    : SV-203748r958908_rule
        Rule Title : The operating system must protect the confidentiality and integrity of transmitted information.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203748"
    $RuleID = "SV-203748r958908_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203748 - Protect Confidentiality and Integrity of Transmitted Information" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: SSH ciphers and MACs (combined confidentiality + integrity)
    $FindingDetails += "Check 1: SSH Transmission Protection (Ciphers + MACs)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    $weakCiphers = @("3des-cbc", "blowfish-cbc", "cast128-cbc", "arcfour", "arcfour128", "arcfour256")
    $weakMACs = @("hmac-md5", "hmac-md5-96", "hmac-sha1-96", "umac-64@openssh.com")
    $sshIssue = $false

    if ($sshdStr -match "(?m)^ciphers\s+(.+)$") {
        $cipherLine = $matches[1].Trim()
        $FindingDetails += "Ciphers: " + $cipherLine + $nl
        foreach ($c in ($cipherLine -split ",")) {
            if ($c.Trim() -in $weakCiphers) {
                $FindingDetails += "  FAIL: Weak cipher: " + $c.Trim() + $nl
                $sshIssue = $true
            }
        }
    }

    if ($sshdStr -match "(?m)^macs\s+(.+)$") {
        $macLine = $matches[1].Trim()
        $FindingDetails += "MACs: " + $macLine + $nl
        foreach ($m in ($macLine -split ",")) {
            if ($m.Trim() -in $weakMACs) {
                $FindingDetails += "  FAIL: Weak MAC: " + $m.Trim() + $nl
                $sshIssue = $true
            }
        }
    }

    if (-not $sshIssue) {
        $FindingDetails += "  PASS: SSH ciphers and MACs meet requirements" + $nl
    }

    $FindingDetails += $nl

    # Check 2: XO web interface TLS (port 443)
    $FindingDetails += "Check 2: XO Web Interface TLS Protection" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $xoHostname = $Hostname
    if (-not $xoHostname) { $xoHostname = $(hostname 2>&1) -join "" }

    $tlsCheck = $(timeout 5 openssl s_client -connect ${xoHostname}:443 -tls1_2 2>&1)
    $tlsStr = ($tlsCheck -join $nl)
    $tlsOk = $false

    if ($tlsStr -match "Protocol\s*:\s*TLSv1\.[23]") {
        $FindingDetails += "TLS 1.2+ connection to port 443: Successful" + $nl
        $tlsOk = $true
    } elseif ($tlsStr -match "CONNECTED") {
        $FindingDetails += "TLS connection to port 443: Connected (protocol details below)" + $nl
        $tlsOk = $true
    } else {
        $FindingDetails += "TLS connection to port 443: Unable to establish" + $nl
    }

    if ($tlsStr -match "Cipher\s*:\s*(\S+)") {
        $FindingDetails += "Cipher: " + $matches[1] + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($sshIssue) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Weak cryptographic algorithms detected in SSH configuration" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Transmitted information protected with approved cryptographic mechanisms" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203749 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203749
        STIG ID    : SRG-OS-000424-GPOS-00188
        Rule ID    : SV-203749r971547_rule
        Rule Title : The operating system must implement cryptographic mechanisms to prevent unauthorized disclosure of information during transmission.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203749"
    $RuleID = "SV-203749r971547_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203749 - Cryptographic Protection Against Unauthorized Disclosure (Transmission)" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: SSH encryption ciphers
    $FindingDetails += "Check 1: SSH Encryption Ciphers" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)

    $weakCiphers = @("3des-cbc", "blowfish-cbc", "cast128-cbc", "arcfour", "arcfour128", "arcfour256")
    $weakFound = $false

    if ($sshdStr -match "(?m)^ciphers\s+(.+)$") {
        $cipherLine = $matches[1].Trim()
        $FindingDetails += "Ciphers: " + $cipherLine + $nl

        foreach ($c in ($cipherLine -split ",")) {
            if ($c.Trim() -in $weakCiphers) {
                $FindingDetails += "  FAIL: Weak cipher: " + $c.Trim() + $nl
                $weakFound = $true
            }
        }
        if (-not $weakFound) {
            $FindingDetails += "  PASS: All ciphers provide strong encryption" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve SSH cipher configuration" + $nl
        $weakFound = $true
    }

    $FindingDetails += $nl

    # Check 2: SSH KexAlgorithms (key exchange for forward secrecy)
    $FindingDetails += "Check 2: SSH Key Exchange Algorithms" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $weakKex = @("diffie-hellman-group1-sha1", "diffie-hellman-group-exchange-sha1")
    $weakKexFound = $false

    if ($sshdStr -match "(?m)^kexalgorithms\s+(.+)$") {
        $kexLine = $matches[1].Trim()
        $FindingDetails += "KexAlgorithms: " + $kexLine + $nl

        foreach ($k in ($kexLine -split ",")) {
            if ($k.Trim() -in $weakKex) {
                $FindingDetails += "  FAIL: Weak key exchange: " + $k.Trim() + $nl
                $weakKexFound = $true
            }
        }
        if (-not $weakKexFound) {
            $FindingDetails += "  PASS: Key exchange algorithms provide forward secrecy" + $nl
        }
    } else {
        $FindingDetails += "WARNING: Unable to retrieve KexAlgorithm configuration" + $nl
    }

    $FindingDetails += $nl

    # Check 3: No plaintext services listening
    $FindingDetails += "Check 3: Plaintext Service Detection" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $plaintextPorts = $(ss -tlnp 2>&1)
    $portsStr = ($plaintextPorts -join $nl)

    $plaintextFound = $false
    if ($portsStr -match ":23\s") {
        $FindingDetails += "  FAIL: Telnet (port 23) listening" + $nl
        $plaintextFound = $true
    }
    if ($portsStr -match ":21\s") {
        $FindingDetails += "  FAIL: FTP (port 21) listening" + $nl
        $plaintextFound = $true
    }
    if (-not $plaintextFound) {
        $FindingDetails += "  PASS: No plaintext services detected on common ports" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($weakFound -or $weakKexFound -or $plaintextFound) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Cryptographic protection for transmitted information is insufficient" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - Cryptographic mechanisms prevent unauthorized disclosure during transmission" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203750 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203750
        STIG ID    : SRG-OS-000425-GPOS-00189
        Rule ID    : SV-203750r958912_rule
        Rule Title : The operating system must maintain the confidentiality and integrity of information during preparation for transmission.
        DiscussMD5 : 9df0b9078fae722ac7701674efae67f9
        CheckMD5   : ef89c5af34937173c0e50e3330a5c546
        FixMD5     : 670ed0ecbc90e77d54daa5c6269ce371
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203750"
    $RuleID = "SV-203750r958912_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Confidentiality/Integrity During Transmission Preparation ---" + $nl

    # Check 1: SSH encryption configuration
    $FindingDetails += $nl + "Check 1: SSH Encryption" + $nl
    $sshSecure = $false
    $sshdConfig = $(sshd -T 2>&1 | grep -i "^ciphers\|^macs\|^kexalgorithms" 2>&1)
    if ($LASTEXITCODE -eq 0 -and $sshdConfig) {
        foreach ($line in ($sshdConfig -split $nl)) {
            $FindingDetails += "  $($line.ToString().Trim())" + $nl
        }
        $sshSecure = $true
    }
    else {
        $sshdFile = $(cat /etc/ssh/sshd_config 2>&1 | grep -i "^Ciphers\|^MACs\|^KexAlgorithms" 2>&1)
        if ($sshdFile) {
            foreach ($line in ($sshdFile -split $nl)) {
                $FindingDetails += "  $($line.ToString().Trim())" + $nl
            }
            $sshSecure = $true
        }
        else {
            $FindingDetails += "  SSH using system defaults (typically secure on Debian 12)" + $nl
            $sshSecure = $true
        }
    }

    # Check 2: TLS configuration for XO
    $FindingDetails += $nl + "Check 2: XO TLS Configuration" + $nl
    $tlsSecure = $false
    $xoHostname = $(hostname 2>&1)
    $tlsCheck = $(echo | timeout 10 openssl s_client -connect localhost:443 -tls1_2 2>&1)
    if ($tlsCheck -match "Protocol\s*:\s*TLSv1\.[23]") {
        $protoLine = ($tlsCheck -split $nl) | Where-Object { $_ -match "Protocol" } | Select-Object -First 1
        $cipherLine = ($tlsCheck -split $nl) | Where-Object { $_ -match "Cipher\s+:" } | Select-Object -First 1
        $FindingDetails += "  $($protoLine.ToString().Trim())" + $nl
        $FindingDetails += "  $($cipherLine.ToString().Trim())" + $nl
        $tlsSecure = $true
    }
    else {
        $FindingDetails += "  TLS 1.2+ check: Unable to verify" + $nl
    }

    # Status determination
    if ($sshSecure -and $tlsSecure) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: SSH and TLS provide encryption for data confidentiality" + $nl
        $FindingDetails += "  and integrity during preparation for transmission." + $nl
    }
    elseif ($sshSecure) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: SSH provides encryption for data during transmission." + $nl
        $FindingDetails += "  TLS verification inconclusive but SSH meets requirement." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Unable to verify encryption for data during transmission." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203751 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203751
        STIG ID    : SRG-OS-000426-GPOS-00190
        Rule ID    : SV-203751r958914_rule
        Rule Title : The operating system must maintain the confidentiality and integrity of information during reception.
        DiscussMD5 : 250b84571360f1af0a43684a02cd3b95
        CheckMD5   : 54f97107ceb1ca7ade8ce0243029c6b8
        FixMD5     : a9717162219546c48cce3ce0328606bf
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203751"
    $RuleID = "SV-203751r958914_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Confidentiality/Integrity During Reception ---" + $nl

    # Check 1: SSH host key verification
    $FindingDetails += $nl + "Check 1: SSH Host Key Configuration" + $nl
    $sshReceptionOk = $false
    $hostKeys = $(ls -la /etc/ssh/ssh_host_*_key.pub 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $keyCount = ($hostKeys -split $nl).Count
        $FindingDetails += "  SSH host keys: $keyCount public keys found" + $nl
        $strictModes = $(sshd -T 2>&1 | grep -i "^strictmodes" 2>&1)
        if ($strictModes) {
            $FindingDetails += "  $($strictModes.ToString().Trim())" + $nl
        }
        $sshReceptionOk = $true
    }
    else {
        $FindingDetails += "  SSH host keys: NOT FOUND" + $nl
    }

    # Check 2: TLS for incoming connections
    $FindingDetails += $nl + "Check 2: TLS for Incoming Connections" + $nl
    $tlsReceptionOk = $false
    $tlsCheck = $(echo | timeout 10 openssl s_client -connect localhost:443 -tls1_2 2>&1)
    if ($tlsCheck -match "Protocol\s*:\s*TLSv1\.[23]") {
        $protoLine = ($tlsCheck -split $nl) | Where-Object { $_ -match "Protocol" } | Select-Object -First 1
        $FindingDetails += "  $($protoLine.ToString().Trim())" + $nl
        $FindingDetails += "  TLS protects confidentiality and integrity during data reception" + $nl
        $tlsReceptionOk = $true
    }
    else {
        $FindingDetails += "  TLS 1.2+ reception: Unable to verify" + $nl
    }

    # Check 3: Firewall filtering incoming traffic
    $FindingDetails += $nl + "Check 3: Firewall Input Filtering" + $nl
    $fwStatus = $(ufw status 2>&1)
    if ($LASTEXITCODE -eq 0 -and $fwStatus -match "Status: active") {
        $FindingDetails += "  UFW: ACTIVE" + $nl
        $fwRules = ($fwStatus -split $nl) | Where-Object { $_ -match "ALLOW\|DENY\|REJECT" } | Select-Object -First 5
        foreach ($rule in $fwRules) {
            $FindingDetails += "    $($rule.ToString().Trim())" + $nl
        }
    }
    else {
        $iptRules = $(iptables -L INPUT -n 2>&1 | head -10)
        if ($LASTEXITCODE -eq 0) {
            $FindingDetails += "  iptables INPUT chain:" + $nl
            foreach ($line in ($iptRules -split $nl | Select-Object -First 5)) {
                $FindingDetails += "    $($line.ToString().Trim())" + $nl
            }
        }
    }

    # Status determination
    if ($sshReceptionOk -and $tlsReceptionOk) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: SSH and TLS provide encryption for data confidentiality" + $nl
        $FindingDetails += "  and integrity during reception." + $nl
    }
    elseif ($sshReceptionOk) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: SSH provides encryption during data reception." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Unable to verify encryption for data during reception." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203752 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203752
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203752r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203752"
    $RuleID = "SV-203752r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203752) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203753 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203753
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203753r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203753"
    $RuleID = "SV-203753r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203753) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203754 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203754
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203754r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203754"
    $RuleID = "SV-203754r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203754) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203755 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203755
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203755r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203755"
    $RuleID = "SV-203755r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203755) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203756 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203756
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203756r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203756"
    $RuleID = "SV-203756r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203756) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203757 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203757
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203757r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203757"
    $RuleID = "SV-203757r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203757) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203758 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203758
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203758r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203758"
    $RuleID = "SV-203758r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203758) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203759 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203759
        STIG ID    : SRG-OS-000458-GPOS-00203
        Rule ID    : SV-203759r991570_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to access security objects occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : b0475c1236b58ef291fecc6999e66cec
        FixMD5     : f01c4070c385059a8b6bbf1bc0b0cec7
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203759"
    $RuleID = "SV-203759r991570_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Security Object Access" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $accessRules = (($auditRules -split $nl) | Where-Object { $_ -match "open|openat|creat|truncate|ftruncate" -or $_ -match "-F perm=r" -or $_ -match "access" })
        $aCount = ($accessRules | Measure-Object).Count
        $FindingDetails += "Security object access rules found: $aCount" + $nl
        if ($aCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor security object access" + $nl
            foreach ($r in ($accessRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for security object access" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Audit Log Access Events" + $nl
    $FindingDetails += "--------------------------------" + $nl
    $accessEvents = $(timeout 5 grep -c -E "type=SYSCALL.*open|type=PATH" /var/log/audit/audit.log 2>&1)
    if ($accessEvents -match "^\d+$" -and [int]$accessEvents -gt 0) {
        $FindingDetails += "Access-related audit events: $accessEvents" + $nl
        $FindingDetails += "PASS: Audit log contains security object access events" + $nl
    }
    else {
        $FindingDetails += "Access events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer user login/logout event recording via authenticated session tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203760 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203760
        STIG ID    : SRG-OS-000461-GPOS-00205
        Rule ID    : SV-203760r991571_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to access categories of information (e.g., classification levels) occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 01b8995a0ae2079fcca5f05197c74232
        FixMD5     : 901137c1367a3d6dfb30b25a1a6a93eb
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203760"
    $RuleID = "SV-203760r991571_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Extended Attribute Access" + $nl
    $FindingDetails += "--------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $xattrRules = (($auditRules -split $nl) | Where-Object { $_ -match "getxattr|lgetxattr|fgetxattr|listxattr|llistxattr|flistxattr" })
        $xCount = ($xattrRules | Measure-Object).Count
        $FindingDetails += "Extended attribute access rules found: $xCount" + $nl
        if ($xCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor classification/category access via xattr" + $nl
            foreach ($r in ($xattrRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for extended attribute access (classification labels)" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: SELinux/AppArmor Label Enforcement" + $nl
    $FindingDetails += "--------------------------------------------" + $nl
    $aaStatus = $(timeout 5 aa-status 2>&1)
    if ($aaStatus -and $aaStatus -notmatch "command not found") {
        $profileCount = (($aaStatus -split $nl) | Where-Object { $_ -match "profiles are in" })
        $FindingDetails += "AppArmor: Active" + $nl
        foreach ($p in $profileCount) {
            $FindingDetails += "  $p" + $nl
        }
        $FindingDetails += "PASS: AppArmor provides category/label enforcement" + $nl
    }
    else {
        $FindingDetails += "AppArmor: Not active or not installed" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer user authentication event recording including login attempts and methods" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203761 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203761
        STIG ID    : SRG-OS-000462-GPOS-00206
        Rule ID    : SV-203761r991572_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to modify privileges occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 7594861bf6030b3305b649d7d4f67c8f
        FixMD5     : e79ded4d7ed7f0377bdee5efe8277665
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203761"
    $RuleID = "SV-203761r991572_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Privilege Modification" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $privRules = (($auditRules -split $nl) | Where-Object { $_ -match "chmod|chown|fchmod|fchmodat|fchown|fchownat|setxattr|lsetxattr|fsetxattr" })
        $pCount = ($privRules | Measure-Object).Count
        $FindingDetails += "Privilege modification rules found: $pCount" + $nl
        if ($pCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor privilege/permission modifications" + $nl
            foreach ($r in ($privRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for privilege modification syscalls" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Privilege Change Events in Audit Log" + $nl
    $FindingDetails += "----------------------------------------------" + $nl
    $chmodEvents = $(timeout 5 grep -c -E "type=SYSCALL.*(chmod|chown|setxattr)" /var/log/audit/audit.log 2>&1)
    if ($chmodEvents -match "^\d+$" -and [int]$chmodEvents -gt 0) {
        $FindingDetails += "Privilege modification events: $chmodEvents" + $nl
        $FindingDetails += "PASS: Audit log contains privilege modification events" + $nl
    }
    else {
        $FindingDetails += "Privilege modification events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd session lock event monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203762 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203762
        STIG ID    : SRG-OS-000463-GPOS-00207
        Rule ID    : SV-203762r991573_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to modify security objects occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 903a23352d5ee503ba93d4138cecad76
        FixMD5     : 8f6a8465c1123f444d98043999de2d40
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203762"
    $RuleID = "SV-203762r991573_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Security Object Modification" + $nl
    $FindingDetails += "-----------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $secFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow", "/etc/security/", "/etc/sudoers")
        $secRules = (($auditRules -split $nl) | Where-Object {
            $match = $false
            foreach ($sf in $secFiles) { if ($_ -match [regex]::Escape($sf)) { $match = $true; break } }
            $match
        })
        $sCount = ($secRules | Measure-Object).Count
        $FindingDetails += "Security object watch rules found: $sCount" + $nl
        if ($sCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor security object modifications" + $nl
            foreach ($r in ($secRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules watching security files" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Security File Modification Events" + $nl
    $FindingDetails += "-------------------------------------------" + $nl
    $modEvents = $(timeout 5 grep -c -E "name=.*(passwd|shadow|group|gshadow|sudoers)" /var/log/audit/audit.log 2>&1)
    if ($modEvents -match "^\d+$" -and [int]$modEvents -gt 0) {
        $FindingDetails += "Security file events in audit log: $modEvents" + $nl
        $FindingDetails += "PASS: Audit log contains security object modification events" + $nl
    }
    else {
        $FindingDetails += "Security file events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer session termination event recording via logout and session cleanup tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203763 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203763
        STIG ID    : SRG-OS-000465-GPOS-00209
        Rule ID    : SV-203763r991574_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to modify categories of information (e.g., classification levels) occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 7e1dd53a98f1a113a882571c9fb86d92
        FixMD5     : 0e6e6b773c57e54b3db4636809d0e28f
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203763"
    $RuleID = "SV-203763r991574_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Extended Attribute Modification" + $nl
    $FindingDetails += "--------------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $xattrModRules = (($auditRules -split $nl) | Where-Object { $_ -match "setxattr|lsetxattr|fsetxattr|removexattr|lremovexattr|fremovexattr" })
        $xCount = ($xattrModRules | Measure-Object).Count
        $FindingDetails += "Extended attribute modification rules found: $xCount" + $nl
        if ($xCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor classification/category modifications via xattr" + $nl
            foreach ($r in ($xattrModRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for extended attribute modification" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Extended Attribute Events in Audit Log" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $xattrEvents = $(timeout 5 grep -c -E "type=SYSCALL.*(setxattr|removexattr)" /var/log/audit/audit.log 2>&1)
    if ($xattrEvents -match "^\d+$" -and [int]$xattrEvents -gt 0) {
        $FindingDetails += "Extended attribute modification events: $xattrEvents" + $nl
        $FindingDetails += "PASS: Audit log contains category modification events" + $nl
    }
    else {
        $FindingDetails += "Extended attribute events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer privilege escalation recording via admin action tracking in audit records" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203764 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203764
        STIG ID    : SRG-OS-000466-GPOS-00210
        Rule ID    : SV-203764r991575_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to delete privileges occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 145ced579136e5b2b49c416e4443b681
        FixMD5     : 3521cebc3ba582d3207d08f18e764ec7
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203764"
    $RuleID = "SV-203764r991575_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Privilege Deletion" + $nl
    $FindingDetails += "--------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $delPrivRules = (($auditRules -split $nl) | Where-Object { $_ -match "fremovexattr|lremovexattr|removexattr" -or ($_ -match "unlink|rename" -and $_ -match "perm=") })
        $dCount = ($delPrivRules | Measure-Object).Count
        $FindingDetails += "Privilege deletion rules found: $dCount" + $nl
        if ($dCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor privilege deletion attempts" + $nl
            foreach ($r in ($delPrivRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for privilege deletion syscalls" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Privilege Deletion Events in Audit Log" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $delEvents = $(timeout 5 grep -c -E "type=SYSCALL.*(removexattr)" /var/log/audit/audit.log 2>&1)
    if ($delEvents -match "^\d+$" -and [int]$delEvents -gt 0) {
        $FindingDetails += "Privilege deletion events: $delEvents" + $nl
        $FindingDetails += "PASS: Audit log contains privilege deletion events" + $nl
    }
    else {
        $FindingDetails += "Privilege deletion events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd privilege elevation failure monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203765 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203765
        STIG ID    : SRG-OS-000467-GPOS-00211
        Rule ID    : SV-203765r991576_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to delete security levels occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 0f1d49185c3f1b171decbe2163559851
        FixMD5     : 6f6a484610948e7c9eeaafb028689f08
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203765"
    $RuleID = "SV-203765r991576_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Security Level Deletion" + $nl
    $FindingDetails += "-------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $levelDelRules = (($auditRules -split $nl) | Where-Object { $_ -match "fremovexattr|lremovexattr|removexattr" -or ($_ -match "security" -and $_ -match "delete") })
        $lCount = ($levelDelRules | Measure-Object).Count
        $FindingDetails += "Security level deletion rules found: $lCount" + $nl
        if ($lCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor security level deletion" + $nl
            foreach ($r in ($levelDelRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for security level deletion" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: AppArmor Profile Deletion Monitoring" + $nl
    $FindingDetails += "----------------------------------------------" + $nl
    $aaProfiles = $(timeout 5 aa-status 2>&1)
    if ($aaProfiles -and $aaProfiles -notmatch "command not found") {
        $profileLines = (($aaProfiles -split $nl) | Where-Object { $_ -match "profiles are" })
        foreach ($p in $profileLines) {
            $FindingDetails += "  $p" + $nl
        }
        $FindingDetails += "PASS: AppArmor active — profile changes are logged" + $nl
    }
    else {
        $FindingDetails += "AppArmor: Not active or not installed" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer user/group modification recording via account management action tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203766 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203766
        STIG ID    : SRG-OS-000468-GPOS-00212
        Rule ID    : SV-203766r991577_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful attempts to delete security objects occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : c1e10f73ffd6ed3bf68051a1480620d8
        FixMD5     : c2924accc91cf7b8745b555c10282a51
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203766"
    $RuleID = "SV-203766r991577_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Security Object Deletion" + $nl
    $FindingDetails += "--------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $delObjRules = (($auditRules -split $nl) | Where-Object { $_ -match "unlink|unlinkat|rename|renameat" })
        $dCount = ($delObjRules | Measure-Object).Count
        $FindingDetails += "Security object deletion rules found: $dCount" + $nl
        if ($dCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor file/object deletion" + $nl
            foreach ($r in ($delObjRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for object deletion syscalls" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Security Object Deletion Events in Audit Log" + $nl
    $FindingDetails += "-----------------------------------------------------" + $nl
    $delEvents = $(timeout 5 grep -c -E "type=SYSCALL.*(unlink|rename)" /var/log/audit/audit.log 2>&1)
    if ($delEvents -match "^\d+$" -and [int]$delEvents -gt 0) {
        $FindingDetails += "Object deletion events: $delEvents" + $nl
        $FindingDetails += "PASS: Audit log contains security object deletion events" + $nl
    }
    else {
        $FindingDetails += "Object deletion events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer permission modification recording via ACL and role change tracking" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203767 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203767
        STIG ID    : SRG-OS-000470-GPOS-00214
        Rule ID    : SV-203767r991578_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful logon attempts occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 0063939743bf652e6adbc003f5eec84e
        FixMD5     : 8ae107afa9641a30747e9e64f5e6912b
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203767"
    $RuleID = "SV-203767r991578_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: PAM Authentication Logging" + $nl
    $FindingDetails += "------------------------------------" + $nl
    $pamAuth = $(timeout 5 grep -r "pam_tally2\|pam_faillock\|pam_unix" /etc/pam.d/common-auth 2>&1)
    if ($pamAuth) {
        $FindingDetails += ($pamAuth -join $nl) + $nl
        $FindingDetails += "PASS: PAM authentication modules configured for login tracking" + $nl
    }
    else {
        $pamLogin = $(timeout 5 grep -r "auth" /etc/pam.d/login 2>&1)
        if ($pamLogin) {
            $FindingDetails += "PAM login config found" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No PAM authentication logging configured" + $nl
        }
    }

    $FindingDetails += $nl + "CHECK 3: Login/Logout Audit Events" + $nl
    $FindingDetails += "-----------------------------------" + $nl
    $loginEvents = $(timeout 5 grep -c -E "type=USER_LOGIN|type=USER_AUTH|type=USER_ACCT" /var/log/audit/audit.log 2>&1)
    if ($loginEvents -match "^\d+$" -and [int]$loginEvents -gt 0) {
        $FindingDetails += "Login-related audit events: $loginEvents" + $nl
        $FindingDetails += "PASS: Audit log records logon attempts" + $nl
        $recentLogin = $(timeout 5 tail -3 /var/log/auth.log 2>&1)
        if ($recentLogin) {
            $FindingDetails += "Recent auth.log entries:" + $nl
            foreach ($entry in ($recentLogin -split $nl | Select-Object -First 3)) {
                $FindingDetails += "  $entry" + $nl
            }
        }
    }
    else {
        $FindingDetails += "Login audit events: 0 or log not accessible" + $nl
        $authLog = $(timeout 5 wc -l /var/log/auth.log 2>&1)
        if ($authLog -match "(\d+)") {
            $FindingDetails += "auth.log lines: $($matches[1])" + $nl
            $FindingDetails += "INFO: auth.log present but auditd login events not found" + $nl
        }
        $auditIssues++
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd unauthorized access attempt monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203768 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203768
        STIG ID    : SRG-OS-000471-GPOS-00215
        Rule ID    : SV-203768r991579_rule
        Rule Title : The operating system must generate audit records for privileged activities or other system-level access.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 12cae798c6b979fb44746de12c6e8da5
        FixMD5     : 16893a29892f0da81a497680db4173d4
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203768"
    $RuleID = "SV-203768r991579_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Privileged Commands" + $nl
    $FindingDetails += "---------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $privRules = (($auditRules -split $nl) | Where-Object { $_ -match "execve" -or $_ -match "-F perm=x" -or $_ -match "privileged" -or $_ -match "sudo|su |passwd|chsh|chfn|newgrp" })
        $pCount = ($privRules | Measure-Object).Count
        $FindingDetails += "Privileged activity rules found: $pCount" + $nl
        if ($pCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor privileged activities" + $nl
            foreach ($r in ($privRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for privileged activities" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Privileged Activity Audit Events" + $nl
    $FindingDetails += "-----------------------------------------" + $nl
    $privEvents = $(timeout 5 grep -c -E "type=SYSCALL.*execve|type=USER_CMD|sudo:" /var/log/audit/audit.log 2>&1)
    if ($privEvents -match "^\d+$" -and [int]$privEvents -gt 0) {
        $FindingDetails += "Privileged activity events: $privEvents" + $nl
        $FindingDetails += "PASS: Audit log contains privileged activity records" + $nl
    }
    else {
        $FindingDetails += "Privileged events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [PASS] XO Audit Plugin provides application-layer privileged activity recording via authenticated admin action tracking in audit records" + $nl
        $xoAuditCompensates = $true
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
        $xoAuditCompensates = $false
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    elseif ($xoAuditCompensates) {
        $Status = "NotAFinding"
        $FindingDetails += "COMPENSATING CONTROL: While auditd is not active, the XO Audit Plugin" + $nl
        $FindingDetails += "provides application-layer auditing with hash chain integrity that" + $nl
        $FindingDetails += "satisfies this requirement for the Xen Orchestra application." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203769 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203769
        STIG ID    : SRG-OS-000471-GPOS-00216
        Rule ID    : SV-203769r991580_rule
        Rule Title : The audit system must be configured to audit the loading and unloading of dynamic kernel modules.
        DiscussMD5 : 69989f08fb25d41af34e9424aa845d19
        CheckMD5   : b53d30a74dc98bfbf92fa1dccff2ec3b
        FixMD5     : cb82a5f2d4b69e701781a6e6e98dc168
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203769"
    $RuleID = "SV-203769r991580_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Kernel Module Operations" + $nl
    $FindingDetails += "--------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $kmodRules = (($auditRules -split $nl) | Where-Object { $_ -match "init_module|finit_module|delete_module" -or $_ -match "insmod|rmmod|modprobe" })
        $kCount = ($kmodRules | Measure-Object).Count
        $FindingDetails += "Kernel module audit rules found: $kCount" + $nl
        if ($kCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor kernel module operations" + $nl
            foreach ($r in ($kmodRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for kernel module load/unload" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Kernel Module Audit Events" + $nl
    $FindingDetails += "------------------------------------" + $nl
    $kmodEvents = $(timeout 5 grep -c -E "type=SYSCALL.*(init_module|finit_module|delete_module)" /var/log/audit/audit.log 2>&1)
    if ($kmodEvents -match "^\d+$" -and [int]$kmodEvents -gt 0) {
        $FindingDetails += "Kernel module events: $kmodEvents" + $nl
        $FindingDetails += "PASS: Audit log contains kernel module events" + $nl
    }
    else {
        $FindingDetails += "Kernel module events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit shutdown event monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203770 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203770
        STIG ID    : SRG-OS-000472-GPOS-00217
        Rule ID    : SV-203770r991581_rule
        Rule Title : The operating system must generate audit records showing starting and ending time for user access to the system.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 206e978848f1a09bb9c0e8a918e96008
        FixMD5     : ef160cd484169bfd8b4550f4342f74e6
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203770"
    $RuleID = "SV-203770r991581_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Login/Logout Session Tracking" + $nl
    $FindingDetails += "--------------------------------------" + $nl
    $wtmpCheck = $(timeout 5 last -F -n 5 2>&1)
    if ($wtmpCheck -and $wtmpCheck -notmatch "no such file") {
        $FindingDetails += "wtmp records (last 5):" + $nl
        foreach ($line in (($wtmpCheck -split $nl) | Select-Object -First 5)) {
            $FindingDetails += "  $line" + $nl
        }
        $FindingDetails += "PASS: Login/logout records with timestamps available" + $nl
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: wtmp/btmp not accessible for login tracking" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: User Session Audit Events" + $nl
    $FindingDetails += "-----------------------------------" + $nl
    $sessionEvents = $(timeout 5 grep -c -E "type=USER_LOGIN|type=USER_LOGOUT|type=USER_START|type=USER_END" /var/log/audit/audit.log 2>&1)
    if ($sessionEvents -match "^\d+$" -and [int]$sessionEvents -gt 0) {
        $FindingDetails += "Session start/end events: $sessionEvents" + $nl
        $FindingDetails += "PASS: Audit log records user session timing" + $nl
    }
    else {
        $authLogCheck = $(timeout 5 grep -c -E "session opened|session closed" /var/log/auth.log 2>&1)
        if ($authLogCheck -match "^\d+$" -and [int]$authLogCheck -gt 0) {
            $FindingDetails += "auth.log session events: $authLogCheck" + $nl
            $FindingDetails += "PASS: auth.log records session start/end" + $nl
        }
        else {
            $FindingDetails += "Session events: 0 or log not accessible" + $nl
            $auditIssues++
        }
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit configuration change monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203771 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203771
        STIG ID    : SRG-OS-000473-GPOS-00218
        Rule ID    : SV-203771r991582_rule
        Rule Title : The operating system must generate audit records when concurrent logons to the same account occur from different sources.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 568ef6293ba7cf77d65f64c4aa89d178
        FixMD5     : a186a1b4b3dfd33f61aeaabe225b6256
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203771"
    $RuleID = "SV-203771r991582_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Concurrent Login Tracking" + $nl
    $FindingDetails += "-----------------------------------" + $nl
    $currentUsers = $(timeout 5 who 2>&1)
    if ($currentUsers) {
        $userLines = ($currentUsers -split $nl) | Where-Object { $_.Trim() -ne "" }
        $userCount = ($userLines | Measure-Object).Count
        $FindingDetails += "Current active sessions: $userCount" + $nl
        foreach ($u in ($userLines | Select-Object -First 10)) {
            $FindingDetails += "  $u" + $nl
        }
        $FindingDetails += "PASS: Login session tracking available via utmp/wtmp" + $nl
    }
    else {
        $FindingDetails += "No active sessions or who command unavailable" + $nl
        $auditIssues++
    }

    $FindingDetails += $nl + "CHECK 3: Login Audit Events with Source" + $nl
    $FindingDetails += "---------------------------------------" + $nl
    $loginEvents = $(timeout 5 grep -c -E "type=USER_LOGIN|type=USER_AUTH" /var/log/audit/audit.log 2>&1)
    if ($loginEvents -match "^\d+$" -and [int]$loginEvents -gt 0) {
        $FindingDetails += "Login audit events: $loginEvents" + $nl
        $FindingDetails += "PASS: Audit log records login events with source info" + $nl
    }
    else {
        $authLogins = $(timeout 5 grep -c -E "Accepted|session opened" /var/log/auth.log 2>&1)
        if ($authLogins -match "^\d+$" -and [int]$authLogins -gt 0) {
            $FindingDetails += "auth.log login events: $authLogins" + $nl
            $FindingDetails += "PASS: auth.log records login events with source" + $nl
        }
        else {
            $FindingDetails += "Login events: 0 or log not accessible" + $nl
            $auditIssues++
        }
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit rule modification detection; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203772 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203772
        STIG ID    : SRG-OS-000474-GPOS-00219
        Rule ID    : SV-203772r991583_rule
        Rule Title : The operating system must generate audit records when successful/unsuccessful accesses to objects occur.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 590cfe5d2f7d1007eebdba6219d0f730
        FixMD5     : e8b4d5ff9c53009a71abb19d28586a33
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203772"
    $RuleID = "SV-203772r991583_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Object Access (Success/Failure)" + $nl
    $FindingDetails += "--------------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $objRules = (($auditRules -split $nl) | Where-Object { $_ -match "open|openat|creat|truncate|ftruncate" -or $_ -match "-F exit=-EACCES|-F exit=-EPERM" -or $_ -match "-F perm=" })
        $oCount = ($objRules | Measure-Object).Count
        $FindingDetails += "Object access audit rules found: $oCount" + $nl
        if ($oCount -gt 0) {
            $FindingDetails += "PASS: Audit rules monitor object access" + $nl
            foreach ($r in ($objRules | Select-Object -First 5)) {
                $FindingDetails += "  $r" + $nl
            }
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No audit rules for object access" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Object Access Audit Events" + $nl
    $FindingDetails += "------------------------------------" + $nl
    $objEvents = $(timeout 5 grep -c -E "type=SYSCALL.*(open|creat|truncate)" /var/log/audit/audit.log 2>&1)
    if ($objEvents -match "^\d+$" -and [int]$objEvents -gt 0) {
        $FindingDetails += "Object access events: $objEvents" + $nl
        $FindingDetails += "PASS: Audit log contains object access records" + $nl
    }
    else {
        $FindingDetails += "Object access events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit system disable attempt detection; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203773 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203773
        STIG ID    : SRG-OS-000475-GPOS-00220
        Rule ID    : SV-203773r991584_rule
        Rule Title : The operating system must generate audit records for all direct access to the information system.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : ad41db83734dd0007a0fe7eb55da096b
        FixMD5     : bdc4458163e38c96cd25ecaf3edb68b2
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203773"
    $RuleID = "SV-203773r991584_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Direct Access Logging (Console/TTY/SSH)" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $pamLogin = $(timeout 5 grep -E "pam_loginuid|pam_lastlog|pam_tty_audit" /etc/pam.d/common-session 2>&1)
    if ($pamLogin) {
        $pamLines = ($pamLogin -split $nl) | Where-Object { $_.Trim() -ne "" -and $_ -notmatch "^#" }
        $pamCount = ($pamLines | Measure-Object).Count
        $FindingDetails += "PAM session modules: $pamCount" + $nl
        foreach ($p in ($pamLines | Select-Object -First 5)) {
            $FindingDetails += "  $p" + $nl
        }
        $FindingDetails += "PASS: PAM configured for direct access logging" + $nl
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No PAM session audit modules configured" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Direct Access Audit Events" + $nl
    $FindingDetails += "------------------------------------" + $nl
    $directEvents = $(timeout 5 grep -c -E "type=USER_LOGIN|type=LOGIN|type=USER_START" /var/log/audit/audit.log 2>&1)
    if ($directEvents -match "^\d+$" -and [int]$directEvents -gt 0) {
        $FindingDetails += "Direct access events: $directEvents" + $nl
        $FindingDetails += "PASS: Audit log records direct access events" + $nl
    }
    else {
        $authDirect = $(timeout 5 grep -c -E "sshd.*Accepted|login.*LOGIN" /var/log/auth.log 2>&1)
        if ($authDirect -match "^\d+$" -and [int]$authDirect -gt 0) {
            $FindingDetails += "auth.log direct access events: $authDirect" + $nl
            $FindingDetails += "PASS: auth.log records direct access" + $nl
        }
        else {
            $FindingDetails += "Direct access events: 0 or log not accessible" + $nl
            $auditIssues++
        }
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit failure recovery monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203774 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203774
        STIG ID    : SRG-OS-000476-GPOS-00221
        Rule ID    : SV-203774r991585_rule
        Rule Title : The operating system must generate audit records for all account creations, modifications, disabling, and termination events.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 4ec9ae0f492d50abba81cbe4a070f060
        FixMD5     : 9f048fc81ed680444b623bc990c4cd19
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203774"
    $RuleID = "SV-203774r991585_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Account Management Files" + $nl
    $FindingDetails += "--------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $acctFiles = @("/etc/passwd", "/etc/shadow", "/etc/group", "/etc/gshadow", "/etc/security/opasswd")
        $acctRulesFound = 0
        foreach ($af in $acctFiles) {
            $escaped = [regex]::Escape($af)
            $matched = (($auditRules -split $nl) | Where-Object { $_ -match $escaped })
            if ($matched) {
                $acctRulesFound++
                $FindingDetails += "  Watch rule for $af : FOUND" + $nl
            }
            else {
                $FindingDetails += "  Watch rule for $af : MISSING" + $nl
            }
        }
        if ($acctRulesFound -ge 3) {
            $FindingDetails += "PASS: Account management file watches configured ($acctRulesFound/$($acctFiles.Count))" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: Insufficient account file watches ($acctRulesFound/$($acctFiles.Count))" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Account Management Audit Events" + $nl
    $FindingDetails += "-----------------------------------------" + $nl
    $acctEvents = $(timeout 5 grep -c -E "type=ADD_USER|type=DEL_USER|type=ADD_GROUP|type=DEL_GROUP|type=USER_MGMT|type=ACCT_LOCK|type=ACCT_UNLOCK" /var/log/audit/audit.log 2>&1)
    if ($acctEvents -match "^\d+$" -and [int]$acctEvents -gt 0) {
        $FindingDetails += "Account management events: $acctEvents" + $nl
        $FindingDetails += "PASS: Audit log contains account lifecycle events" + $nl
    }
    else {
        $authAcct = $(timeout 5 grep -c -E "useradd|userdel|usermod|groupadd|groupdel|passwd" /var/log/auth.log 2>&1)
        if ($authAcct -match "^\d+$" -and [int]$authAcct -gt 0) {
            $FindingDetails += "auth.log account events: $authAcct" + $nl
            $FindingDetails += "PASS: auth.log records account management" + $nl
        }
        else {
            $FindingDetails += "Account events: 0 or log not accessible" + $nl
            $auditIssues++
        }
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit data protection enforcement; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203775 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203775
        STIG ID    : SRG-OS-000477-GPOS-00222
        Rule ID    : SV-203775r991586_rule
        Rule Title : The operating system must generate audit records for all kernel module load, unload, and restart actions, and also for all program initiations.
        DiscussMD5 : 54b117448d2d37375c1440c2f61bb02a
        CheckMD5   : 78be4790d2a517243e0b8dbad51e6377
        FixMD5     : 3602efe449b46c743c78f6425574fb99
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203775"
    $RuleID = "SV-203775r991586_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Kernel Modules and Program Execution" + $nl
    $FindingDetails += "--------------------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $kmodRules = (($auditRules -split $nl) | Where-Object { $_ -match "init_module|finit_module|delete_module" -or $_ -match "insmod|rmmod|modprobe" })
        $execRules = (($auditRules -split $nl) | Where-Object { $_ -match "execve" -or $_ -match "-F perm=x" })
        $kCount = ($kmodRules | Measure-Object).Count
        $eCount = ($execRules | Measure-Object).Count
        $FindingDetails += "Kernel module rules: $kCount" + $nl
        $FindingDetails += "Program execution rules: $eCount" + $nl
        if ($kCount -gt 0 -and $eCount -gt 0) {
            $FindingDetails += "PASS: Both kernel module and program execution rules configured" + $nl
        }
        elseif ($kCount -gt 0 -or $eCount -gt 0) {
            $FindingDetails += "PARTIAL: Some rules configured but coverage incomplete" + $nl
            $auditIssues++
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No kernel module or program execution rules" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules loaded" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Kernel Module and Execution Events" + $nl
    $FindingDetails += "--------------------------------------------" + $nl
    $kmodEvents = $(timeout 5 grep -c -E "type=SYSCALL.*(init_module|finit_module|delete_module|execve)" /var/log/audit/audit.log 2>&1)
    if ($kmodEvents -match "^\d+$" -and [int]$kmodEvents -gt 0) {
        $FindingDetails += "Kernel/execution events: $kmodEvents" + $nl
        $FindingDetails += "PASS: Audit log contains module and execution records" + $nl
    }
    else {
        $FindingDetails += "Kernel/execution events: 0 or log not accessible" + $nl
        $auditIssues++
    }


    # Note: XO Audit Plugin Status
    $FindingDetails += $nl + "--- Note: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    $FindingDetails += "  XO Audit Plugin: $(if ($xoAuditInfo.Enabled) {'ACTIVE'} else {'NOT DETECTED'})" + $nl
    $FindingDetails += "  [INFO] This check requires OS-level auditd audit backup procedure monitoring; XO Audit Plugin does not address this requirement." + $nl
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203776 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203776
        STIG ID    : SRG-OS-000478-GPOS-00223
        Rule ID    : SV-203776r959006_rule
        Rule Title : The operating system must implement NIST FIPS-validated cryptography for digital signatures, cryptographic hashes, and confidentiality protection.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203776"
    $RuleID = "SV-203776r959006_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203776 - NIST FIPS-Validated Cryptography" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Kernel FIPS mode
    $FindingDetails += "Check 1: Kernel FIPS Mode (/proc/sys/crypto/fips_enabled)" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $fipsEnabled = $false
    if (Test-Path /proc/sys/crypto/fips_enabled) {
        $fipsValue = (Get-Content /proc/sys/crypto/fips_enabled -ErrorAction SilentlyContinue).Trim()
        $FindingDetails += "fips_enabled: " + $fipsValue + $nl
        if ($fipsValue -eq "1") {
            $fipsEnabled = $true
        }
    } else {
        $FindingDetails += "fips_enabled: file not found" + $nl
    }

    $FindingDetails += $nl

    # Check 2: OpenSSL version and FIPS provider
    $FindingDetails += "Check 2: OpenSSL FIPS Status" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $opensslVer = $(openssl version 2>&1)
    $FindingDetails += "OpenSSL: " + ($opensslVer -join $nl) + $nl

    $opensslProviders = $(openssl list -providers 2>&1)
    $providersStr = ($opensslProviders -join $nl)
    $FindingDetails += "Providers: " + $providersStr + $nl

    $FindingDetails += $nl

    # Check 3: Kernel boot parameters
    $FindingDetails += "Check 3: FIPS Boot Parameters" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $cmdline = (Get-Content /proc/cmdline -ErrorAction SilentlyContinue) -join " "
    $hasFipsBoot = $cmdline -match "fips=1"
    $FindingDetails += "Kernel cmdline: " + $cmdline + $nl
    $FindingDetails += "fips=1 present: " + $hasFipsBoot + $nl

    $FindingDetails += $nl

    # Check 4: FIPS crypto packages
    $FindingDetails += "Check 4: FIPS Crypto Packages" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $fipsPkgs = @("libssl3", "libgcrypt20", "libgnutls30")
    foreach ($pkg in $fipsPkgs) {
        $pkgInfo = $(dpkg -l $pkg 2>&1)
        $pkgStr = ($pkgInfo -join $nl)
        if ($pkgStr -match "^ii\s+\S+\s+(\S+)") {
            $FindingDetails += "  " + $pkg + ": " + $matches[1] + $nl
        } else {
            $FindingDetails += "  " + $pkg + ": Not installed" + $nl
        }
    }

    $FindingDetails += $nl

    # Status determination
    if ($fipsEnabled) {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - NIST FIPS-validated cryptography is enabled" + $nl
    } else {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - FIPS mode is not enabled. System does not enforce NIST FIPS-validated cryptography." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203777 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203777
        STIG ID    : SRG-OS-000479-GPOS-00224
        Rule ID    : SV-203777r959008_rule
        Rule Title : The operating system must, at a minimum, off-load audit data from interconnected systems in real time and off-load audit data from standalone systems weekly.
        DiscussMD5 : 70944557094cf5c2cbca167073bdd4b1
        CheckMD5   : 368dd6afeee1747b5beb817f85e27f87
        FixMD5     : 99d86c5c8ab9d7f491bce61bdf7fbfd3
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203777"
    $RuleID = "SV-203777r959008_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: Remote Syslog Configuration" + $nl
    $FindingDetails += "------------------------------------" + $nl
    $rsyslogConf = $(timeout 5 grep -r "@@\|action.*type=" /etc/rsyslog.conf /etc/rsyslog.d/ 2>&1)
    if ($rsyslogConf -and $rsyslogConf -notmatch "No such file") {
        $remoteLines = ($rsyslogConf -split $nl) | Where-Object { $_.Trim() -ne "" -and $_ -notmatch "^#" -and ($_ -match "@@" -or $_ -match "action.*type=") }
        $rCount = ($remoteLines | Measure-Object).Count
        $FindingDetails += "Remote forwarding rules: $rCount" + $nl
        foreach ($r in ($remoteLines | Select-Object -First 5)) {
            $FindingDetails += "  $r" + $nl
        }
        if ($rCount -gt 0) {
            $FindingDetails += "PASS: rsyslog configured to forward audit data" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: No remote forwarding in rsyslog" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: rsyslog configuration not found" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: systemd-journal-upload or audisp-remote" + $nl
    $FindingDetails += "------------------------------------------------" + $nl
    $journalUpload = $(timeout 5 systemctl is-active systemd-journal-upload 2>&1)
    $audispRemote = $(timeout 5 systemctl is-active audisp-remote 2>&1)
    $FindingDetails += "systemd-journal-upload: $journalUpload" + $nl
    $FindingDetails += "audisp-remote: $audispRemote" + $nl
    if ($journalUpload -eq "active" -or $audispRemote -eq "active") {
        $FindingDetails += "PASS: Centralized log forwarding service active" + $nl
    }
    else {
        $FindingDetails += "INFO: No dedicated log forwarding service active" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Audit Log Rotation and Off-loading" + $nl
    $FindingDetails += "--------------------------------------------" + $nl
    $logrotateAudit = $(timeout 5 grep -l "audit" /etc/logrotate.d/* 2>&1)
    if ($logrotateAudit -and $logrotateAudit -notmatch "No such file") {
        $FindingDetails += "Audit logrotate config: FOUND" + $nl
        foreach ($lf in (($logrotateAudit -split $nl) | Select-Object -First 3)) {
            $FindingDetails += "  $lf" + $nl
        }
        $FindingDetails += "PASS: Audit log rotation configured" + $nl
    }
    else {
        $FindingDetails += "Audit logrotate config: not found" + $nl
        $auditIssues++
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [INFO] XO Audit Plugin provides audit trail integrity verification via cryptographic hash chain (each record linked to previous)" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203778 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203778
        STIG ID    : SRG-OS-000480-GPOS-00225
        Rule ID    : SV-203778r991587_rule
        Rule Title : Prevent the use of dictionary words for passwords
        DiscussMD5 : 9cb543ada83a7e715bb0ce789ff8bd25
        CheckMD5   : 9602171ad83aad48e3feb2d59eca6c55
        FixMD5     : 6c093c4b7380d0aecb95eaed5f85132c
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203778"
    $RuleID = "SV-203778r991587_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $dictCheckPass = $false

    # Check 1: pwquality.conf dictcheck setting
    $output += "Check 1: pwquality.conf dictcheck Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'dictcheck'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "dictcheck\s*=\s*(\d+)") {
            $dictcheckVal = [int]$Matches[1]
            $output += "  dictcheck = $dictcheckVal${nl}"
            if ($dictcheckVal -ge 1) {
                $output += "  [PASS] Dictionary check enabled${nl}"
                $dictCheckPass = $true
            }
            else {
                $output += "  [FAIL] dictcheck is disabled (set to 0)${nl}"
            }
        }
        else {
            $output += "  [INFO] dictcheck not explicitly set (default is 1 = enabled in pwquality 1.4.4+)${nl}"
            $dictCheckPass = $true
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Dictionary files available (cracklib)
    $output += "Check 3: Dictionary Files${nl}"
    try {
        $dictFiles = $(timeout 5 sh -c "ls -la /usr/share/dict/ 2>/dev/null; dpkg -l cracklib-runtime 2>/dev/null | grep '^ii'; dpkg -l libpam-cracklib 2>/dev/null | grep '^ii'" 2>&1)
        $dictStr = ($dictFiles -join $nl).Trim()
        if ($dictStr) {
            foreach ($line in ($dictStr -split $nl)) {
                $output += "  $line${nl}"
            }
        }
        else {
            $output += "  [INFO] No dictionary files or cracklib packages found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status - dictcheck enabled (or default) AND pam_pwquality loaded
    if ($dictCheckPass -and $pamStr) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203779 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203779
        STIG ID    : SRG-OS-000480-GPOS-00226
        Rule ID    : SV-203779r991588_rule
        Rule Title : Enforce 4-second delay after failed logon
        DiscussMD5 : 7c22d07c283abac40cc9dd2e8dc76d89
        CheckMD5   : a5f88eae97ca1d47acc13394b31702f1
        FixMD5     : 6a2ff3c02925b7b5b7a15a288d0a82e2
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203779"
    $RuleID = "SV-203779r991588_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""

    # Check 1: PAM faildelay module
    $output += "Check 1: PAM Fail Delay Configuration${nl}"
    $faildelayPass = $false
    try {
        $pamAuth = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-auth 2>/dev/null | grep pam_faildelay" 2>&1)
        $pamStr = ($pamAuth -join $nl).Trim()
        if ($pamStr -match "pam_faildelay") {
            $output += "  PAM faildelay config: $pamStr${nl}"
            if ($pamStr -match "delay=(\d+)") {
                $delayUs = [int64]$matches[1]
                $delaySec = $delayUs / 1000000
                if ($delaySec -ge 4) {
                    $output += "  [PASS] Fail delay = $delaySec seconds (minimum 4 required)${nl}"
                    $faildelayPass = $true
                }
                else {
                    $output += "  [FAIL] Fail delay = $delaySec seconds (less than 4 required)${nl}"
                }
            }
        }
        else {
            $output += "  [FAIL] pam_faildelay not configured in /etc/pam.d/common-auth${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: pam_unix nodelay option (should NOT be set)
    $output += "Check 2: PAM Unix Delay Behavior${nl}"
    $nodelayBad = $false
    try {
        $pamUnix = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-auth 2>/dev/null | grep pam_unix" 2>&1)
        $pamUnixStr = ($pamUnix -join $nl).Trim()
        if ($pamUnixStr) {
            $output += "  PAM unix config: $pamUnixStr${nl}"
            if ($pamUnixStr -match "nodelay") {
                $output += "  [FAIL] nodelay option set - bypasses authentication delay${nl}"
                $nodelayBad = $true
            }
            else {
                $output += "  [PASS] nodelay not set (default delay behavior active)${nl}"
            }
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: SSH LoginGraceTime
    $output += "Check 3: SSH Login Grace Time${nl}"
    try {
        $sshGrace = $(timeout 5 sh -c "sshd -T 2>/dev/null | grep -i logingracetime" 2>&1)
        $sshStr = ($sshGrace -join $nl).Trim()
        if ($sshStr -match "logingracetime\s+(\d+)") {
            $graceTime = [int]$matches[1]
            $output += "  SSH LoginGraceTime: $graceTime seconds${nl}"
        }
        else {
            $output += "  [INFO] SSH LoginGraceTime: $sshStr${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status
    if ($faildelayPass -and -not $nodelayBad) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203780 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203780
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203780r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203780"
    $RuleID = "SV-203780r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203780) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203781 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203781
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203781r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203781"
    $RuleID = "SV-203781r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203781) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203782 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203782
        STIG ID    : SRG-OS-000480-GPOS-00229
        Rule ID    : SV-203782r991591_rule
        Rule Title : The operating system must not allow an unattended or automatic logon to the system.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203782"
    $RuleID = "SV-203782r991591_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-203782 - No Unattended or Automatic Logon" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Getty autologin (console)
    $FindingDetails += "Check 1: Getty/Console Autologin" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $autologinFound = $false
    $gettyOverrides = @(
        "/etc/systemd/system/getty@tty1.service.d/override.conf",
        "/etc/systemd/system/serial-getty@.service.d/override.conf"
    )

    foreach ($overrideFile in $gettyOverrides) {
        if (Test-Path $overrideFile) {
            $overrideContent = Get-Content $overrideFile -ErrorAction SilentlyContinue
            $overrideStr = ($overrideContent -join $nl)
            if ($overrideStr -match "autologin|--autologin") {
                $FindingDetails += "  FAIL: Autologin configured in " + $overrideFile + $nl
                $autologinFound = $true
            }
        }
    }

    if (-not $autologinFound) {
        $FindingDetails += "  PASS: No getty autologin overrides detected" + $nl
    }

    $FindingDetails += $nl

    # Check 2: Display manager autologin (GDM3, LightDM)
    $FindingDetails += "Check 2: Display Manager Autologin" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $dmAutologin = $false

    # GDM3
    if (Test-Path /etc/gdm3/custom.conf) {
        $gdmConf = Get-Content /etc/gdm3/custom.conf -ErrorAction SilentlyContinue
        $gdmStr = ($gdmConf -join $nl)
        if ($gdmStr -match "(?m)^AutomaticLoginEnable\s*=\s*[Tt]rue") {
            $FindingDetails += "  FAIL: GDM3 automatic login is enabled" + $nl
            $dmAutologin = $true
        }
    }

    # LightDM
    if (Test-Path /etc/lightdm/lightdm.conf) {
        $ldmConf = Get-Content /etc/lightdm/lightdm.conf -ErrorAction SilentlyContinue
        $ldmStr = ($ldmConf -join $nl)
        if ($ldmStr -match "(?m)^autologin-user\s*=\s*\S+") {
            $FindingDetails += "  FAIL: LightDM autologin user is configured" + $nl
            $dmAutologin = $true
        }
    }

    if (-not $dmAutologin) {
        $FindingDetails += "  PASS: No display manager autologin detected" + $nl
    }

    $FindingDetails += $nl

    # Check 3: SSH PermitEmptyPasswords (allows passwordless login)
    $FindingDetails += "Check 3: SSH Empty Password Access" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $sshdConfig = $(sshd -T 2>&1)
    $sshdStr = ($sshdConfig -join $nl)
    $emptyPwIssue = $false

    if ($sshdStr -match "(?m)^permitemptypasswords\s+yes") {
        $FindingDetails += "  FAIL: SSH permits empty passwords" + $nl
        $emptyPwIssue = $true
    } else {
        $FindingDetails += "  PASS: SSH denies empty passwords" + $nl
    }

    $FindingDetails += $nl

    # Check 4: Accounts with empty password fields
    $FindingDetails += "Check 4: Accounts with Empty Passwords" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $emptyPwAccts = $false
    $shadowContent = Get-Content /etc/shadow -ErrorAction SilentlyContinue
    foreach ($line in $shadowContent) {
        if ($line -match "^([^:]+):([^:]*):") {
            if ($matches[2] -eq "" -or $matches[2] -eq " ") {
                $FindingDetails += "  FAIL: Empty password for: " + $matches[1] + $nl
                $emptyPwAccts = $true
            }
        }
    }
    if (-not $emptyPwAccts) {
        $FindingDetails += "  PASS: No accounts with empty passwords" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    if ($autologinFound -or $dmAutologin -or $emptyPwIssue -or $emptyPwAccts) {
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Unattended or automatic logon is possible" + $nl
    } else {
        $Status = "NotAFinding"
        $FindingDetails += "RESULT: PASS - No unattended or automatic logon mechanisms detected" + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203783 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203783
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203783r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203783"
    $RuleID = "SV-203783r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203783) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V203784 {
    <#
    .DESCRIPTION
        Vuln ID    : V-203784
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-203784r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-203784"
    $RuleID = "SV-203784r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-203784) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V252688 {
    <#
    .DESCRIPTION
        Vuln ID    : V-252688
        STIG ID    : SRG-OS-000481-GPOS-00481
        Rule ID    : SV-252688r958358_rule
        Rule Title : The operating system must protect the confidentiality and integrity of communications with wireless peripherals.
        DiscussMD5 : 00000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-252688"
    $RuleID = "SV-252688r958358_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "V-252688 - Wireless Peripheral Communications Protection" + $nl
    $FindingDetails += ("=" * 60) + $nl + $nl

    # Check 1: Bluetooth hardware/subsystem detection
    $FindingDetails += "Check 1: Bluetooth Hardware Detection" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $btDevices = $(timeout 5 sh -c 'ls /sys/class/bluetooth/ 2>/dev/null')
    $btStr = ($btDevices -join $nl).Trim()
    $btFound = ($btStr.Length -gt 0)

    if ($btFound) {
        $FindingDetails += "Bluetooth devices detected: " + $btStr + $nl
    } else {
        $FindingDetails += "No Bluetooth hardware detected" + $nl
    }

    $FindingDetails += $nl

    # Check 2: Bluetooth service status
    $FindingDetails += "Check 2: Bluetooth Service Status" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $btService = $(systemctl is-active bluetooth 2>&1)
    $btServiceStr = ($btService -join $nl).Trim()
    $FindingDetails += "Bluetooth service: " + $btServiceStr + $nl

    $btEnabled = $(systemctl is-enabled bluetooth 2>&1)
    $btEnabledStr = ($btEnabled -join $nl).Trim()
    $FindingDetails += "Bluetooth enabled: " + $btEnabledStr + $nl

    $btActive = ($btServiceStr -eq "active")

    $FindingDetails += $nl

    # Check 3: Wi-Fi hardware detection
    $FindingDetails += "Check 3: Wireless Network Hardware Detection" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $wifiDevices = $(timeout 5 sh -c 'ls /sys/class/net/*/wireless 2>/dev/null')
    $wifiStr = ($wifiDevices -join $nl).Trim()
    $wifiFound = ($wifiStr.Length -gt 0)

    if ($wifiFound) {
        $FindingDetails += "Wireless network interfaces detected: " + $wifiStr + $nl
    } else {
        $FindingDetails += "No wireless network interfaces detected" + $nl
    }

    $FindingDetails += $nl

    # Check 4: USB wireless adapter kernel modules
    $FindingDetails += "Check 4: Wireless Kernel Modules" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $wirelessMods = $(timeout 5 sh -c 'lsmod 2>/dev/null | grep -iE "bluetooth|btusb|iwlwifi|ath9k|ath10k|rtl8|mt76|brcmfmac" 2>/dev/null')
    $wirelessModStr = ($wirelessMods -join $nl).Trim()

    if ($wirelessModStr.Length -gt 0) {
        $FindingDetails += "Wireless kernel modules loaded:" + $nl + $wirelessModStr + $nl
    } else {
        $FindingDetails += "No wireless kernel modules loaded" + $nl
    }

    $FindingDetails += $nl

    # Check 5: VM/hypervisor environment detection
    $FindingDetails += "Check 5: Virtualization Environment" + $nl
    $FindingDetails += ("-" * 40) + $nl

    $virtType = $(systemd-detect-virt 2>&1)
    $virtStr = ($virtType -join $nl).Trim()
    $FindingDetails += "Virtualization type: " + $virtStr + $nl

    $isVM = ($virtStr -ne "none" -and $virtStr.Length -gt 0)
    if ($isVM) {
        $FindingDetails += "  INFO: System is a virtual machine - wireless peripherals not physically attached" + $nl
    }

    $FindingDetails += $nl

    # Status determination
    $hasWireless = ($btFound -or $btActive -or $wifiFound -or ($wirelessModStr.Length -gt 0))

    if (-not $hasWireless) {
        $Status = "Not_Applicable"
        $FindingDetails += "RESULT: NOT APPLICABLE - No wireless peripheral hardware or services detected" + $nl
        if ($isVM) {
            $FindingDetails += "System is a virtual machine with no wireless hardware passthrough" + $nl
        }
    } else {
        # Wireless hardware detected - check if properly secured
        $Status = "Open"
        $FindingDetails += "RESULT: FAIL - Wireless hardware/services detected. Verify communications" + $nl
        $FindingDetails += "are protected with DoD-approved cryptographic mechanisms." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V259333 {
    <#
    .DESCRIPTION
        Vuln ID    : V-259333
        STIG ID    : SRG-OS-000439-GPOS-00195
        Rule ID    : SV-259333r958940_rule
        Rule Title : The operating system must install security-relevant software updates within the time period directed by an authoritative source (e.g., IAVM, CTOs, DTMs, and STIGs).
        DiscussMD5 : cae6b28fe90be534f51fca4471b6d2c8
        CheckMD5   : 1c534cf32c0e21b51ce389d5c661d83e
        FixMD5     : f1b88545a7b49f37d93b32b28c760743
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-259333"
    $RuleID = "SV-259333r958940_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $FindingDetails = "--- Check: Security-Relevant Software Updates ---" + $nl

    # Check 1: Available security updates
    $FindingDetails += $nl + "Check 1: Pending Security Updates" + $nl
    $updatesAvailable = $false
    $aptCheck = $(apt list --upgradable 2>&1 | grep -i "security" 2>&1)
    if ($aptCheck -and $aptCheck.ToString().Trim().Length -gt 0) {
        $updateCount = ($aptCheck -split $nl).Count
        $FindingDetails += "  Security updates available: $updateCount" + $nl
        foreach ($line in ($aptCheck -split $nl | Select-Object -First 5)) {
            $FindingDetails += "    $($line.ToString().Trim())" + $nl
        }
        $updatesAvailable = $true
    }
    else {
        $FindingDetails += "  No pending security updates detected" + $nl
    }

    # Check 2: Last update timestamp
    $FindingDetails += $nl + "Check 2: Last Package Update" + $nl
    $lastUpdate = $(stat -c "%Y %y" /var/lib/apt/lists/ 2>&1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  apt lists last modified: $($lastUpdate.ToString().Trim())" + $nl
    }
    $dpkgLog = $(ls -lt /var/log/dpkg.log* 2>&1 | head -1)
    if ($LASTEXITCODE -eq 0) {
        $FindingDetails += "  dpkg log: $($dpkgLog.ToString().Trim())" + $nl
    }
    $lastInstall = $(grep " install " /var/log/dpkg.log 2>&1 | tail -3)
    if ($lastInstall) {
        $FindingDetails += "  Recent package installs:" + $nl
        foreach ($line in ($lastInstall -split $nl | Select-Object -Last 3)) {
            $FindingDetails += "    $($line.ToString().Trim())" + $nl
        }
    }

    # Check 3: Automatic update configuration
    $FindingDetails += $nl + "Check 3: Automatic Update Configuration" + $nl
    $autoUpdateOk = $false
    $(test -f /etc/apt/apt.conf.d/20auto-upgrades 2>&1) | Out-Null
    if ($LASTEXITCODE -eq 0) {
        $autoConf = $(cat /etc/apt/apt.conf.d/20auto-upgrades 2>&1)
        $FindingDetails += "  /etc/apt/apt.conf.d/20auto-upgrades:" + $nl
        foreach ($line in ($autoConf -split $nl)) {
            $FindingDetails += "    $($line.ToString().Trim())" + $nl
        }
        if ($autoConf -match "Unattended-Upgrade.*1") {
            $autoUpdateOk = $true
        }
    }
    else {
        $FindingDetails += "  Automatic updates: NOT CONFIGURED" + $nl
    }

    $unattendedStatus = $(systemctl is-active unattended-upgrades 2>&1)
    if ($LASTEXITCODE -eq 0 -and $unattendedStatus -match "active") {
        $FindingDetails += "  unattended-upgrades service: ACTIVE" + $nl
        $autoUpdateOk = $true
    }

    # Check 4: OS version and support status
    $FindingDetails += $nl + "Check 4: OS Version and Support" + $nl
    $osRelease = $(cat /etc/os-release 2>&1 | grep -i "PRETTY_NAME\|VERSION_ID" 2>&1)
    if ($osRelease) {
        foreach ($line in ($osRelease -split $nl)) {
            $FindingDetails += "  $($line.ToString().Trim())" + $nl
        }
    }

    # Status determination
    if (-not $updatesAvailable -and $autoUpdateOk) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: No pending security updates and automatic updates are configured." + $nl
    }
    elseif (-not $updatesAvailable) {
        $Status = "NotAFinding"
        $FindingDetails += $nl + "RESULT: No pending security updates detected. System appears current." + $nl
    }
    else {
        $Status = "Open"
        $FindingDetails += $nl + "RESULT: Security updates are available but not installed." + $nl
        $FindingDetails += "  Updates must be installed within the timeframe directed by" + $nl
        $FindingDetails += "  authoritative sources (IAVM, CTOs, DTMs, STIGs)." + $nl
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263650 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263650
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263650r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263650"
    $RuleID = "SV-263650r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263650) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263651 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263651
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263651r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263651"
    $RuleID = "SV-263651r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263651) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263652 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263652
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263652r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263652"
    $RuleID = "SV-263652r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263652) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263653 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263653
        STIG ID    : SRG-OS-000710-GPOS-00160
        Rule ID    : SV-263653r982229_rule
        Rule Title : Verify passwords not found on commonly-used, compromised password lists
        DiscussMD5 : 013e737dbcd96e4dd0461a8e25c3fbfb
        CheckMD5   : 64577a6a45f6e808ffb6264db9dad2e1
        FixMD5     : d2b3c8b240803accec4cbf73a4ba54be
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,

        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,

        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263653"
    $RuleID = "SV-263653r982229_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $output = ""
    $dictCheckPass = $false
    $wordlistFound = $false

    # Check 1: pwquality.conf dictcheck setting
    $output += "Check 1: pwquality.conf dictcheck Setting${nl}"
    try {
        $pwqConf = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'dictcheck'" 2>&1)
        $pwqStr = ($pwqConf -join $nl).Trim()
        if ($pwqStr -match "dictcheck\s*=\s*(\d+)") {
            $dictcheckVal = [int]$Matches[1]
            $output += "  dictcheck = $dictcheckVal${nl}"
            if ($dictcheckVal -ge 1) {
                $output += "  [PASS] Dictionary check enabled${nl}"
                $dictCheckPass = $true
            }
            else {
                $output += "  [FAIL] dictcheck is disabled (set to 0)${nl}"
            }
        }
        else {
            $output += "  [INFO] dictcheck not explicitly set (default is 1 = enabled in pwquality 1.4.4+)${nl}"
            $dictCheckPass = $true
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 2: PAM pwquality module loaded
    $output += "Check 2: PAM pwquality Module${nl}"
    try {
        $pamConf = $(timeout 5 sh -c "grep -v '^#' /etc/pam.d/common-password 2>/dev/null | grep pam_pwquality" 2>&1)
        $pamStr = ($pamConf -join $nl).Trim()
        if ($pamStr) {
            $output += "  $pamStr${nl}"
            $output += "  [PASS] pam_pwquality loaded in PAM stack${nl}"
        }
        else {
            $output += "  [FAIL] pam_pwquality not found in /etc/pam.d/common-password${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 3: Wordlist/dictionary files for compromised password checking
    $output += "Check 3: Compromised Password Wordlists${nl}"
    try {
        $wordlists = $(timeout 5 sh -c "ls -la /usr/share/dict/ 2>/dev/null; ls -la /usr/share/cracklib/ 2>/dev/null; dpkg -l cracklib-runtime 2>/dev/null | grep '^ii'; dpkg -l wamerican 2>/dev/null | grep '^ii'; dpkg -l wamerican-large 2>/dev/null | grep '^ii'" 2>&1)
        $wordStr = ($wordlists -join $nl).Trim()
        if ($wordStr) {
            foreach ($line in ($wordStr -split $nl)) {
                $output += "  $line${nl}"
            }
            if ($wordStr -match "(cracklib|wamerican|words)") {
                $wordlistFound = $true
                $output += "  [PASS] Dictionary/wordlist files available for password checking${nl}"
            }
            else {
                $output += "  [INFO] Dictionary directory exists but standard wordlists not confirmed${nl}"
            }
        }
        else {
            $output += "  [FAIL] No dictionary/wordlist files found${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }
    $output += $nl

    # Check 4: pwquality dictpath for custom compromised password list
    $output += "Check 4: Custom Compromised Password List${nl}"
    try {
        $dictpath = $(timeout 5 sh -c "grep -v '^#' /etc/security/pwquality.conf 2>/dev/null | grep -i 'dictpath'" 2>&1)
        $dictpathStr = ($dictpath -join $nl).Trim()
        if ($dictpathStr -match "dictpath\s*=\s*(.+)") {
            $customPath = $Matches[1].Trim()
            $output += "  dictpath = $customPath${nl}"
            $pathCheck = $(timeout 5 sh -c "ls -la ${customPath}* 2>/dev/null" 2>&1)
            $pathStr = ($pathCheck -join $nl).Trim()
            if ($pathStr) {
                $output += "  [PASS] Custom dictionary path exists${nl}"
                $wordlistFound = $true
            }
            else {
                $output += "  [FAIL] Custom dictionary path configured but files not found${nl}"
            }
        }
        else {
            $output += "  [INFO] No custom dictpath configured (uses system default)${nl}"
        }
    }
    catch {
        $output += "  [ERROR] $($_.Exception.Message)${nl}"
    }

    # Determine status - dictcheck enabled AND pam_pwquality loaded AND wordlists available
    if ($dictCheckPass -and $pamStr -and $wordlistFound) {
        $Status = "NotAFinding"
    }

    $FindingDetails = $output.TrimEnd()
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263654 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263654
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263654r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263654"
    $RuleID = "SV-263654r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263654) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263655 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263655
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263655r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263655"
    $RuleID = "SV-263655r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263655) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263656 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263656
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263656r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263656"
    $RuleID = "SV-263656r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263656) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263657 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263657
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263657r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263657"
    $RuleID = "SV-263657r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263657) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263658 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263658
        STIG ID    : SRG-OS-000755-GPOS-00220
        Rule ID    : SV-263658r982561_rule
        Rule Title : The operating system must monitor the use of maintenance tools that execute with increased privilege.
        DiscussMD5 : 01af889ff92a2e2d0fb297005442e57d
        CheckMD5   : c6dd4b132084bc300dc955e32750e1d5
        FixMD5     : e39678d284b536d5e8d6e71f3fab2011
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263658"
    $RuleID = "SV-263658r982561_rule"
    $Status = "Open"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $nl = [Environment]::NewLine
    $auditIssues = 0

    $FindingDetails += "CHECK 1: auditd Service Status" + $nl
    $FindingDetails += "------------------------------" + $nl
    $auditdStatus = $(timeout 5 systemctl is-active auditd 2>&1)
    $FindingDetails += "Service active: $auditdStatus" + $nl
    if ($auditdStatus -ne "active") {
        $auditIssues++
        $FindingDetails += "FAIL: auditd is not active" + $nl
    }
    else {
        $FindingDetails += "PASS: auditd is running" + $nl
    }

    $FindingDetails += $nl + "CHECK 2: Audit Rules for Maintenance Tool Execution" + $nl
    $FindingDetails += "----------------------------------------------------" + $nl
    $auditRules = $(timeout 5 auditctl -l 2>&1)
    if ($auditRules -and ($auditRules -notmatch "No rules")) {
        $maintTools = @("/usr/sbin/fdisk", "/usr/sbin/parted", "/usr/sbin/mkfs", "/usr/sbin/fsck",
                        "/usr/sbin/debugfs", "/usr/sbin/tune2fs", "/usr/sbin/resize2fs",
                        "/usr/bin/mount", "/usr/bin/umount", "/usr/sbin/lvm",
                        "/usr/sbin/mdadm", "/usr/sbin/iptables", "/usr/sbin/nftables",
                        "/usr/sbin/tcpdump", "/usr/sbin/ip", "/usr/bin/strace",
                        "/usr/bin/ltrace", "/usr/bin/gdb")
        $toolsFound = 0
        $ruleLines = ($auditRules -split $nl)
        foreach ($tool in $maintTools) {
            $escaped = [regex]::Escape($tool)
            $match = $ruleLines | Where-Object { $_ -match $escaped }
            if ($match) {
                $toolsFound++
            }
        }
        $FindingDetails += "Maintenance tools with audit rules: $toolsFound of $($maintTools.Count)" + $nl
        $privRules = $ruleLines | Where-Object { $_ -match "execve" -or $_ -match "-F perm=x" -or $_ -match "-F auid>=1000" -or $_ -match "privileged" }
        $privCount = ($privRules | Measure-Object).Count
        $FindingDetails += "Privileged execution rules: $privCount" + $nl
        foreach ($r in ($privRules | Select-Object -First 5)) {
            $FindingDetails += "  $($r.Trim())" + $nl
        }
        if ($toolsFound -ge 3 -or $privCount -ge 2) {
            $FindingDetails += "PASS: Maintenance tool audit rules detected" + $nl
        }
        else {
            $auditIssues++
            $FindingDetails += "FAIL: Insufficient audit rules for maintenance tools" + $nl
        }
    }
    else {
        $auditIssues++
        $FindingDetails += "FAIL: No audit rules configured" + $nl
    }

    $FindingDetails += $nl + "CHECK 3: Maintenance Tool Execution Events" + $nl
    $FindingDetails += "-------------------------------------------" + $nl
    $auditLog = $(timeout 5 grep -c -E "type=SYSCALL.*(fdisk|parted|mkfs|fsck|debugfs|mount|umount|iptables|tcpdump|strace|gdb)|type=USER_CMD.*(fdisk|parted|mkfs|fsck)" /var/log/audit/audit.log 2>&1)
    if ($LASTEXITCODE -eq 0 -and $auditLog -match "^\d+$") {
        $eventCount = [int]$auditLog
        $FindingDetails += "Maintenance tool events in audit log: $eventCount" + $nl
        if ($eventCount -gt 0) {
            $recentEvents = $(timeout 5 grep -E "type=SYSCALL.*(fdisk|parted|mkfs|fsck|debugfs|mount|umount|iptables|tcpdump|strace|gdb)|type=USER_CMD.*(fdisk|parted|mkfs|fsck)" /var/log/audit/audit.log 2>&1 | tail -3)
            foreach ($evt in ($recentEvents -split $nl | Select-Object -First 3)) {
                $FindingDetails += "  $($evt.Trim())" + $nl
            }
            $FindingDetails += "PASS: Maintenance tool events recorded" + $nl
        }
        else {
            $FindingDetails += "INFO: No recent maintenance tool events (tools may not have been used)" + $nl
        }
    }
    else {
        $authEvents = $(timeout 5 grep -c -E "sudo:.*(fdisk|parted|mkfs|fsck|debugfs|mount|umount|iptables|tcpdump|strace|gdb)" /var/log/auth.log 2>&1)
        if ($LASTEXITCODE -eq 0 -and $authEvents -match "^\d+$") {
            $FindingDetails += "Maintenance tool sudo events in auth.log: $authEvents" + $nl
        }
        else {
            $FindingDetails += "INFO: Unable to query audit/auth logs for maintenance tool events" + $nl
        }
    }


    # Check 4: XO Audit Plugin (Application-Layer Auditing)
    $FindingDetails += $nl + "--- Check 4: XO Audit Plugin ---" + $nl
    $xoAuditInfo = Get-XOAuditPluginInfo
    if ($xoAuditInfo.Enabled) {
        $FindingDetails += "  XO Audit Plugin: ACTIVE" + $nl
        $FindingDetails += "  Recent audit records: $($xoAuditInfo.RecordCount)" + $nl
        $FindingDetails += "  Hash chain integrity: $($xoAuditInfo.HasIntegrity)" + $nl
        $FindingDetails += "  Token source: $($xoAuditInfo.TokenSource)" + $nl
        $FindingDetails += "  [INFO] XO Audit Plugin provides maintenance and administrative operation recording via authenticated action tracking" + $nl
    }
    else {
        $FindingDetails += "  XO Audit Plugin: NOT DETECTED" + $nl
        $FindingDetails += "  Reason: $($xoAuditInfo.Details)" + $nl
        $FindingDetails += "  [INFO] No application-layer audit compensation available" + $nl
    }
    $FindingDetails += $nl

    if ($auditIssues -eq 0) {
        $Status = "NotAFinding"
    }
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263659 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263659
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263659r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263659"
    $RuleID = "SV-263659r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263659) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263660 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263660
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263660r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263660"
    $RuleID = "SV-263660r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263660) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}
Function Get-V263661 {
    <#
    .DESCRIPTION
        Vuln ID    : V-263661
        STIG ID    : SRG-OS-000001-GPOS-00001
        Rule ID    : SV-263661r877420_rule
        Rule Title : [STUB] General Purpose Operating System SRG check
        DiscussMD5 : 00000000000000000000000000000000000
        CheckMD5   : 00000000000000000000000000000000
        FixMD5     : 00000000000000000000000000000000
    #>

    param (
        [Parameter(Mandatory = $true)]
        [String]$ScanType,

        [Parameter(Mandatory = $false)]
        [String]$AnswerFile,

        [Parameter(Mandatory = $false)]
        [String]$AnswerKey,


        [Parameter(Mandatory = $false)]
        [String]$Username,

        [Parameter(Mandatory = $false)]
        [String]$UserSID,

        [Parameter(Mandatory = $false)]
        [String]$Hostname,
        [Parameter(Mandatory = $false)]
        [String]$Instance,

        [Parameter(Mandatory = $false)]
        [String]$Database,

        [Parameter(Mandatory = $false)]
        [String]$SiteName
    )

    $ModuleName = (Get-Command $MyInvocation.MyCommand).Source
    $VulnID = "V-263661"
    $RuleID = "SV-263661r877420_rule"
    $Status = "Not_Reviewed"
    $FindingDetails = ""
    $Comments = ""
    $AFKey = ""
    $AFStatus = ""
    $SeverityOverride = ""
    $Justification = ""

    #---=== Begin Custom Code ===---#
    $FindingDetails = "This check requires manual review of Debian 12 system configuration. " +
                      "Refer to the General Purpose Operating System SRG (V-263661) for detailed requirements. " +
                      "Evidence should include system configuration files, security policies, and operational procedures."
    #---=== End Custom Code ===---#

    if ($FindingDetails.Trim().Length -gt 0) {
        $ResultHash = Get-TextHash -Text $FindingDetails -Algorithm SHA1
    }
    else {
        $ResultHash = ""
    }

    if ($PSBoundParameters.AnswerFile) {
        $GetCorpParams = @{
            AnswerFile   = $PSBoundParameters.AnswerFile
            VulnID       = $VulnID
            RuleID       = $RuleID
            AnswerKey    = $PSBoundParameters.AnswerKey
            Status       = $Status
            Hostname     = $Hostname
            Username     = $Username
            UserSID      = $UserSID
            Instance     = $Instance
            Database     = $Database
            Site         = $SiteName
            ResultHash   = $ResultHash
            ResultData   = $FindingDetails
            ESPath       = $ESPath
            LogPath      = $LogPath
            LogComponent = $LogComponent
            OSPlatform   = $OSPlatform
        }

        $AnswerData = (Get-CorporateComment @GetCorpParams)
        if ($Status -eq $AnswerData.ExpectedStatus) {
            $AFKey = $AnswerData.AFKey
            $AFStatus = $AnswerData.AFStatus
            $Comments = $AnswerData.AFComment | Out-String
        }
    }

    $SendCheckParams = @{
        Module           = $ModuleName
        Status           = $Status
        FindingDetails   = $FindingDetails
        AFKey            = $AFKey
        AFStatus         = $AFStatus
        Comments         = $Comments
        SeverityOverride = $SeverityOverride
        Justification    = $Justification
        HeadInstance     = $Instance
        HeadDatabase     = $Database
        HeadSite         = $SiteName
        HeadHash         = $ResultHash
    }

    return Send-CheckResult @SendCheckParams
}

Export-ModuleMember -Function Get-V*
